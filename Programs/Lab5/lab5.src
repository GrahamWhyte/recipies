       section   code
**********************************************************************************************************
* CSTART.ASM  -  C startup-code
*
*          Initialises the system prior to running the users main() program
*
*          1) Sets up the user program stack pointer
*          2) Switches to User mode in the 68000
*          3) Enables All Interrupts 1-7 on 68000
*          4) Copies all initialised C program variables from Rom to Ram prior to running main()
*
**********************************************************************************************************
                align


**********************************************************************************************************
* The Following ORG Statement marks the address of the start of the this CStart Program
*
* The debug Monitor and Flash Load and Program routines assume your program lives here
**********************************************************************************************************
                org       $08000000
start:          move.w    #$2000,SR             clear interrupts to enable all, move to supervisor mode

******************************************************************************************
* Set unitialised global variables to 0 at startup
******************************************************************************************
mainloop        movea.l   #BssStart,a0          point a0 to the start of the initialised data section held in ROM
                move.l    #BssLength,d0         figure out how many bytes of C program variables data to copy
                beq       go_main               if no data to copy go straight to program
Zeroinit        move.b    #0,(a0)+              copy the C program initialise variables from rom to ram
                subq.l    #1,d0
                bne       Zeroinit

*******************************************************************************************
* last minute initialisation before calling main
*******************************************************************************************

                move.l    #-1,__ungetbuf         required for use of scanf() etc in C programs
                clr.l     __allocp               used by malloc() in C
                move.l    #heap,__heap           pointer to free memory
go_main         jsr       _main
                bra       start

; C:\M68KV6.0 - 640BY480\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS\PROGRAMS\LAB5\IIC_DRIVER.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
; #include <stdlib.h>
; #include "IIC_Driver.h"
; /* Globals */
; volatile unsigned char *IICClkPrescalerLow = (unsigned char *)IIC_CLK_PRSCL_LO;
; volatile unsigned char *IICClkPrescalerHigh = (unsigned char *)IIC_CLK_PRSCL_HI;
; volatile unsigned char *IICControl = (unsigned char *)IIC_CONTROL;
; volatile unsigned char *IICTx = (unsigned char *)IIC_TRANSMIT;
; volatile unsigned char *IICRx = (unsigned char *)IIC_RECEIVE;
; volatile unsigned char *IICStatus = (unsigned char *)IIC_STATUS;
; volatile unsigned char *IICCommand = (unsigned char *)IIC_COMMAND;
; // *IICClkPrescalerLow = (unsigned char *)IIC_CLK_PRSCL_LO;
; // *IICClkPrescalerHigh = (unsigned char *)IIC_CLK_PRSCL_HI;
; // *IICControl = (unsigned char *)IIC_CONTROL;
; // *IICTx = (unsigned char *)IIC_TRANSMIT;
; // *IICRx = (unsigned char *)IIC_RECEIVE;
; // *IICStatus = (unsigned char *)IIC_STATUS;
; // *IICCommand = (unsigned char *)IIC_COMMAND;
; /* Functions */
; void WaitForEndOfTransfer(void) {
_WaitForEndOfTransfer:
; while (1){							
WaitForEndOfTransfer_1:
; if ( ( (*IICStatus) & TIP) == 0)	
       move.l    _IICStatus.L,A0
       move.b    (A0),D0
       and.b     #2,D0
       bne.s     WaitForEndOfTransfer_4
; break;							
       bra.s     WaitForEndOfTransfer_3
WaitForEndOfTransfer_4:
       bra       WaitForEndOfTransfer_1
WaitForEndOfTransfer_3:
       rts
; }			
; }
; void WaitForAck(void) {
_WaitForAck:
; while (1){								
WaitForAck_1:
; if ( ( (*IICStatus) & RxACK) == 0 )	
       move.l    _IICStatus.L,A0
       move.b    (A0),D0
       and.w     #255,D0
       and.w     #128,D0
       bne.s     WaitForAck_4
; break;							
       bra.s     WaitForAck_3
WaitForAck_4:
       bra       WaitForAck_1
WaitForAck_3:
       rts
; }				
; }	
; unsigned char EEPROMInternalWritting(void) {
_EEPROMInternalWritting:
; return ( ( (*IICStatus) & RxACK) == 0 );
       move.l    _IICStatus.L,A0
       move.b    (A0),D0
       and.w     #255,D0
       and.w     #128,D0
       bne.s     EEPROMInternalWritting_1
       moveq     #1,D0
       bra.s     EEPROMInternalWritting_2
EEPROMInternalWritting_1:
       clr.l     D0
EEPROMInternalWritting_2:
       rts
; }
; void Init_IIC(void) {
_Init_IIC:
; *IICControl = 0;
       move.l    _IICControl.L,A0
       clr.b     (A0)
; *IICClkPrescalerLow = CLK_100K_LO;
       move.l    _IICClkPrescalerLow.L,A0
       move.b    #49,(A0)
; *IICClkPrescalerHigh = CLK_100K_HI;
       move.l    _IICClkPrescalerHigh.L,A0
       clr.b     (A0)
; *IICControl = CORE_ENABLED | INTERRUPT_DISABLED;
       move.l    _IICControl.L,A0
       move.b    #128,(A0)
       rts
; } 
; void WriteByte(unsigned char IICSlaveAddress, unsigned char byteToStore, unsigned int EEPROMAddress) {
_WriteByte:
       link      A6,#-4
       movem.l   D2/A2/A3/A4/A5,-(A7)
       lea       _WaitForAck.L,A2
       lea       _WaitForEndOfTransfer.L,A3
       lea       _IICCommand.L,A4
       lea       _IICTx.L,A5
       move.l    16(A6),D2
; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
       move.l    D2,D0
       lsr.b     #8,D0
       lsr.b     #8,D0
       move.b    D0,-3(A6)
; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
       move.l    D2,D0
       lsr.l     #8,D0
       move.b    D0,-2(A6)
; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
       move.b    D2,-1(A6)
; IICSlaveAddress |= (blockSelect << 3);  
       move.b    -3(A6),D0
       lsl.b     #3,D0
       or.b      D0,11(A6)
; // Transfer IIC Slave Address
; WaitForInternalWrite(IICSlaveAddress);
       move.b    11(A6),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       jsr       _WaitForInternalWrite
       addq.w    #4,A7
; // Transfer High EEProm Address
; *IICTx = EEPROMAddress_High;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -2(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A4),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
; // Transfer Low EEProm Address
; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -1(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A4),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
; // Send Data
; *IICTx = byteToStore;
       move.l    (A5),A0
       move.b    15(A6),(A0)
; *IICCommand = WR | STO;	//send stop signal
       move.l    (A4),A0
       move.b    #80,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
       movem.l   (A7)+,D2/A2/A3/A4/A5
       unlk      A6
       rts
; }
; unsigned char ReadByte(unsigned char IICSlaveAddress, unsigned int EEPROMAddress) {
_ReadByte:
       link      A6,#-4
       movem.l   D2/D3/A2/A3/A4/A5,-(A7)
       lea       _WaitForEndOfTransfer.L,A2
       lea       _IICCommand.L,A3
       lea       _WaitForAck.L,A4
       lea       _IICTx.L,A5
       move.b    11(A6),D2
       and.l     #255,D2
       move.l    12(A6),D3
; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
       move.l    D3,D0
       lsr.b     #8,D0
       lsr.b     #8,D0
       move.b    D0,-3(A6)
; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
       move.l    D3,D0
       lsr.l     #8,D0
       move.b    D0,-2(A6)
; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
       move.b    D3,-1(A6)
; IICSlaveAddress |= (blockSelect << 3);  
       move.b    -3(A6),D0
       lsl.b     #3,D0
       or.b      D0,D2
; // Transfer IIC Slave Address
; WaitForInternalWrite(IICSlaveAddress);
       and.l     #255,D2
       move.l    D2,-(A7)
       jsr       _WaitForInternalWrite
       addq.w    #4,A7
; // Transfer High EEProm Address
; *IICTx = EEPROMAddress_High;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -2(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A3),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; WaitForAck();
       jsr       (A4)
; // Transfer Low EEProm Address
; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -1(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A3),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; WaitForAck();
       jsr       (A4)
; // Fetch Data
; *IICTx = IICSlaveAddress | READ;
       move.b    D2,D0
       or.b      #1,D0
       move.l    (A5),A0
       move.b    D0,(A0)
; *IICCommand = WR | STA;	//send stop signal
       move.l    (A3),A0
       move.b    #144,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; WaitForAck();
       jsr       (A4)
; // read SDA line
; *IICCommand = RD | STO | NACK;	//send stop signal
       move.l    (A3),A0
       move.b    #104,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; return *IICRx;
       move.l    _IICRx.L,A0
       move.b    (A0),D0
       movem.l   (A7)+,D2/D3/A2/A3/A4/A5
       unlk      A6
       rts
; }
; void WaitForInternalWrite(unsigned char IICSlaveAddress) {
_WaitForInternalWrite:
       link      A6,#0
; do {
WaitForInternalWrite_1:
; *IICTx = IICSlaveAddress | WRITE;	// fill the tx shift register
       move.b    11(A6),D0
       or.b      #0,D0
       move.l    _IICTx.L,A0
       move.b    D0,(A0)
; *IICCommand = STA | WR;	// set write bit
       move.l    _IICCommand.L,A0
       move.b    #144,(A0)
; WaitForEndOfTransfer();
       jsr       _WaitForEndOfTransfer
       jsr       _EEPROMInternalWritting
       tst.b     D0
       beq       WaitForInternalWrite_1
       unlk      A6
       rts
; } while (!EEPROMInternalWritting());
; }
; void Write_128_Bytes(unsigned char IICSlaveAddress, unsigned int EEPROMAddress, unsigned char *iicArray) {
_Write_128_Bytes:
       link      A6,#-4
       movem.l   D2/D3/A2/A3/A4/A5,-(A7)
       lea       _WaitForAck.L,A2
       lea       _WaitForEndOfTransfer.L,A3
       lea       _IICCommand.L,A4
       lea       _IICTx.L,A5
       move.l    12(A6),D3
; int i; 
; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
       move.l    D3,D0
       lsr.b     #8,D0
       lsr.b     #8,D0
       move.b    D0,-3(A6)
; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
       move.l    D3,D0
       lsr.l     #8,D0
       move.b    D0,-2(A6)
; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
       move.b    D3,-1(A6)
; IICSlaveAddress |= (blockSelect << 3);  
       move.b    -3(A6),D0
       lsl.b     #3,D0
       or.b      D0,11(A6)
; // Transfer IIC Slave Address
; WaitForInternalWrite(IICSlaveAddress);
       move.b    11(A6),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       jsr       _WaitForInternalWrite
       addq.w    #4,A7
; // Transfer High EEProm Address
; *IICTx = EEPROMAddress_High;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -2(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A4),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
; // Transfer Low EEProm Address
; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -1(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A4),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
; for (i=0; i<127; i++)
       clr.l     D2
Write_128_Bytes_1:
       cmp.l     #127,D2
       bge.s     Write_128_Bytes_3
; {
; *IICTx = iicArray[i];
       move.l    16(A6),A0
       move.l    (A5),A1
       move.b    0(A0,D2.L),(A1)
; *IICCommand = WR;	// set write bit
       move.l    (A4),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
       addq.l    #1,D2
       bra       Write_128_Bytes_1
Write_128_Bytes_3:
; }
; // Send Data
; *IICTx = iicArray[127];
       move.l    16(A6),A0
       move.l    (A5),A1
       move.b    127(A0),(A1)
; *IICCommand = WR | STO;	//send stop signal
       move.l    (A4),A0
       move.b    #80,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
       movem.l   (A7)+,D2/D3/A2/A3/A4/A5
       unlk      A6
       rts
; }
; void Read_128_Bytes(unsigned char IICSlaveAddress, unsigned int EEPROMAddress, unsigned char *buffer){
_Read_128_Bytes:
       link      A6,#-4
       movem.l   D2/D3/D4/A2/A3/A4/A5,-(A7)
       lea       _WaitForEndOfTransfer.L,A2
       lea       _IICCommand.L,A3
       lea       _WaitForAck.L,A4
       lea       _IICTx.L,A5
       move.b    11(A6),D3
       and.l     #255,D3
       move.l    12(A6),D4
; int i; 
; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
       move.l    D4,D0
       lsr.b     #8,D0
       lsr.b     #8,D0
       move.b    D0,-3(A6)
; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
       move.l    D4,D0
       lsr.l     #8,D0
       move.b    D0,-2(A6)
; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
       move.b    D4,-1(A6)
; IICSlaveAddress |= (blockSelect << 3);  
       move.b    -3(A6),D0
       lsl.b     #3,D0
       or.b      D0,D3
; // Transfer IIC Slave Address
; WaitForInternalWrite(IICSlaveAddress);
       and.l     #255,D3
       move.l    D3,-(A7)
       jsr       _WaitForInternalWrite
       addq.w    #4,A7
; // Transfer High EEProm Address
; *IICTx = EEPROMAddress_High;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -2(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A3),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; WaitForAck();
       jsr       (A4)
; // Transfer Low EEProm Address
; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -1(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A3),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; WaitForAck();
       jsr       (A4)
; // Fetch Data
; *IICTx = IICSlaveAddress | READ;
       move.b    D3,D0
       or.b      #1,D0
       move.l    (A5),A0
       move.b    D0,(A0)
; *IICCommand = WR | STA;	//send start signal
       move.l    (A3),A0
       move.b    #144,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; WaitForAck();
       jsr       (A4)
; for (i=0; i<127; i++)
       clr.l     D2
Read_128_Bytes_1:
       cmp.l     #127,D2
       bge.s     Read_128_Bytes_3
; {
; *IICCommand = RD;
       move.l    (A3),A0
       move.b    #32,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; buffer[i] = *IICRx; 
       move.l    _IICRx.L,A0
       move.l    16(A6),A1
       move.b    (A0),0(A1,D2.L)
       addq.l    #1,D2
       bra       Read_128_Bytes_1
Read_128_Bytes_3:
; }
; // read SDA line
; *IICCommand = RD | STO | NACK;	//send stop signal
       move.l    (A3),A0
       move.b    #104,(A0)
; WaitForEndOfTransfer();
       jsr       (A2)
; buffer[127] = *IICRx; 
       move.l    _IICRx.L,A0
       move.l    16(A6),A1
       move.b    (A0),127(A1)
       movem.l   (A7)+,D2/D3/D4/A2/A3/A4/A5
       unlk      A6
       rts
; }
; void WriteBytes(unsigned char IICSlaveAddress, unsigned int EEPROMAddress, unsigned char *iicArray, unsigned int length){
_WriteBytes:
       link      A6,#-12
       movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
       move.l    12(A6),D4
       lea       _IICCommand.L,A2
       lea       _WaitForAck.L,A3
       lea       _WaitForEndOfTransfer.L,A4
       lea       _IICTx.L,A5
       move.l    16(A6),D6
       move.b    11(A6),D7
       and.l     #255,D7
; int i; 
; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
       move.l    D4,D0
       lsr.b     #8,D0
       lsr.b     #8,D0
       move.b    D0,-11(A6)
; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
       move.l    D4,D0
       lsr.l     #8,D0
       move.b    D0,-10(A6)
; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
       move.b    D4,-9(A6)
; unsigned int bytesToWrite; 
; unsigned char lengthFlag = 0; 
       clr.b     -3(A6)
; int lengthCopy = (int)length;  
       move.l    20(A6),D5
; unsigned int CurrentAddress = EEPROMAddress; 
       move.l    D4,D2
; unsigned char CurrentAddress_High;
; unsigned char CurrentAddress_Low; 
; IICSlaveAddress |= (blockSelect << 3);  
       move.b    -11(A6),D0
       lsl.b     #3,D0
       or.b      D0,D7
; // Transfer IIC Slave Address
; WaitForInternalWrite(IICSlaveAddress);
       and.l     #255,D7
       move.l    D7,-(A7)
       jsr       _WaitForInternalWrite
       addq.w    #4,A7
; // Transfer High EEProm Address
; *IICTx = EEPROMAddress_High;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -10(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A4)
; WaitForAck();
       jsr       (A3)
; // Transfer Low EEProm Address
; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -9(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A4)
; WaitForAck();
       jsr       (A3)
; // Check difference between starting address and next block 
; bytesToWrite = 128-EEPROMAddress%128; 
       move.w    #128,D0
       ext.l     D0
       move.l    D4,-(A7)
       pea       128
       jsr       ULDIV
       move.l    4(A7),D1
       addq.w    #8,A7
       sub.l     D1,D0
       move.l    D0,-8(A6)
; // First block 
; for (i=0; i<bytesToWrite; i++)
       clr.l     D3
WriteBytes_1:
       cmp.l     -8(A6),D3
       bhs       WriteBytes_3
; {
; printf("\r\nEntered First Block Loop"); 
       pea       @iic_dr~1_1.L
       jsr       _printf
       addq.w    #4,A7
; *IICTx = iicArray[i];
       move.l    D6,A0
       move.l    (A5),A1
       move.b    0(A0,D3.L),(A1)
; if ( (i+1 >= length) || (i==(bytesToWrite-1)))
       move.l    D3,D0
       addq.l    #1,D0
       cmp.l     20(A6),D0
       bhs.s     WriteBytes_6
       move.l    -8(A6),D0
       subq.l    #1,D0
       cmp.l     D0,D3
       bne.s     WriteBytes_4
WriteBytes_6:
; {
; if (i+1 >= length)
       move.l    D3,D0
       addq.l    #1,D0
       cmp.l     20(A6),D0
       blo.s     WriteBytes_7
; lengthFlag = 1;
       move.b    #1,-3(A6)
WriteBytes_7:
; *IICCommand = WR | STO;	//send stop signal 
       move.l    (A2),A0
       move.b    #80,(A0)
       bra.s     WriteBytes_5
WriteBytes_4:
; }
; else
; {
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
WriteBytes_5:
; }
; WaitForEndOfTransfer();
       jsr       (A4)
; WaitForAck();
       jsr       (A3)
; lengthCopy--; 
       subq.l    #1,D5
; CurrentAddress++; 
       addq.l    #1,D2
; if (lengthFlag)
       tst.b     -3(A6)
       beq.s     WriteBytes_9
; {
; break; 
       bra.s     WriteBytes_3
WriteBytes_9:
       addq.l    #1,D3
       bra       WriteBytes_1
WriteBytes_3:
; }
; }
; // Other blocks
; if (!lengthFlag)
       tst.b     -3(A6)
       bne       WriteBytes_16
; {
; // Complete blocks
; while (lengthCopy >= 128)
WriteBytes_13:
       cmp.l     #128,D5
       blt       WriteBytes_15
; {
; printf("\r\n Entered Intermediate Loop"); 
       pea       @iic_dr~1_2.L
       jsr       _printf
       addq.w    #4,A7
; printf("\r\n Current Address Index: %x", CurrentAddress-EEPROMAddress); 
       move.l    D2,D1
       sub.l     D4,D1
       move.l    D1,-(A7)
       pea       @iic_dr~1_3.L
       jsr       _printf
       addq.w    #8,A7
; Write_128_Bytes(0xA6, CurrentAddress, &(iicArray[CurrentAddress-EEPROMAddress])); 
       move.l    D6,D1
       move.l    D0,-(A7)
       move.l    D2,D0
       sub.l     D4,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       move.l    D2,-(A7)
       pea       166
       jsr       _Write_128_Bytes
       add.w     #12,A7
; CurrentAddress+=128; 
       add.l     #128,D2
; lengthCopy-=128; 
       sub.l     #128,D5
       bra       WriteBytes_13
WriteBytes_15:
; }
; if (lengthCopy>0)
       cmp.l     #0,D5
       ble       WriteBytes_16
; {
; // Prepare for write to final block
; blockSelect = (unsigned char)CurrentAddress>>16; 
       move.l    D2,D0
       lsr.b     #8,D0
       lsr.b     #8,D0
       move.b    D0,-11(A6)
; CurrentAddress_High = (unsigned char)(CurrentAddress>>8);
       move.l    D2,D0
       lsr.l     #8,D0
       move.b    D0,-2(A6)
; CurrentAddress_Low = (unsigned char)(CurrentAddress);
       move.b    D2,-1(A6)
; IICSlaveAddress |= (blockSelect << 3);  
       move.b    -11(A6),D0
       lsl.b     #3,D0
       or.b      D0,D7
; // Transfer IIC Slave Address
; WaitForInternalWrite(IICSlaveAddress);
       and.l     #255,D7
       move.l    D7,-(A7)
       jsr       _WaitForInternalWrite
       addq.w    #4,A7
; // Transfer High EEProm Address
; *IICTx = CurrentAddress_High;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -2(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A4)
; WaitForAck();
       jsr       (A3)
; // Transfer Low EEProm Address
; *IICTx = CurrentAddress_Low;	// fill the tx shift register
       move.l    (A5),A0
       move.b    -1(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A4)
; WaitForAck();
       jsr       (A3)
; // Last block
; for (i=0; i<lengthCopy-1; i++)
       clr.l     D3
WriteBytes_18:
       move.l    D5,D0
       subq.l    #1,D0
       cmp.l     D0,D3
       bge       WriteBytes_20
; {
; printf("\r\n Entered Last Block Loop"); 
       pea       @iic_dr~1_4.L
       jsr       _printf
       addq.w    #4,A7
; printf("\r\n Current Address Index: %x", CurrentAddress-EEPROMAddress); 
       move.l    D2,D1
       sub.l     D4,D1
       move.l    D1,-(A7)
       pea       @iic_dr~1_3.L
       jsr       _printf
       addq.w    #8,A7
; *IICTx = iicArray[CurrentAddress-EEPROMAddress];
       move.l    D6,A0
       move.l    D2,D0
       sub.l     D4,D0
       move.l    (A5),A1
       move.b    0(A0,D0.L),(A1)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A4)
; WaitForAck();
       jsr       (A3)
; CurrentAddress+=1; 
       addq.l    #1,D2
       addq.l    #1,D3
       bra       WriteBytes_18
WriteBytes_20:
; }
; // Final byte
; *IICTx = iicArray[CurrentAddress-EEPROMAddress];
       move.l    D6,A0
       move.l    D2,D0
       sub.l     D4,D0
       move.l    (A5),A1
       move.b    0(A0,D0.L),(A1)
; *IICCommand = WR | STO;	// set write bit
       move.l    (A2),A0
       move.b    #80,(A0)
; WaitForEndOfTransfer();
       jsr       (A4)
; WaitForAck();
       jsr       (A3)
WriteBytes_16:
; }
; }
; printf("\r\n Exited All Loops"); 
       pea       @iic_dr~1_5.L
       jsr       _printf
       addq.w    #4,A7
       movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
       unlk      A6
       rts
; }
; void ReadBytes(unsigned char IICSlaveAddress, unsigned int EEPROMAddress, unsigned char *buffer, unsigned int length){
_ReadBytes:
       link      A6,#-12
       movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
       lea       _IICCommand.L,A2
       move.l    12(A6),D4
       lea       _WaitForEndOfTransfer.L,A3
       lea       _printf.L,A4
       lea       _WaitForAck.L,A5
       move.b    11(A6),D5
       and.l     #255,D5
       move.l    16(A6),D7
; int i; 
; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
       move.l    D4,D0
       lsr.b     #8,D0
       lsr.b     #8,D0
       move.b    D0,-11(A6)
; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
       move.l    D4,D0
       lsr.l     #8,D0
       move.b    D0,-10(A6)
; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
       move.b    D4,-9(A6)
; unsigned int bytesToRead; 
; unsigned char lengthFlag = 0; 
       clr.b     -3(A6)
; int lengthCopy = (int)length;  
       move.l    20(A6),D6
; unsigned int CurrentAddress = EEPROMAddress; 
       move.l    D4,D2
; unsigned char CurrentAddress_High;
; unsigned char CurrentAddress_Low; 
; IICSlaveAddress |= (blockSelect << 3);  
       move.b    -11(A6),D0
       lsl.b     #3,D0
       or.b      D0,D5
; // Transfer IIC Slave Address
; WaitForInternalWrite(IICSlaveAddress);
       and.l     #255,D5
       move.l    D5,-(A7)
       jsr       _WaitForInternalWrite
       addq.w    #4,A7
; // Transfer High EEProm Address
; *IICTx = EEPROMAddress_High;	// fill the tx shift register
       move.l    _IICTx.L,A0
       move.b    -10(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A5)
; // Transfer Low EEProm Address
; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
       move.l    _IICTx.L,A0
       move.b    -9(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A5)
; // Fetch Data
; *IICTx = IICSlaveAddress | READ;
       move.b    D5,D0
       or.b      #1,D0
       move.l    _IICTx.L,A0
       move.b    D0,(A0)
; *IICCommand = WR | STA;	//send start signal
       move.l    (A2),A0
       move.b    #144,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A5)
; // Check difference between starting address and next block 
; bytesToRead = 128-EEPROMAddress%128; 
       move.w    #128,D0
       ext.l     D0
       move.l    D4,-(A7)
       pea       128
       jsr       ULDIV
       move.l    4(A7),D1
       addq.w    #8,A7
       sub.l     D1,D0
       move.l    D0,-8(A6)
; // First block 
; for (i=0; i<bytesToRead; i++)
       clr.l     D3
ReadBytes_1:
       cmp.l     -8(A6),D3
       bhs       ReadBytes_3
; {
; printf("\r\nEntered First Block Loop"); 
       pea       @iic_dr~1_1.L
       jsr       (A4)
       addq.w    #4,A7
; if ( (i+1 >= length) || (i==(bytesToRead-1)))
       move.l    D3,D0
       addq.l    #1,D0
       cmp.l     20(A6),D0
       bhs.s     ReadBytes_6
       move.l    -8(A6),D0
       subq.l    #1,D0
       cmp.l     D0,D3
       bne.s     ReadBytes_4
ReadBytes_6:
; {
; if (i+1 >= length)
       move.l    D3,D0
       addq.l    #1,D0
       cmp.l     20(A6),D0
       blo.s     ReadBytes_7
; lengthFlag = 1;
       move.b    #1,-3(A6)
ReadBytes_7:
; *IICCommand = RD | STO | NACK;	//send stop signal 
       move.l    (A2),A0
       move.b    #104,(A0)
       bra.s     ReadBytes_5
ReadBytes_4:
; }
; else
; {
; *IICCommand = RD;	// set write bit
       move.l    (A2),A0
       move.b    #32,(A0)
ReadBytes_5:
; }
; WaitForEndOfTransfer();
       jsr       (A3)
; buffer[i] = *IICRx; 
       move.l    _IICRx.L,A0
       move.l    D7,A1
       move.b    (A0),0(A1,D3.L)
; lengthCopy--; 
       subq.l    #1,D6
; CurrentAddress++; 
       addq.l    #1,D2
; if (lengthFlag)
       tst.b     -3(A6)
       beq.s     ReadBytes_9
; {
; break; 
       bra.s     ReadBytes_3
ReadBytes_9:
       addq.l    #1,D3
       bra       ReadBytes_1
ReadBytes_3:
; }
; }
; // Other blocks
; if (!lengthFlag)
       tst.b     -3(A6)
       bne       ReadBytes_16
; {
; // Complete blocks
; while (lengthCopy >= 128)
ReadBytes_13:
       cmp.l     #128,D6
       blt       ReadBytes_15
; {
; printf("\r\n Entered Intermediate Loop"); 
       pea       @iic_dr~1_2.L
       jsr       (A4)
       addq.w    #4,A7
; printf("\r\n Current Address Index: %x", CurrentAddress-EEPROMAddress); 
       move.l    D2,D1
       sub.l     D4,D1
       move.l    D1,-(A7)
       pea       @iic_dr~1_3.L
       jsr       (A4)
       addq.w    #8,A7
; Read_128_Bytes(0xA6, CurrentAddress, &(buffer[CurrentAddress-EEPROMAddress])); 
       move.l    D7,D1
       move.l    D0,-(A7)
       move.l    D2,D0
       sub.l     D4,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       move.l    D2,-(A7)
       pea       166
       jsr       _Read_128_Bytes
       add.w     #12,A7
; CurrentAddress+=128; 
       add.l     #128,D2
; lengthCopy-=128; 
       sub.l     #128,D6
       bra       ReadBytes_13
ReadBytes_15:
; }
; if (lengthCopy>0)
       cmp.l     #0,D6
       ble       ReadBytes_16
; {
; // Prepare for write to final block
; blockSelect = (unsigned char)CurrentAddress>>16; 
       move.l    D2,D0
       lsr.b     #8,D0
       lsr.b     #8,D0
       move.b    D0,-11(A6)
; CurrentAddress_High = (unsigned char)(CurrentAddress>>8);
       move.l    D2,D0
       lsr.l     #8,D0
       move.b    D0,-2(A6)
; CurrentAddress_Low = (unsigned char)(CurrentAddress);
       move.b    D2,-1(A6)
; IICSlaveAddress |= (blockSelect << 3);  
       move.b    -11(A6),D0
       lsl.b     #3,D0
       or.b      D0,D5
; // Transfer IIC Slave Address
; WaitForInternalWrite(IICSlaveAddress);
       and.l     #255,D5
       move.l    D5,-(A7)
       jsr       _WaitForInternalWrite
       addq.w    #4,A7
; // Transfer High EEProm Address
; *IICTx = CurrentAddress_High;	// fill the tx shift register
       move.l    _IICTx.L,A0
       move.b    -2(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A5)
; // Transfer Low EEProm Address
; *IICTx = CurrentAddress_Low;	// fill the tx shift register
       move.l    _IICTx.L,A0
       move.b    -1(A6),(A0)
; *IICCommand = WR;	// set write bit
       move.l    (A2),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A5)
; // Fetch Data
; *IICTx = IICSlaveAddress | READ;
       move.b    D5,D0
       or.b      #1,D0
       move.l    _IICTx.L,A0
       move.b    D0,(A0)
; *IICCommand = WR | STA;	//send start signal
       move.l    (A2),A0
       move.b    #144,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A5)
; // Last block
; for (i=0; i<lengthCopy-1; i++)
       clr.l     D3
ReadBytes_18:
       move.l    D6,D0
       subq.l    #1,D0
       cmp.l     D0,D3
       bge       ReadBytes_20
; {
; printf("\r\n Entered Last Block Loop"); 
       pea       @iic_dr~1_4.L
       jsr       (A4)
       addq.w    #4,A7
; printf("\r\n Current Address Index: %x", CurrentAddress-EEPROMAddress); 
       move.l    D2,D1
       sub.l     D4,D1
       move.l    D1,-(A7)
       pea       @iic_dr~1_3.L
       jsr       (A4)
       addq.w    #8,A7
; *IICCommand = RD;	// set read bit
       move.l    (A2),A0
       move.b    #32,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; buffer[CurrentAddress-EEPROMAddress] = *IICRx; 
       move.l    _IICRx.L,A0
       move.l    D7,A1
       move.l    D2,D0
       sub.l     D4,D0
       move.b    (A0),0(A1,D0.L)
; CurrentAddress+=1; 
       addq.l    #1,D2
       addq.l    #1,D3
       bra       ReadBytes_18
ReadBytes_20:
; }
; // Final byte
; *IICCommand = RD | STO | NACK;	// set read bit
       move.l    (A2),A0
       move.b    #104,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; buffer[CurrentAddress-EEPROMAddress] = *IICRx; 
       move.l    _IICRx.L,A0
       move.l    D7,A1
       move.l    D2,D0
       sub.l     D4,D0
       move.b    (A0),0(A1,D0.L)
ReadBytes_16:
; }
; }
; printf("\r\n Exited All Loops"); 
       pea       @iic_dr~1_5.L
       jsr       (A4)
       addq.w    #4,A7
       movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
       unlk      A6
       rts
; }
; C:\M68KV6.0 - 640BY480\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS\PROGRAMS\LAB5\M68KUSERPROGRAM (DE1).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
; #include <stdio.h>
; #include <string.h>
; #include <ctype.h>
; #include "IIC_Driver.h"
; #include "ADC_DAC.h"
; //IMPORTANT
; //
; // Uncomment one of the two #defines below
; // Define StartOfExceptionVectorTable as 08030000 if running programs from sram or
; // 0B000000 for running programs from dram
; //
; // In your labs, you will initially start by designing a system with SRam and later move to
; // Dram, so these constants will need to be changed based on the version of the system you have
; // building
; //
; // The working 68k system SOF file posted on canvas that you can use for your pre-lab
; // is based around Dram so #define accordingly before building
; #define MAX_SPI_ADDRESS 0x7FFFF
; #define NUM_SECTORS 128
; #define WRITES_PER_SECTOR 16
; // #define StartOfExceptionVectorTable 0x08030000
; #define StartOfExceptionVectorTable 0x0B000000
; // #define CLOCK_FREQUENCY 45000000
; #define CLOCK_FREQUENCY 25000000
; /**********************************************************************************************
; **	Parallel port addresses
; **********************************************************************************************/
; #define PortA   *(volatile unsigned char *)(0x00400000)
; #define PortB   *(volatile unsigned char *)(0x00400002)
; #define PortC   *(volatile unsigned char *)(0x00400004)
; #define PortD   *(volatile unsigned char *)(0x00400006)
; #define PortE   *(volatile unsigned char *)(0x00400008)
; // /*********************************************************************************************
; // **	Hex 7 seg displays port addresses
; // *********************************************************************************************/
; #define HEX_A        *(volatile unsigned char *)(0x00400010)
; #define HEX_B        *(volatile unsigned char *)(0x00400012)
; #define HEX_C        *(volatile unsigned char *)(0x00400014)    // de2 only
; #define HEX_D        *(volatile unsigned char *)(0x00400016)    // de2 only
; /**********************************************************************************************
; **	LCD display port addresses
; **********************************************************************************************/
; #define LCDcommand   *(volatile unsigned char *)(0x00400020)
; #define LCDdata      *(volatile unsigned char *)(0x00400022)
; /*******************************************************************************************
; **	Timer Port addresses
; ********************************************************************************************/
; #define Timer1Data      *(volatile unsigned char *)(0x00400030)
; #define Timer1Control   *(volatile unsigned char *)(0x00400032)
; #define Timer1Status    *(volatile unsigned char *)(0x00400032)
; #define Timer2Data      *(volatile unsigned char *)(0x00400034)
; #define Timer2Control   *(volatile unsigned char *)(0x00400036)
; #define Timer2Status    *(volatile unsigned char *)(0x00400036)
; #define Timer3Data      *(volatile unsigned char *)(0x00400038)
; #define Timer3Control   *(volatile unsigned char *)(0x0040003A)
; #define Timer3Status    *(volatile unsigned char *)(0x0040003A)
; #define Timer4Data      *(volatile unsigned char *)(0x0040003C)
; #define Timer4Control   *(volatile unsigned char *)(0x0040003E)
; #define Timer4Status    *(volatile unsigned char *)(0x0040003E)
; // /*********************************************************************************************
; // **	RS232 port addresses
; // *********************************************************************************************/
; #define RS232_Control     *(volatile unsigned char *)(0x00400040)
; #define RS232_Status      *(volatile unsigned char *)(0x00400040)
; #define RS232_TxData      *(volatile unsigned char *)(0x00400042)
; #define RS232_RxData      *(volatile unsigned char *)(0x00400042)
; #define RS232_Baud        *(volatile unsigned char *)(0x00400044)
; /*********************************************************************************************
; **	PIA 1 and 2 port addresses
; *********************************************************************************************/
; #define PIA1_PortA_Data     *(volatile unsigned char *)(0x00400050)         // combined data and data direction register share same address
; #define PIA1_PortA_Control *(volatile unsigned char *)(0x00400052)
; #define PIA1_PortB_Data     *(volatile unsigned char *)(0x00400054)         // combined data and data direction register share same address
; #define PIA1_PortB_Control *(volatile unsigned char *)(0x00400056)
; #define PIA2_PortA_Data     *(volatile unsigned char *)(0x00400060)         // combined data and data direction register share same address
; #define PIA2_PortA_Control *(volatile unsigned char *)(0x00400062)
; #define PIA2_PortB_data     *(volatile unsigned char *)(0x00400064)         // combined data and data direction register share same address
; #define PIA2_PortB_Control *(volatile unsigned char *)(0x00400066)
; // SPI Registers
; #define SPI_Control         (*(volatile unsigned char *)(0x00408020))
; #define SPI_Status          (*(volatile unsigned char *)(0x00408022))
; #define SPI_Data            (*(volatile unsigned char *)(0x00408024))
; #define SPI_Ext             (*(volatile unsigned char *)(0x00408026))
; #define SPI_CS              (*(volatile unsigned char *)(0x00408028))
; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
; // and write FF to disable it
; #define   Enable_SPI_CS()             SPI_CS = 0xFE
; #define   Disable_SPI_CS()            SPI_CS = 0xFF 
; typedef struct 
; {
; unsigned char SPR       : 2;
; unsigned char CPHA      : 1;
; unsigned char CPOL      : 1; 
; unsigned char MSTR      : 1;
; unsigned char reserved  : 1; 
; unsigned char SPE       : 1;
; unsigned char SPIE      : 1; 
; } ControlRegister_t; 
; typedef struct 
; {
; unsigned char ESPR      : 2;
; unsigned char Reserved  : 4;
; unsigned char ICNT      : 2; 
; } ExtRegister_t;
; typedef struct 
; {
; unsigned char CS0       : 1; 
; unsigned char CS1       : 1; 
; unsigned char CS2       : 1; 
; unsigned char CS3       : 1; 
; unsigned char CS4       : 1; 
; unsigned char CS5       : 1; 
; unsigned char CS6       : 1; 
; unsigned char CS7       : 1; 
; } CSRegister_t;
; typedef struct 
; {
; unsigned char SPIF      : 1;
; unsigned char WCOL      : 1;
; unsigned char reserved  : 2; 
; unsigned char WF_FULL   : 1;
; unsigned char WF_EMPTY  : 1; 
; unsigned char RF_FULL   : 1;
; unsigned char RF_EMPTY  : 1; 
; } StatusRegister_t; 
; /*********************************************************************************************************************************
; (( DO NOT initialise global variables here, do it main even if you want 0
; (( it's a limitation of the compiler
; (( YOU HAVE BEEN WARNED
; *********************************************************************************************************************************/
; unsigned int x, y, z, PortA_Count;
; unsigned char Timer1Count, Timer2Count, Timer3Count, Timer4Count ;
; volatile unsigned long int counter, rollovers;
; int a[100][100], b[100][100], c[100][100];
; int i, j, k, sum;
; /*******************************************************************************************
; ** Function Prototypes
; *******************************************************************************************/
; void Wait1ms(void);
; void Wait3ms(void);
; void Init_LCD(void) ;
; void LCDOutchar(int c);
; void LCDOutMess(char *theMessage);
; void LCDClearln(void);
; void LCDline1Message(char *theMessage);
; void LCDline2Message(char *theMessage);
; int sprintf(char *out, const char *format, ...) ;
; void startTimer(void);
; unsigned long int endTimer(void);
; /*****************************************************************************************
; **	Interrupt service routine for Timers
; **
; **  Timers 1 - 4 share a common IRQ on the CPU  so this function uses polling to figure
; **  out which timer is producing the interrupt
; **
; *****************************************************************************************/
; void Timer_ISR()
; {
_Timer_ISR:
; if(Timer1Status == 1) {         // Did Timer 1 produce the Interrupt?
       move.b    4194354,D0
       cmp.b     #1,D0
       bne.s     Timer_ISR_3
; Timer1Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
       move.b    #3,4194354
; //PortA = Timer1Count++ ;     // increment an LED count on PortA with each tick of Timer 1
; counter++;
       addq.l    #1,_counter.L
; if (!counter)   //handle the counter rolling over, who knows, maybe something will take an eternity to run
       tst.l     _counter.L
       bne.s     Timer_ISR_3
; rollovers++;
       addq.l    #1,_rollovers.L
Timer_ISR_3:
; }
; if(Timer2Status == 1) {         // Did Timer 2 produce the Interrupt?
       move.b    4194358,D0
       cmp.b     #1,D0
       bne.s     Timer_ISR_5
; Timer2Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
       move.b    #3,4194358
; PortC = Timer2Count++ ;     // increment an LED count on PortC with each tick of Timer 2
       move.b    _Timer2Count.L,D0
       addq.b    #1,_Timer2Count.L
       move.b    D0,4194308
Timer_ISR_5:
; }
; if(Timer3Status == 1) {         // Did Timer 3 produce the Interrupt?
       move.b    4194362,D0
       cmp.b     #1,D0
       bne.s     Timer_ISR_7
; Timer3Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
       move.b    #3,4194362
; HEX_A = Timer3Count++ ;     // increment a HEX count on Port HEX_A with each tick of Timer 3
       move.b    _Timer3Count.L,D0
       addq.b    #1,_Timer3Count.L
       move.b    D0,4194320
Timer_ISR_7:
; }
; if(Timer4Status == 1) {         // Did Timer 4 produce the Interrupt?
       move.b    4194366,D0
       cmp.b     #1,D0
       bne.s     Timer_ISR_9
; Timer4Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
       move.b    #3,4194366
; HEX_B = Timer4Count++ ;     // increment a HEX count on HEX_B with each tick of Timer 4
       move.b    _Timer4Count.L,D0
       addq.b    #1,_Timer4Count.L
       move.b    D0,4194322
Timer_ISR_9:
       rts
; }
; }
; /*****************************************************************************************
; **	Interrupt service routine for ACIA. This device has it's own dedicate IRQ level
; **  Add your code here to poll Status register and clear interrupt
; *****************************************************************************************/
; void ACIA_ISR()
; {}
_ACIA_ISR:
       rts
; /***************************************************************************************
; **	Interrupt service routine for PIAs 1 and 2. These devices share an IRQ level
; **  Add your code here to poll Status register and clear interrupt
; *****************************************************************************************/
; void PIA_ISR()
; {}
_PIA_ISR:
       rts
; /***********************************************************************************
; **	Interrupt service routine for Key 2 on DE1 board. Add your own response here
; ************************************************************************************/
; void Key2PressISR()
; {}
_Key2PressISR:
       rts
; /***********************************************************************************
; **	Interrupt service routine for Key 1 on DE1 board. Add your own response here
; ************************************************************************************/
; void Key1PressISR()
; {}
_Key1PressISR:
       rts
; /************************************************************************************
; **   Delay Subroutine to give the 68000 something useless to do to waste 1 mSec
; ************************************************************************************/
; void Wait1ms(void)
; {
_Wait1ms:
       move.l    D2,-(A7)
; int  i ;
; for(i = 0; i < 1000; i ++)
       clr.l     D2
Wait1ms_1:
       cmp.l     #1000,D2
       bge.s     Wait1ms_3
       addq.l    #1,D2
       bra       Wait1ms_1
Wait1ms_3:
       move.l    (A7)+,D2
       rts
; ;
; }
; /************************************************************************************
; **  Subroutine to give the 68000 something useless to do to waste 3 mSec
; **************************************************************************************/
; void Wait3ms(void)
; {
_Wait3ms:
       move.l    D2,-(A7)
; int i ;
; for(i = 0; i < 3; i++)
       clr.l     D2
Wait3ms_1:
       cmp.l     #3,D2
       bge.s     Wait3ms_3
; Wait1ms() ;
       jsr       _Wait1ms
       addq.l    #1,D2
       bra       Wait3ms_1
Wait3ms_3:
       move.l    (A7)+,D2
       rts
; }
; /*********************************************************************************************
; **  Subroutine to initialise the LCD display by writing some commands to the LCD internal registers
; **  Sets it for parallel port and 2 line display mode (if I recall correctly)
; *********************************************************************************************/
; void Init_LCD(void)
; {
_Init_LCD:
; LCDcommand = 0x0c ;
       move.b    #12,4194336
; Wait3ms() ;
       jsr       _Wait3ms
; LCDcommand = 0x38 ;
       move.b    #56,4194336
; Wait3ms() ;
       jsr       _Wait3ms
       rts
; }
; /*********************************************************************************************
; **  Subroutine to initialise the RS232 Port by writing some commands to the internal registers
; *********************************************************************************************/
; void Init_RS232(void)
; {
_Init_RS232:
; RS232_Control = 0x15 ; //  %00010101 set up 6850 uses divide by 16 clock, set RTS low, 8 bits no parity, 1 stop bit, transmitter interrupt disabled
       move.b    #21,4194368
; RS232_Baud = 0x1 ;      // program baud rate generator 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
       move.b    #1,4194372
       rts
; }
; /*********************************************************************************************************
; **  Subroutine to provide a low level output function to 6850 ACIA
; **  This routine provides the basic functionality to output a single character to the serial Port
; **  to allow the board to communicate with HyperTerminal Program
; **
; **  NOTE you do not call this function directly, instead you call the normal putchar() function
; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
; **  call _putch() also
; *********************************************************************************************************/
; int _putch( int c)
; {
__putch:
       link      A6,#0
; while((RS232_Status & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
_putch_1:
       move.b    4194368,D0
       and.b     #2,D0
       cmp.b     #2,D0
       beq.s     _putch_3
       bra       _putch_1
_putch_3:
; ;
; RS232_TxData = (c & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
       move.l    8(A6),D0
       and.l     #127,D0
       move.b    D0,4194370
; return c ;                                              // putchar() expects the character to be returned
       move.l    8(A6),D0
       unlk      A6
       rts
; }
; /*********************************************************************************************************
; **  Subroutine to provide a low level input function to 6850 ACIA
; **  This routine provides the basic functionality to input a single character from the serial Port
; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
; **
; **  NOTE you do not call this function directly, instead you call the normal getchar() function
; **  which in turn calls _getch() below). Other functions like gets(), scanf() call getchar() so will
; **  call _getch() also
; *********************************************************************************************************/
; int _getch( void )
; {
__getch:
       link      A6,#-4
; char c ;
; while((RS232_Status & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
_getch_1:
       move.b    4194368,D0
       and.b     #1,D0
       cmp.b     #1,D0
       beq.s     _getch_3
       bra       _getch_1
_getch_3:
; ;
; return (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
       move.b    4194370,D0
       and.l     #255,D0
       and.l     #127,D0
       unlk      A6
       rts
; }
; /******************************************************************************
; **  Subroutine to output a single character to the 2 row LCD display
; **  It is assumed the character is an ASCII code and it will be displayed at the
; **  current cursor position
; *******************************************************************************/
; void LCDOutchar(int c)
; {
_LCDOutchar:
       link      A6,#0
; LCDdata = (char)(c);
       move.l    8(A6),D0
       move.b    D0,4194338
; Wait1ms() ;
       jsr       _Wait1ms
       unlk      A6
       rts
; }
; /**********************************************************************************
; *subroutine to output a message at the current cursor position of the LCD display
; ************************************************************************************/
; void LCDOutMessage(char *theMessage)
; {
_LCDOutMessage:
       link      A6,#-4
; char c ;
; while((c = *theMessage++) != 0)     // output characters from the string until NULL
LCDOutMessage_1:
       move.l    8(A6),A0
       addq.l    #1,8(A6)
       move.b    (A0),-1(A6)
       move.b    (A0),D0
       beq.s     LCDOutMessage_3
; LCDOutchar(c) ;
       move.b    -1(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       jsr       _LCDOutchar
       addq.w    #4,A7
       bra       LCDOutMessage_1
LCDOutMessage_3:
       unlk      A6
       rts
; }
; /******************************************************************************
; *subroutine to clear the line by issuing 24 space characters
; *******************************************************************************/
; void LCDClearln(void)
; {
_LCDClearln:
       move.l    D2,-(A7)
; int i ;
; for(i = 0; i < 24; i ++)
       clr.l     D2
LCDClearln_1:
       cmp.l     #24,D2
       bge.s     LCDClearln_3
; LCDOutchar(' ') ;       // write a space char to the LCD display
       pea       32
       jsr       _LCDOutchar
       addq.w    #4,A7
       addq.l    #1,D2
       bra       LCDClearln_1
LCDClearln_3:
       move.l    (A7)+,D2
       rts
; }
; /******************************************************************************
; **  Subroutine to move the LCD cursor to the start of line 1 and clear that line
; *******************************************************************************/
; void LCDLine1Message(char *theMessage)
; {
_LCDLine1Message:
       link      A6,#0
; LCDcommand = 0x80 ;
       move.b    #128,4194336
; Wait3ms();
       jsr       _Wait3ms
; LCDClearln() ;
       jsr       _LCDClearln
; LCDcommand = 0x80 ;
       move.b    #128,4194336
; Wait3ms() ;
       jsr       _Wait3ms
; LCDOutMessage(theMessage) ;
       move.l    8(A6),-(A7)
       jsr       _LCDOutMessage
       addq.w    #4,A7
       unlk      A6
       rts
; }
; /******************************************************************************
; **  Subroutine to move the LCD cursor to the start of line 2 and clear that line
; *******************************************************************************/
; void LCDLine2Message(char *theMessage)
; {
_LCDLine2Message:
       link      A6,#0
; LCDcommand = 0xC0 ;
       move.b    #192,4194336
; Wait3ms();
       jsr       _Wait3ms
; LCDClearln() ;
       jsr       _LCDClearln
; LCDcommand = 0xC0 ;
       move.b    #192,4194336
; Wait3ms() ;
       jsr       _Wait3ms
; LCDOutMessage(theMessage) ;
       move.l    8(A6),-(A7)
       jsr       _LCDOutMessage
       addq.w    #4,A7
       unlk      A6
       rts
; }
; /*********************************************************************************************************************************
; **  IMPORTANT FUNCTION
; **  This function install an exception handler so you can capture and deal with any 68000 exception in your program
; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
; **  Calling this function allows you to deal with Interrupts for example
; ***********************************************************************************************************************************/
; void InstallExceptionHandler( void (*function_ptr)(), int level)
; {
_InstallExceptionHandler:
       link      A6,#-4
; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
       move.l    #184549376,-4(A6)
; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
       move.l    -4(A6),A0
       move.l    12(A6),D0
       lsl.l     #2,D0
       move.l    8(A6),0(A0,D0.L)
       unlk      A6
       rts
; }
; /******************************************************************************************
; ** The following code is for the SPI controller
; *******************************************************************************************/
; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
; // this can be used in a polling algorithm to know when the controller is busy or idle.
; int TestForSPITransmitDataComplete(void)    {
_TestForSPITransmitDataComplete:
; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
; return (SPI_Status>>7);
       move.b    4227106,D0
       and.l     #255,D0
       lsr.l     #7,D0
       rts
; }
; /************************************************************************************
; ** initialises the SPI controller chip to set speed, interrupt capability etc.
; ************************************************************************************/
; void SPI_Init(void)
; {
_SPI_Init:
; //TODO
; //
; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
; // Don't forget to call this routine from main() before you do anything else with SPI
; //
; // Here are some settings we want to create
; //
; // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
; // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
; // SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
; // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
; // ControlRegister_t tempControl; 
; // memset(&SPI_Control, 0, sizeof(unsigned char)); 
; // memset(&tempControl, 0, sizeof(ControlRegister_t));
; // tempControl.SPIE = 0; 
; // tempControl.SPE = 1; 
; // tempControl.MSTR = 1; 
; // tempControl.CPOL = 0;
; // tempControl.CPHA = 0; 
; // tempControl.SPR = 3; 
; // SPI_Control = (volatile unsigned char)tempControl; 
; // SPI_Control = (unsigned char)0b01010011; 
; SPI_Control = (unsigned char)0x53;
       move.b    #83,4227104
; SPI_Ext = (unsigned char)0x00; 
       clr.b     4227110
; Disable_SPI_CS(); 
       move.b    #255,4227112
       rts
; }
; /************************************************************************************
; ** return ONLY when the SPI controller has finished transmitting a byte
; ************************************************************************************/
; void WaitForSPITransmitComplete(void)
; {
_WaitForSPITransmitComplete:
; // TODO : poll the status register SPIF bit looking for completion of transmission
; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
; // just in case they were set
; // while ((SPI_Status>>7)==0);
; while (1) {
WaitForSPITransmitComplete_1:
; if (SPI_Status & (unsigned char)0x80) {
       move.b    4227106,D0
       and.b     #128,D0
       beq.s     WaitForSPITransmitComplete_4
; break;
       bra.s     WaitForSPITransmitComplete_3
WaitForSPITransmitComplete_4:
       bra       WaitForSPITransmitComplete_1
WaitForSPITransmitComplete_3:
; }
; }
; // SPI_Status &= 0x3F; // And with 00111111 to clear top two bits
; SPI_Status = (unsigned char)0xC0;  
       move.b    #192,4227106
       rts
; }
; /************************************************************************************
; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
; ** given back by SPI device at the same time (removes the read byte from the FIFO)
; ************************************************************************************/
; int WriteSPIChar(int c)
; {
_WriteSPIChar:
       link      A6,#-4
; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
; // wait for completion of transmission
; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
; // by reading fom the SPI controller Data Register.
; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
; //
; // modify '0' below to return back read byte from data register
; //
; unsigned char temp;
; // Load data register
; SPI_Data = (unsigned char)c; 
       move.l    8(A6),D0
       move.b    D0,4227108
; // Poll for completion 
; WaitForSPITransmitComplete(); 
       jsr       _WaitForSPITransmitComplete
; temp = SPI_Data;
       move.b    4227108,-1(A6)
; // printf("\r\nRead: %x", temp);
; // Read data register
; return (int)temp;  
       move.b    -1(A6),D0
       and.l     #255,D0
       unlk      A6
       rts
; }
; void ChipErase() {
_ChipErase:
       move.l    A2,-(A7)
       lea       _WriteSPIChar.L,A2
; // wren
; Enable_SPI_CS();
       move.b    #254,4227112
; WriteSPIChar(0x06);
       pea       6
       jsr       (A2)
       addq.w    #4,A7
; Disable_SPI_CS(); 
       move.b    #255,4227112
; //chip erase
; Enable_SPI_CS();
       move.b    #254,4227112
; WriteSPIChar(0x60);
       pea       96
       jsr       (A2)
       addq.w    #4,A7
; Disable_SPI_CS(); 
       move.b    #255,4227112
; //wait for WIP
; Enable_SPI_CS();
       move.b    #254,4227112
; WriteSPIChar(0x05);
       pea       5
       jsr       (A2)
       addq.w    #4,A7
; while((WriteSPIChar(0x55)&0x01) == 1);
ChipErase_1:
       pea       85
       jsr       (A2)
       addq.w    #4,A7
       and.l     #1,D0
       cmp.l     #1,D0
       bne.s     ChipErase_3
       bra       ChipErase_1
ChipErase_3:
; Disable_SPI_CS();
       move.b    #255,4227112
       move.l    (A7)+,A2
       rts
; }
; void WriteData(int startAddress, unsigned char *dataArray, int numBytes) {
_WriteData:
       link      A6,#0
       movem.l   D2/D3/A2,-(A7)
       lea       _WriteSPIChar.L,A2
       move.l    8(A6),D3
; int i = 0;
       clr.l     D2
; // wren command
; Enable_SPI_CS();
       move.b    #254,4227112
; WriteSPIChar(0x06);
       pea       6
       jsr       (A2)
       addq.w    #4,A7
; Disable_SPI_CS(); 
       move.b    #255,4227112
; // write command
; Enable_SPI_CS();
       move.b    #254,4227112
; WriteSPIChar(0x02); //page program command
       pea       2
       jsr       (A2)
       addq.w    #4,A7
; WriteSPIChar(startAddress>>16); //addres high
       move.l    D3,D1
       asr.l     #8,D1
       asr.l     #8,D1
       move.l    D1,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; WriteSPIChar(startAddress>>8); // address middle
       move.l    D3,D1
       asr.l     #8,D1
       move.l    D1,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; WriteSPIChar(startAddress); //address low
       move.l    D3,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; //stream data
; for (i; i < numBytes; i++) {
WriteData_1:
       cmp.l     16(A6),D2
       bge.s     WriteData_3
; WriteSPIChar((int)dataArray[i]);
       move.l    12(A6),A0
       move.b    0(A0,D2.L),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       jsr       (A2)
       addq.w    #4,A7
       addq.l    #1,D2
       bra       WriteData_1
WriteData_3:
; }
; Disable_SPI_CS();
       move.b    #255,4227112
; //wait for internal writing    
; Enable_SPI_CS();
       move.b    #254,4227112
; WriteSPIChar(0x05);
       pea       5
       jsr       (A2)
       addq.w    #4,A7
; while((WriteSPIChar(0x55)&0x01) == 1);
WriteData_4:
       pea       85
       jsr       (A2)
       addq.w    #4,A7
       and.l     #1,D0
       cmp.l     #1,D0
       bne.s     WriteData_6
       bra       WriteData_4
WriteData_6:
; Disable_SPI_CS();
       move.b    #255,4227112
       movem.l   (A7)+,D2/D3/A2
       unlk      A6
       rts
; }
; void ReadData(int startAddress, int numBytes, unsigned char *data) {
_ReadData:
       link      A6,#0
       movem.l   D2/D3/A2,-(A7)
       lea       _WriteSPIChar.L,A2
       move.l    8(A6),D3
; int i = 0;
       clr.l     D2
; Enable_SPI_CS();
       move.b    #254,4227112
; WriteSPIChar(0x03); //read command
       pea       3
       jsr       (A2)
       addq.w    #4,A7
; WriteSPIChar(startAddress>>16); //addres high
       move.l    D3,D1
       asr.l     #8,D1
       asr.l     #8,D1
       move.l    D1,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; WriteSPIChar(startAddress>>8); // address middle
       move.l    D3,D1
       asr.l     #8,D1
       move.l    D1,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; WriteSPIChar(startAddress); //address low
       move.l    D3,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; //stream data
; for (i; i < numBytes; i++) {
ReadData_1:
       cmp.l     12(A6),D2
       bge.s     ReadData_3
; data[i] = (unsigned char)WriteSPIChar(0x55); //dummy byte
       pea       85
       jsr       (A2)
       addq.w    #4,A7
       move.l    16(A6),A0
       move.b    D0,0(A0,D2.L)
       addq.l    #1,D2
       bra       ReadData_1
ReadData_3:
; }
; Disable_SPI_CS();
       move.b    #255,4227112
       movem.l   (A7)+,D2/D3/A2
       unlk      A6
       rts
; }
; void startTimer(void) {
_startTimer:
; counter = 0;
       clr.l     _counter.L
; rollovers = 0;
       clr.l     _rollovers.L
       rts
; }
; unsigned long int endTimer(void) {
_endTimer:
; return counter + (rollovers * sizeof(counter) * 256);
       move.l    _counter.L,D0
       move.l    _rollovers.L,-(A7)
       pea       4
       jsr       ULMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    D1,-(A7)
       pea       256
       jsr       ULMUL
       move.l    (A7),D1
       addq.w    #8,A7
       add.l     D1,D0
       rts
; }
; /******************************************************************************************************************************
; * Start of user program
; ******************************************************************************************************************************/
; void main()
; {
_main:
       link      A6,#-1040
       move.l    D2,-(A7)
; unsigned char iicArray[512]; 
; unsigned char readBuffer[512]; 
; unsigned char temp;
; unsigned int address; 
; unsigned int startingAddress = 0x40; 
       move.l    #64,-8(A6)
; int i; 
; int length = 500; 
       move.l    #500,-4(A6)
; // Populate test array 
; for (i=0; i<length; i++)
       clr.l     D2
main_1:
       cmp.l     -4(A6),D2
       bge.s     main_3
; {
; iicArray[i] = 0xFF; 
       lea       -1038(A6),A0
       move.b    #255,0(A0,D2.L)
       addq.l    #1,D2
       bra       main_1
main_3:
; }
; printf("\r\nInitializing IIC Controller");
       pea       @m68kus~1_1.L
       jsr       _printf
       addq.w    #4,A7
; Init_IIC();
       jsr       _Init_IIC
; printf("\r\nDone initialization, sending a byte...");
       pea       @m68kus~1_2.L
       jsr       _printf
       addq.w    #4,A7
; // WriteByte(0xA6, 0x42, (unsigned int)0x55);
; // printf("\r\nDone writing!");
; // temp = ReadByte(0xA6, (unsigned int)0x55);
; // printf("\r\nRead back %x!", temp);
; // Write_128_Bytes(0xA6, 0x00, iicArray); 
; // temp = ReadByte(0xA6, 0x00);
; // printf("\r\nRead back %x!", temp);
; // temp = ReadByte(0xA6, 0x05);
; // printf("\r\nRead back %x!", temp);
; // temp = ReadByte(0xA6, 0x7F);
; // printf("\r\nRead back %x!", temp);
; // Read_128_Bytes(0xA6, 0x00, readBuffer); 
; // for (i=0; i<128; i++)
; // {
; //     printf("\r\nRead back %x!", readBuffer[i]);
; // }
; /**********************************************
; * Testing Read/Write Bytes functions
; **********************************************/
; // WriteBytes(0xA6, startingAddress, iicArray, length); 
; // ReadBytes(0xA6, startingAddress, readBuffer, length); 
; // for (i=0; i<length; i++)
; // {
; //     printf("\r\nRead back %x from %x!", readBuffer[i], startingAddress+i);
; // }
; // temp = ReadByte(0xA6, 0x40);
; // printf("\r\nRead back %x!", temp);
; // temp = ReadByte(0xA6, 0x7f);
; // printf("\r\nRead back %x!", temp);
; // temp = ReadByte(0xA6, 0x80);
; // printf("\r\nRead back %x!", temp);
; // temp = ReadByte(0xA6, 0x81);
; // printf("\r\nRead back %x!", temp);
; // for (address = startingAddress; address < startingAddress+length; address++)
; // {
; //     temp = ReadByte(0xA6, address);
; //     printf("\r\nRead back %x from %x!", temp, address);
; // }
; DigitalToAnalog(ADC_SLAVE_ADDRESS, iicArray, sizeof(iicArray)); 
       pea       512
       pea       -1038(A6)
       pea       158
       jsr       _DigitalToAnalog
       add.w     #12,A7
; while(1);
main_4:
       bra       main_4
; }
; C:\M68KV6.0 - 640BY480\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS\PROGRAMS\LAB5\ADC_DAC.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
; #include <stdio.h> 
; #include "IIC_Driver.h"
; #include "ADC_DAC.h"
; // Globals
; volatile unsigned char *IICTx_ = (unsigned char *)IIC_TRANSMIT;
; volatile unsigned char *IICRx_ = (unsigned char *)IIC_RECEIVE;
; volatile unsigned char *IICCommand_ = (unsigned char *)IIC_COMMAND;
; /* Functions */ 
; void DigitalToAnalog(unsigned char slaveAddress, unsigned char *data, unsigned int size) {
_DigitalToAnalog:
       link      A6,#0
       movem.l   D2/A2/A3/A4/A5,-(A7)
       lea       _WaitForAck.L,A2
       lea       _WaitForEndOfTransfer.L,A3
       lea       _IICCommand_.L,A4
       lea       _IICTx_.L,A5
; int i; 
; // Generate IIC start signal
; *IICTx_ = slaveAddress | WRITE;	// fill the tx shift register
       move.b    11(A6),D0
       or.b      #0,D0
       move.l    (A5),A0
       move.b    D0,(A0)
; *IICCommand_ = STA | WR;	// set write bit
       move.l    (A4),A0
       move.b    #144,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck(); 
       jsr       (A2)
; printf("\r\n Generated Start Signal"); 
       pea       @adc_dac_1.L
       jsr       _printf
       addq.w    #4,A7
; // Send Control Byte 
; *IICTx_ = ANALOG_OUTPUT_ENABLE | SINGLE_ENDED | AD_CH_0; 
       move.l    (A5),A0
       move.b    #64,(A0)
; *IICCommand_ = WR;	// set write bit
       move.l    (A4),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
; printf("\r\n Sent Control Byte"); 
       pea       @adc_dac_2.L
       jsr       _printf
       addq.w    #4,A7
; // Steam Data Byte 
; while (1)
DigitalToAnalog_1:
; {
; for (i = 0; i < size; i++)
       clr.l     D2
DigitalToAnalog_4:
       cmp.l     16(A6),D2
       bhs.s     DigitalToAnalog_6
; {
; *IICTx_ = data[i]; 
       move.l    12(A6),A0
       move.l    (A5),A1
       move.b    0(A0,D2.L),(A1)
; *IICCommand_ = WR; 
       move.l    (A4),A0
       move.b    #16,(A0)
; WaitForEndOfTransfer();
       jsr       (A3)
; WaitForAck();
       jsr       (A2)
       addq.l    #1,D2
       bra       DigitalToAnalog_4
DigitalToAnalog_6:
       bra       DigitalToAnalog_1
; }
; }
; }
ULDIV:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       bra.s   ldiv_3
LDIV:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       tst.l   D0
       bpl.s   ldiv_1
       neg.l   D0
       tst.l   D1
       bpl.s   ldiv_2
       neg.l   D1
       bsr.s   dodiv
       neg.l   D1
       bra.s   ldiv_4
ldiv_1:
       tst.l   D1
       bpl.s   ldiv_3
       neg.l   D1
       bsr.s   dodiv
       neg.l   D0
       bra.s   ldiv_4
ldiv_2:
       bsr.s   dodiv
       neg.l   D0
       neg.l   D1
       bra.s   ldiv_4
ldiv_3:
       bsr.s   dodiv
ldiv_4:
       move.l  D0,8(A6)
       move.l  D1,12(A6)
       movem.l (A7)+,D0/D1
       unlk    A6
       rts
dodiv:
       cmpi.l  #$FFFF,D1
       bhi.s   dodiv_2
       cmpi.l  #$FFFF,D0
       bhi.s   dodiv_1
       divu    D1,D0
       move.l  D0,D1
       clr.w   D1
       swap    D1
       andi.l  #$FFFF,D0
       rts
dodiv_1:
       movem.w D0/D2,-(A7)
       clr.w   D0
       swap    D0
       divu    D1,D0
       move.w  D0,D2
       move.w  (A7)+,D0
       divu    D1,D0
       swap    D0
       clr.l   D1
       move.w  D0,D1
       move.w  D2,D0
       swap    D0
       move.w  (A7)+,D2
       rts
dodiv_2:
       movem.l D2/D3/D4,-(A7)
       move.l  D1,D2
       clr.w   D2
       swap    D2
       addq.l  #1,D2
       move.l  D0,D3
       move.l  D1,D4
       move.l  D2,D1
       bsr.s   dodiv_1
       move.l  D4,D1
       divu    D2,D1
       divu    D1,D0
       andi.l  #$FFFF,D0
dodiv_3:
       move.l  D4,D1
       move.l  D4,D2
       swap    D2
       mulu    D0,D1
       mulu    D0,D2
       swap    D2
       add.l   D2,D1
       sub.l   D3,D1
       bhi.s   dodiv_4
       neg.l   D1
       cmp.l   D1,D4
       bhi.s   dodiv_5
       addq.l  #1,D0
       bra.s   dodiv_3
dodiv_4:
       subq.l  #1,D0
       bra.s   dodiv_3
dodiv_5:
       movem.l (A7)+,D2/D3/D4
       rts
_printf:
       link      A6,#-4
       move.l    D2,-(A7)
       lea       8(A6),A0
       addq.w    #4,A0
       move.l    A0,D2
       move.l    D2,-(A7)
       move.l    8(A6),-(A7)
       clr.l     -(A7)
       jsr       _doprint
       add.w     #12,A7
       move.l    D0,-4(A6)
       clr.l     D2
       move.l    -4(A6),D0
       move.l    (A7)+,D2
       unlk      A6
       rts
ULMUL:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       bra.s   lmul_3
LMUL:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       tst.l   D0
       bpl.s   lmul_1
       neg.l   D0
       tst.l   D1
       bpl.s   lmul_2
       neg.l   D1
       bra.s   lmul_3
lmul_1:
       tst.l   D1
       bpl.s   lmul_3
       neg.l   D1
lmul_2:
       bsr.s   domul
       neg.l   D1
       negx.l  D0
       bra.s   lmul_4
lmul_3:
       bsr.s   domul
lmul_4:
       move.l  D1,8(A6)
       movem.l (A7)+,D0/D1
       unlk    A6
       rts
domul:
       cmpi.l  #$FFFF,D1
       bhi.s   domul_1
       cmpi.l  #$FFFF,D0
       bhi.s   domul_2
       mulu    D0,D1
       rts
domul_1:
       cmpi.l  #$FFFF,D0
       bhi.s   domul_4
       bra.s   domul_3
domul_2
       exg     D0,D1
domul_3:
       move.l  D2,-(A7)
       move.l  D1,D2
       swap    D2
       mulu    D0,D1
       mulu    D0,D2
       swap    D2
       clr.w   D2
       add.l   D2,D1
       move.l  (A7)+,D2
       rts
domul_4:
       movem.l D2/D3,-(A7)
       move.l  D1,D2
       move.l  D1,D3
       mulu    D0,D1
       swap    D2
       mulu    D0,D2
       swap    D0
       mulu    D0,D3
       add.l   D3,D2
       swap    D2
       clr.w   D2
       add.l   D2,D1
       movem.l (A7)+,D2/D3
       rts
@doprint_copy:
       link      A6,#0
       move.l    8(A6),A0
       tst.l     (A0)
       beq.s     @doprint_copy_1
       move.l    12(A6),D0
       move.l    8(A6),A0
       move.l    (A0),A1
       addq.l    #1,(A0)
       move.b    D0,(A1)
       bra.s     @doprint_copy_2
@doprint_copy_1:
       move.l    12(A6),-(A7)
       jsr       _putch
       addq.w    #4,A7
@doprint_copy_2:
       unlk      A6
       rts
@doprint_getval:
       link      A6,#0
       movem.l   D2/D3,-(A7)
       move.l    8(A6),D3
       clr.l     D2
       move.l    D3,A0
       move.l    (A0),A0
       move.b    (A0),D0
       cmp.b     #42,D0
       bne.s     @doprint_getval_1
       move.l    12(A6),A0
       move.l    (A0),A1
       addq.l    #4,(A0)
       move.l    (A1),D2
       move.l    D3,A0
       addq.l    #1,(A0)
       bra       @doprint_getval_5
@doprint_getval_1:
       moveq     #1,D0
       move.l    D3,A0
       move.l    (A0),A0
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       add.l     D1,D0
       lea       __ctype.L,A0
       move.b    0(A0,D0.L),D0
       and.b     #4,D0
       beq.s     @doprint_getval_5
       move.l    D2,-(A7)
       pea       10
       jsr       LMUL
       move.l    (A7),D0
       addq.w    #8,A7
       move.l    D3,A0
       move.l    (A0),A1
       addq.l    #1,(A0)
       move.b    (A1),D1
       ext.w     D1
       ext.l     D1
       add.l     D1,D0
       sub.l     #48,D0
       move.l    D0,D2
       bra       @doprint_getval_1
@doprint_getval_5:
       move.l    D2,D0
       movem.l   (A7)+,D2/D3
       unlk      A6
       rts
_doprint:
       link      A6,#-52
       movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
       lea       8(A6),A2
       lea       @doprint_copy.L,A3
       lea       _ultoa.L,A4
       clr.l     D6
doprint_1:
       move.l    12(A6),A0
       tst.b     (A0)
       beq       doprint_3
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #37,D0
       beq.s     doprint_4
       move.l    12(A6),A0
       addq.l    #1,12(A6)
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       doprint_2
doprint_4:
       addq.l    #1,12(A6)
       clr.b     -45(A6)
       clr.b     -46(A6)
       clr.b     -48(A6)
       clr.b     -49(A6)
       clr.b     -50(A6)
       clr.b     -51(A6)
       clr.l     -4(A6)
       moveq     #-1,D5
       lea       -36(A6),A0
       move.l    A0,D3
       move.l    A0,D2
doprint_6:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #43,D0
       beq.s     doprint_12
       bgt.s     doprint_15
       cmp.l     #35,D0
       beq       doprint_14
       bgt       doprint_9
       cmp.l     #32,D0
       beq.s     doprint_13
       bra.s     doprint_9
doprint_15:
       cmp.l     #45,D0
       beq.s     doprint_11
       bra.s     doprint_9
doprint_11:
       move.b    #1,-51(A6)
       addq.l    #1,12(A6)
       bra.s     doprint_7
doprint_12:
       move.b    #1,-50(A6)
       addq.l    #1,12(A6)
       bra.s     doprint_7
doprint_13:
       move.b    #1,-49(A6)
       addq.l    #1,12(A6)
       bra.s     doprint_7
doprint_14:
       move.b    #1,-48(A6)
       addq.l    #1,12(A6)
       bra.s     doprint_7
doprint_9:
       bra.s     doprint_8
doprint_7:
       bra       doprint_6
doprint_8:
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #48,D0
       bne.s     doprint_16
       addq.l    #1,12(A6)
       move.b    #1,-46(A6)
doprint_16:
       pea       16(A6)
       pea       12(A6)
       jsr       @doprint_getval
       addq.w    #8,A7
       move.l    D0,A5
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #46,D0
       bne.s     doprint_18
       addq.l    #1,12(A6)
       pea       16(A6)
       pea       12(A6)
       jsr       @doprint_getval
       addq.w    #8,A7
       move.l    D0,D5
doprint_18:
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #108,D0
       bne.s     doprint_20
       addq.l    #1,12(A6)
       move.b    #1,-45(A6)
doprint_20:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #111,D0
       beq       doprint_27
       bgt.s     doprint_33
       cmp.l     #100,D0
       beq       doprint_24
       bgt.s     doprint_34
       cmp.l     #99,D0
       beq       doprint_30
       bgt       doprint_22
       cmp.l     #88,D0
       beq       doprint_28
       bra       doprint_22
doprint_34:
       cmp.l     #105,D0
       beq.s     doprint_24
       bra       doprint_22
doprint_33:
       cmp.l     #117,D0
       beq       doprint_26
       bgt.s     doprint_35
       cmp.l     #115,D0
       beq       doprint_31
       bra       doprint_22
doprint_35:
       cmp.l     #120,D0
       beq       doprint_28
       bra       doprint_22
doprint_24:
       tst.b     -45(A6)
       beq.s     doprint_36
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       _ltoa
       add.w     #12,A7
       bra.s     doprint_37
doprint_36:
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       _ltoa
       add.w     #12,A7
doprint_37:
       bra       doprint_23
doprint_26:
       tst.b     -45(A6)
       beq.s     doprint_38
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     doprint_39
doprint_38:
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
doprint_39:
       bra       doprint_23
doprint_27:
       tst.b     -45(A6)
       beq.s     doprint_40
       pea       8
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     doprint_41
doprint_40:
       pea       8
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
doprint_41:
       bra       doprint_23
doprint_28:
       tst.b     -45(A6)
       beq.s     doprint_42
       pea       16
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     doprint_43
doprint_42:
       pea       16
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
doprint_43:
       bra       doprint_23
doprint_30:
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),D0
       move.l    D2,A0
       addq.l    #1,D2
       move.b    D0,(A0)
       move.l    D2,A0
       clr.b     (A0)
       move.l    A5,D0
       beq.s     doprint_44
       move.l    A5,D0
       bra.s     doprint_45
doprint_44:
       moveq     #1,D0
       ext.w     D0
       ext.l     D0
doprint_45:
       move.l    D0,D5
       bra       doprint_23
doprint_31:
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),D3
       cmp.l     #-1,D5
       bne.s     doprint_46
       move.l    D3,-(A7)
       jsr       _strlen
       addq.w    #4,A7
       move.l    D0,D5
doprint_46:
       bra.s     doprint_23
doprint_22:
       move.l    12(A6),A0
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       move.l    D2,A0
       clr.b     (A0)
doprint_23:
       move.l    D3,-(A7)
       jsr       _strlen
       addq.w    #4,A7
       move.b    D0,D4
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #115,D0
       bne.s     doprint_48
       cmp.l     #0,D5
       blt.s     doprint_48
       ext.w     D4
       ext.l     D4
       cmp.l     D5,D4
       ble.s     doprint_50
       move.l    D5,D0
       bra.s     doprint_51
doprint_50:
       move.b    D4,D0
       ext.w     D0
       ext.l     D0
doprint_51:
       move.b    D0,D4
doprint_48:
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #88,D0
       bne       doprint_56
       lea       -36(A6),A0
       move.l    A0,D2
doprint_54:
       move.l    D2,A0
       tst.b     (A0)
       beq.s     doprint_56
       move.l    D2,A0
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       jsr       _toupper
       addq.w    #4,A7
       move.l    D2,A0
       move.b    D0,(A0)
       addq.l    #1,D2
       bra       doprint_54
doprint_56:
       moveq     #0,D7
       lea       -44(A6),A0
       move.l    A0,D2
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #100,D0
       beq.s     doprint_59
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #105,D0
       bne       doprint_65
doprint_59:
       move.b    -50(A6),D0
       ext.w     D0
       ext.l     D0
       tst.l     D0
       bne.s     doprint_62
       move.l    D3,A0
       move.b    (A0),D0
       cmp.b     #45,D0
       bne       doprint_60
doprint_62:
       move.l    D3,A0
       move.b    (A0),D0
       cmp.b     #45,D0
       bne.s     doprint_63
       move.l    D3,A0
       addq.l    #1,D3
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       subq.b    #1,D4
       bra.s     doprint_64
doprint_63:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #43,(A0)
doprint_64:
       addq.l    #1,D7
       bra       doprint_65
doprint_60:
       tst.b     -49(A6)
       beq.s     doprint_65
       move.l    D3,A0
       move.b    (A0),D0
       cmp.b     #45,D0
       bne.s     doprint_67
       move.l    D3,A0
       addq.l    #1,D3
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       subq.b    #1,D4
       bra.s     doprint_68
doprint_67:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #32,(A0)
doprint_68:
       addq.l    #1,D7
doprint_65:
       tst.b     -48(A6)
       beq       doprint_77
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #111,D0
       beq.s     doprint_73
       bgt.s     doprint_76
       cmp.l     #88,D0
       beq.s     doprint_73
       bra       doprint_77
doprint_76:
       cmp.l     #120,D0
       beq.s     doprint_73
       bra       doprint_77
doprint_73:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #48,(A0)
       addq.l    #1,D7
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #120,D0
       beq.s     doprint_79
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #88,D0
       bne.s     doprint_77
doprint_79:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #120,(A0)
       addq.l    #1,D7
doprint_77:
       move.l    D2,A0
       clr.b     (A0)
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #105,D0
       beq       doprint_82
       bgt.s     doprint_93
       cmp.l     #99,D0
       beq       doprint_96
       bgt.s     doprint_94
       cmp.l     #88,D0
       beq       doprint_82
       bgt       doprint_80
       cmp.l     #69,D0
       beq       doprint_82
       bra       doprint_80
doprint_94:
       cmp.l     #101,D0
       beq       doprint_82
       bgt       doprint_80
       cmp.l     #100,D0
       beq.s     doprint_82
       bra       doprint_80
doprint_93:
       cmp.l     #117,D0
       beq.s     doprint_82
       bgt.s     doprint_95
       cmp.l     #115,D0
       beq       doprint_96
       bgt       doprint_80
       cmp.l     #111,D0
       beq.s     doprint_82
       bra       doprint_80
doprint_95:
       cmp.l     #120,D0
       beq.s     doprint_82
       bra       doprint_80
doprint_82:
       tst.b     -46(A6)
       beq.s     doprint_96
       tst.b     -51(A6)
       bne.s     doprint_96
       move.l    A5,D0
       sub.l     D7,D0
       ext.w     D4
       ext.l     D4
       sub.l     D4,D0
       move.l    D0,-4(A6)
doprint_96:
       move.l    -4(A6),D0
       cmp.l     #0,D0
       bge.s     doprint_98
       clr.l     -4(A6)
doprint_98:
       tst.b     -51(A6)
       bne       doprint_104
       move.b    D4,D0
       ext.w     D0
       ext.l     D0
       add.l     -4(A6),D0
       add.l     D7,D0
       move.b    D0,-47(A6)
doprint_102:
       move.b    -47(A6),D0
       ext.w     D0
       ext.l     D0
       move.l    A5,D1
       subq.w    #1,A5
       cmp.l     D1,D0
       bge.s     doprint_104
       pea       32
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       doprint_102
doprint_104:
       lea       -44(A6),A0
       move.l    A0,D2
doprint_105:
       move.l    D2,A0
       tst.b     (A0)
       beq.s     doprint_107
       move.l    D2,A0
       addq.l    #1,D2
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       doprint_105
doprint_107:
       move.l    -4(A6),D0
       move.b    D0,-47(A6)
doprint_108:
       move.b    -47(A6),D0
       subq.b    #1,-47(A6)
       tst.b     D0
       beq.s     doprint_110
       pea       48
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       doprint_108
doprint_110:
       move.l    D3,A0
       tst.b     (A0)
       beq       doprint_113
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #115,D0
       beq.s     doprint_116
       bgt.s     doprint_119
       cmp.l     #99,D0
       beq.s     doprint_116
       bra.s     doprint_119
doprint_116:
       move.l    D5,D0
       subq.l    #1,D5
       cmp.l     #0,D0
       bgt.s     doprint_119
       bra.s     doprint_115
doprint_119:
       move.l    D3,A0
       addq.l    #1,D3
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra.s     doprint_112
doprint_115:
       bra.s     doprint_113
doprint_112:
       bra       doprint_110
doprint_113:
       tst.b     -51(A6)
       beq       doprint_125
       move.b    D4,D0
       ext.w     D0
       ext.l     D0
       add.l     -4(A6),D0
       add.l     D7,D0
       move.b    D0,-47(A6)
doprint_123:
       move.b    -47(A6),D0
       ext.w     D0
       ext.l     D0
       move.l    A5,D1
       subq.w    #1,A5
       cmp.l     D1,D0
       bge.s     doprint_125
       pea       32
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       subq.l    #1,D6
       bra       doprint_123
doprint_125:
       bra.s     doprint_81
doprint_80:
       move.l    12(A6),A0
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
doprint_81:
       addq.l    #1,12(A6)
doprint_2:
       bra       doprint_1
doprint_3:
       tst.l     (A2)
       beq.s     doprint_126
       clr.b     D1
       and.l     #255,D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
doprint_126:
       move.l    D6,D0
       movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
       unlk      A6
       rts
@itoa_convert:
       link      A6,#0
       movem.l   D2/D3/D4/D5,-(A7)
       move.l    8(A6),D2
       move.l    16(A6),D3
       move.l    12(A6),D5
       move.l    D5,-(A7)
       move.l    D3,-(A7)
       jsr       ULDIV
       move.l    4(A7),D0
       addq.w    #8,A7
       move.l    D0,D4
       cmp.l     D3,D5
       blo.s     @itoa_convert_1
       move.l    D3,-(A7)
       move.l    D5,-(A7)
       move.l    D3,-(A7)
       jsr       ULDIV
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    D1,-(A7)
       move.l    D2,-(A7)
       jsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D2
@itoa_convert_1:
       cmp.l     #9,D4
       bgt.s     @itoa_convert_3
       move.l    D4,D0
       moveq     #48,D1
       and.l     #255,D1
       add.l     D1,D0
       bra.s     @itoa_convert_4
@itoa_convert_3:
       move.l    D4,D0
       moveq     #97,D1
       and.l     #255,D1
       add.l     D1,D0
       sub.l     #10,D0
@itoa_convert_4:
       move.l    D2,A0
       move.b    D0,(A0)
       move.l    D2,D0
       addq.l    #1,D0
       movem.l   (A7)+,D2/D3/D4/D5
       unlk      A6
       rts
_ltoa:
       link      A6,#0
       movem.l   D2/D3/D4/D5,-(A7)
       move.l    8(A6),D2
       move.l    12(A6),D3
       move.l    16(A6),D5
       move.l    D3,D4
       cmp.l     #2,D5
       blt.s     ltoa_3
       cmp.l     #36,D5
       ble.s     ltoa_1
ltoa_3:
       move.l    D3,D0
       bra       ltoa_4
ltoa_1:
       cmp.l     #10,D5
       bne       ltoa_5
       cmp.l     #0,D2
       bge.s     ltoa_5
       move.l    D2,D0
       neg.l     D0
       move.l    D0,D2
       cmp.l     #0,D2
       bge.s     ltoa_7
       pea       @itoa_1.L
       move.l    D3,-(A7)
       jsr       _strcpy
       addq.w    #8,A7
       move.l    D3,D0
       bra.s     ltoa_4
ltoa_7:
       move.l    D4,A0
       addq.l    #1,D4
       move.b    #45,(A0)
ltoa_5:
       move.l    D5,-(A7)
       move.l    D2,-(A7)
       move.l    D4,-(A7)
       jsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D4
       move.l    D4,A0
       clr.b     (A0)
       move.l    D3,D0
ltoa_4:
       movem.l   (A7)+,D2/D3/D4/D5
       unlk      A6
       rts
_ultoa:
       link      A6,#0
       movem.l   D2/D3/D4,-(A7)
       move.l    16(A6),D3
       move.l    12(A6),D4
       move.l    D4,D2
       cmp.l     #2,D3
       blt.s     ultoa_3
       cmp.l     #36,D3
       ble.s     ultoa_1
ultoa_3:
       move.l    D4,D0
       bra.s     ultoa_4
ultoa_1:
       move.l    D3,-(A7)
       move.l    8(A6),-(A7)
       move.l    D2,-(A7)
       jsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D2
       move.l    D2,A0
       clr.b     (A0)
       move.l    D4,D0
ultoa_4:
       movem.l   (A7)+,D2/D3/D4
       unlk      A6
       rts
_itoa:
       link      A6,#0
       move.l    16(A6),-(A7)
       move.l    12(A6),-(A7)
       move.l    8(A6),-(A7)
       jsr       _ltoa
       add.w     #12,A7
       unlk      A6
       rts
_strlen:
       move.l    (4,A7),A0
       move.l    A0,A1
strlen_1:
       tst.b     (A1)+
       bne       strlen_1
       move.l    A1,D0
       sub.l     A0,D0
       subq.l    #1,D0
       rts
_putch:
       link      A6,#0
       move.l    D2,-(A7)
       move.l    8(A6),D2
       cmp.l     #10,D2
       bne.s     putch_1
       pea       13
       jsr       __putch
       addq.w    #4,A7
putch_1:
       move.l    D2,-(A7)
       jsr       __putch
       addq.w    #4,A7
       move.l    D2,D0
       move.l    (A7)+,D2
       unlk      A6
       rts
_toupper:
       move.l    4(A7),D0
       cmp.l     #'a',D0
       blt.s     toupper_1
       cmp.l     #'z',D0
       bgt.s     toupper_1
       sub.l     #$20,D0
toupper_1:
       rts
_strcpy:
       move.l    (4,A7),A0
       move.l    (8,A7),A1
       move.l    A0,D0
strcpy_1:
       move.b    (A1)+,(A0)+
       bne.s     strcpy_1
       rts
       section   const
                align


@iic_dr~1_1:
       dc.b      13,10,69,110,116,101,114,101,100,32,70,105,114
       dc.b      115,116,32,66,108,111,99,107,32,76,111,111,112
       dc.b      0
@iic_dr~1_2:
       dc.b      13,10,32,69,110,116,101,114,101,100,32,73,110
       dc.b      116,101,114,109,101,100,105,97,116,101,32,76
       dc.b      111,111,112,0
@iic_dr~1_3:
       dc.b      13,10,32,67,117,114,114,101,110,116,32,65,100
       dc.b      100,114,101,115,115,32,73,110,100,101,120,58
       dc.b      32,37,120,0
@iic_dr~1_4:
       dc.b      13,10,32,69,110,116,101,114,101,100,32,76,97
       dc.b      115,116,32,66,108,111,99,107,32,76,111,111,112
       dc.b      0
@iic_dr~1_5:
       dc.b      13,10,32,69,120,105,116,101,100,32,65,108,108
       dc.b      32,76,111,111,112,115,0
@m68kus~1_1:
       dc.b      13,10,73,110,105,116,105,97,108,105,122,105
       dc.b      110,103,32,73,73,67,32,67,111,110,116,114,111
       dc.b      108,108,101,114,0
@m68kus~1_2:
       dc.b      13,10,68,111,110,101,32,105,110,105,116,105
       dc.b      97,108,105,122,97,116,105,111,110,44,32,115
       dc.b      101,110,100,105,110,103,32,97,32,98,121,116
       dc.b      101,46,46,46,0
@adc_dac_1:
       dc.b      13,10,32,71,101,110,101,114,97,116,101,100,32
       dc.b      83,116,97,114,116,32,83,105,103,110,97,108,0
@adc_dac_2:
       dc.b      13,10,32,83,101,110,116,32,67,111,110,116,114
       dc.b      111,108,32,66,121,116,101,0
@itoa_1:
       dc.b      45,50,49,52,55,52,56,51,54,52,56,0
__ctype:
       dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
       dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
       dc.b      64,64,64,208,160,160,160,160,160,160,160,160
       dc.b      160,160,160,160,160,160,160,140,140,140,140
       dc.b      140,140,140,140,140,140,160,160,160,160,160
       dc.b      160,160,138,138,138,138,138,138,130,130,130
       dc.b      130,130,130,130,130,130,130,130,130,130,130
       dc.b      130,130,130,130,130,130,160,160,160,160,160
       dc.b      160,137,137,137,137,137,137,129,129,129,129
       dc.b      129,129,129,129,129,129,129,129,129,129,129
       dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       section   data
                align

*********************************************************************************************************************************************************
* Section for Initialised Data (in theory should be copied to Ram at startup) but is part of program code as we copy whole program to ram at startup
********************************************************************************************************************************************************

DataStart       equ       *
__ungetbuf:     ds.l      1                    ungetbuffer for stdio functions
__allocp:       ds.l      1                    start of free memory block list
__heap:         ds.l      1                    begin of free memory


_IICClkPrescalerLow:
       dc.l      4227072
_IICClkPrescalerHigh:
       dc.l      4227074
_IICControl:
       dc.l      4227076
_IICTx:
       dc.l      4227078
_IICRx:
       dc.l      4227078
_IICStatus:
       dc.l      4227080
_IICCommand:
       dc.l      4227080
_IICTx_:
       dc.l      4227078
_IICRx_:
       dc.l      4227078
_IICCommand_:
       dc.l      4227080
       section   bss
                align

DataEnd         equ       *                    this label will equate to the address of the last byte of global variable in it
DataLength      equ       DataEnd-DataStart    length of data needed to copy to Ram on bootup

*********************************************************************************************************
* Section for uninitialised Data which is set to zero, i.e. we should set this space to zero at starup
*********************************************************************************************************
BssStart       equ       *

_x:
       ds.b      4
_y:
       ds.b      4
_z:
       ds.b      4
_PortA_Count:
       ds.b      4
_Timer1Count:
       ds.b      1
_Timer2Count:
       ds.b      1
_Timer3Count:
       ds.b      1
_Timer4Count:
       ds.b      1
_counter:
       ds.b      4
_rollovers:
       ds.b      4
_a:
       ds.b      40000
_b:
       ds.b      40000
_c:
       ds.b      40000
_i:
       ds.b      4
_j:
       ds.b      4
_k:
       ds.b      4
_sum:
       ds.b      4
       section   heap
               align

BssEnd         equ       *
BssLength      equ       BssEnd-BssStart       length of zeroed data needed to copy to Ram on bootup

*********************************************************************************************************
* Section for Heap
*********************************************************************************************************

heap           equ       *
               align

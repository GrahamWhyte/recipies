680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 31 Mar 2019      Time: 17:35:36          Source: C:\M68KV6.0 - 640BY480\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS\PROGRAMS\LAB5\LAB5.SRC

                       1          section   code
                       2   **********************************************************************************************************
                       3   * CSTART.ASM  -  C startup-code
                       4   *
                       5   *          Initialises the system prior to running the users main() program
                       6   *
                       7   *          1) Sets up the user program stack pointer
                       8   *          2) Switches to User mode in the 68000
                       9   *          3) Enables All Interrupts 1-7 on 68000
                      10   *          4) Copies all initialised C program variables from Rom to Ram prior to running main()
                      11   *
                      12   **********************************************************************************************************
00000000              13                   align
                      14   
                      15   
                      16   **********************************************************************************************************
                      17   * The Following ORG Statement marks the address of the start of the this CStart Program
                      18   *
                      19   * The debug Monitor and Flash Load and Program routines assume your program lives here
                      20   **********************************************************************************************************
08000000              21                   org       $08000000
08000000  46FC 2000   22   start:          move.w    #$2000,SR             clear interrupts to enable all, move to supervisor mode
                      23   
                      24   ******************************************************************************************
                      25   * Set unitialised global variables to 0 at startup
                      26   ******************************************************************************************
08000004  207C 0800   27   mainloop        movea.l   #BssStart,a0          point a0 to the start of the initialised data section held in ROM
08000008  1A52      
0800000A  203C 0001   28                   move.l    #BssLength,d0         figure out how many bytes of C program variables data to copy
0800000E  D4F0      
08000010  6700 0024   29                   beq       go_main               if no data to copy go straight to program
08000014  10FC 0000   30   Zeroinit        move.b    #0,(a0)+              copy the C program initialise variables from rom to ram
08000018  5380        31                   subq.l    #1,d0
0800001A  66F8        32                   bne       Zeroinit
                      33   
                      34   *******************************************************************************************
                      35   * last minute initialisation before calling main
                      36   *******************************************************************************************
                      37   
0800001C  23FC FFFF   38                   move.l    #-1,__ungetbuf         required for use of scanf() etc in C programs
08000020  FFFF 0800 
08000024  1A1E      
08000026  42B9 0800   39                   clr.l     __allocp               used by malloc() in C
0800002A  1A22      
0800002C  23FC 0801   40                   move.l    #heap,__heap           pointer to free memory
08000030  EF42 0800 
08000034  1A26      
08000036  4EB9 0800   41   go_main         jsr       _main
0800003A  0CC2      
0800003C  60C2        42                   bra       start
                      43   
                      44   ; C:\M68KV6.0 - 640BY480\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS\PROGRAMS\LAB5\IIC_DRIVER.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                      45   ; #include <stdlib.h>
                      46   ; #include "IIC_Driver.h"
                      47   ; /* Globals */
                      48   ; volatile unsigned char *IICClkPrescalerLow = (unsigned char *)IIC_CLK_PRSCL_LO;
                      49   ; volatile unsigned char *IICClkPrescalerHigh = (unsigned char *)IIC_CLK_PRSCL_HI;
                      50   ; volatile unsigned char *IICControl = (unsigned char *)IIC_CONTROL;
                      51   ; volatile unsigned char *IICTx = (unsigned char *)IIC_TRANSMIT;
                      52   ; volatile unsigned char *IICRx = (unsigned char *)IIC_RECEIVE;
                      53   ; volatile unsigned char *IICStatus = (unsigned char *)IIC_STATUS;
                      54   ; volatile unsigned char *IICCommand = (unsigned char *)IIC_COMMAND;
                      55   ; // *IICClkPrescalerLow = (unsigned char *)IIC_CLK_PRSCL_LO;
                      56   ; // *IICClkPrescalerHigh = (unsigned char *)IIC_CLK_PRSCL_HI;
                      57   ; // *IICControl = (unsigned char *)IIC_CONTROL;
                      58   ; // *IICTx = (unsigned char *)IIC_TRANSMIT;
                      59   ; // *IICRx = (unsigned char *)IIC_RECEIVE;
                      60   ; // *IICStatus = (unsigned char *)IIC_STATUS;
                      61   ; // *IICCommand = (unsigned char *)IIC_COMMAND;
                      62   ; /* Functions */
                      63   ; void WaitForEndOfTransfer(void) {
                      64   _WaitForEndOfTransfer:
                      65   ; while (1){							
                      66   WaitForEndOfTransfer_1:
                      67   ; if ( ( (*IICStatus) & TIP) == 0)	
0800003E  2079 0800   68          move.l    _IICStatus.L,A0
08000042  1A3E      
08000044  1010        69          move.b    (A0),D0
08000046  C03C 0002   70          and.b     #2,D0
0800004A  6602        71          bne.s     WaitForEndOfTransfer_4
                      72   ; break;							
0800004C  6002        73          bra.s     WaitForEndOfTransfer_3
                      74   WaitForEndOfTransfer_4:
0800004E  60EE        75          bra       WaitForEndOfTransfer_1
                      76   WaitForEndOfTransfer_3:
08000050  4E75        77          rts
                      78   ; }			
                      79   ; }
                      80   ; void WaitForAck(void) {
                      81   _WaitForAck:
                      82   ; while (1){								
                      83   WaitForAck_1:
                      84   ; if ( ( (*IICStatus) & RxACK) == 0 )	
08000052  2079 0800   85          move.l    _IICStatus.L,A0
08000056  1A3E      
08000058  1010        86          move.b    (A0),D0
0800005A  C07C 00FF   87          and.w     #255,D0
0800005E  C07C 0080   88          and.w     #128,D0
08000062  6602        89          bne.s     WaitForAck_4
                      90   ; break;							
08000064  6002        91          bra.s     WaitForAck_3
                      92   WaitForAck_4:
08000066  60EA        93          bra       WaitForAck_1
                      94   WaitForAck_3:
08000068  4E75        95          rts
                      96   ; }				
                      97   ; }	
                      98   ; unsigned char EEPROMInternalWritting(void) {
                      99   _EEPROMInternalWritting:
                     100   ; return ( ( (*IICStatus) & RxACK) == 0 );
0800006A  2079 0800  101          move.l    _IICStatus.L,A0
0800006E  1A3E      
08000070  1010       102          move.b    (A0),D0
08000072  C07C 00FF  103          and.w     #255,D0
08000076  C07C 0080  104          and.w     #128,D0
0800007A  6604       105          bne.s     EEPROMInternalWritting_1
0800007C  7001       106          moveq     #1,D0
0800007E  6002       107          bra.s     EEPROMInternalWritting_2
                     108   EEPROMInternalWritting_1:
08000080  4280       109          clr.l     D0
                     110   EEPROMInternalWritting_2:
08000082  4E75       111          rts
                     112   ; }
                     113   ; void Init_IIC(void) {
                     114   _Init_IIC:
                     115   ; *IICControl = 0;
08000084  2079 0800  116          move.l    _IICControl.L,A0
08000088  1A32      
0800008A  4210       117          clr.b     (A0)
                     118   ; *IICClkPrescalerLow = CLK_100K_LO;
0800008C  2079 0800  119          move.l    _IICClkPrescalerLow.L,A0
08000090  1A2A      
08000092  10BC 0031  120          move.b    #49,(A0)
                     121   ; *IICClkPrescalerHigh = CLK_100K_HI;
08000096  2079 0800  122          move.l    _IICClkPrescalerHigh.L,A0
0800009A  1A2E      
0800009C  4210       123          clr.b     (A0)
                     124   ; *IICControl = CORE_ENABLED | INTERRUPT_DISABLED;
0800009E  2079 0800  125          move.l    _IICControl.L,A0
080000A2  1A32      
080000A4  10BC 0080  126          move.b    #128,(A0)
080000A8  4E75       127          rts
                     128   ; } 
                     129   ; void WriteByte(unsigned char IICSlaveAddress, unsigned char byteToStore, unsigned int EEPROMAddress) {
                     130   _WriteByte:
080000AA  4E56 FFFC  131          link      A6,#-4
080000AE  48E7 203C  132          movem.l   D2/A2/A3/A4/A5,-(A7)
080000B2  45F9 0800  133          lea       _WaitForAck.L,A2
080000B6  0052      
080000B8  47F9 0800  134          lea       _WaitForEndOfTransfer.L,A3
080000BC  003E      
080000BE  49F9 0800  135          lea       _IICCommand.L,A4
080000C2  1A42      
080000C4  4BF9 0800  136          lea       _IICTx.L,A5
080000C8  1A36      
080000CA  242E 0010  137          move.l    16(A6),D2
                     138   ; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
080000CE  2002       139          move.l    D2,D0
080000D0  E008       140          lsr.b     #8,D0
080000D2  E008       141          lsr.b     #8,D0
080000D4  1D40 FFFD  142          move.b    D0,-3(A6)
                     143   ; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
080000D8  2002       144          move.l    D2,D0
080000DA  E088       145          lsr.l     #8,D0
080000DC  1D40 FFFE  146          move.b    D0,-2(A6)
                     147   ; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
080000E0  1D42 FFFF  148          move.b    D2,-1(A6)
                     149   ; IICSlaveAddress |= (blockSelect << 3);  
080000E4  102E FFFD  150          move.b    -3(A6),D0
080000E8  E708       151          lsl.b     #3,D0
080000EA  812E 000B  152          or.b      D0,11(A6)
                     153   ; // Transfer IIC Slave Address
                     154   ; WaitForInternalWrite(IICSlaveAddress);
080000EE  122E 000B  155          move.b    11(A6),D1
080000F2  C2BC 0000  156          and.l     #255,D1
080000F6  00FF      
080000F8  2F01       157          move.l    D1,-(A7)
080000FA  4EB9 0800  158          jsr       _WaitForInternalWrite
080000FE  01E2      
08000100  584F       159          addq.w    #4,A7
                     160   ; // Transfer High EEProm Address
                     161   ; *IICTx = EEPROMAddress_High;	// fill the tx shift register
08000102  2055       162          move.l    (A5),A0
08000104  10AE FFFE  163          move.b    -2(A6),(A0)
                     164   ; *IICCommand = WR;	// set write bit
08000108  2054       165          move.l    (A4),A0
0800010A  10BC 0010  166          move.b    #16,(A0)
                     167   ; WaitForEndOfTransfer();
0800010E  4E93       168          jsr       (A3)
                     169   ; WaitForAck();
08000110  4E92       170          jsr       (A2)
                     171   ; // Transfer Low EEProm Address
                     172   ; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
08000112  2055       173          move.l    (A5),A0
08000114  10AE FFFF  174          move.b    -1(A6),(A0)
                     175   ; *IICCommand = WR;	// set write bit
08000118  2054       176          move.l    (A4),A0
0800011A  10BC 0010  177          move.b    #16,(A0)
                     178   ; WaitForEndOfTransfer();
0800011E  4E93       179          jsr       (A3)
                     180   ; WaitForAck();
08000120  4E92       181          jsr       (A2)
                     182   ; // Send Data
                     183   ; *IICTx = byteToStore;
08000122  2055       184          move.l    (A5),A0
08000124  10AE 000F  185          move.b    15(A6),(A0)
                     186   ; *IICCommand = WR | STO;	//send stop signal
08000128  2054       187          move.l    (A4),A0
0800012A  10BC 0050  188          move.b    #80,(A0)
                     189   ; WaitForEndOfTransfer();
0800012E  4E93       190          jsr       (A3)
                     191   ; WaitForAck();
08000130  4E92       192          jsr       (A2)
08000132  4CDF 3C04  193          movem.l   (A7)+,D2/A2/A3/A4/A5
08000136  4E5E       194          unlk      A6
08000138  4E75       195          rts
                     196   ; }
                     197   ; unsigned char ReadByte(unsigned char IICSlaveAddress, unsigned int EEPROMAddress) {
                     198   _ReadByte:
0800013A  4E56 FFFC  199          link      A6,#-4
0800013E  48E7 303C  200          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
08000142  45F9 0800  201          lea       _WaitForEndOfTransfer.L,A2
08000146  003E      
08000148  47F9 0800  202          lea       _IICCommand.L,A3
0800014C  1A42      
0800014E  49F9 0800  203          lea       _WaitForAck.L,A4
08000152  0052      
08000154  4BF9 0800  204          lea       _IICTx.L,A5
08000158  1A36      
0800015A  142E 000B  205          move.b    11(A6),D2
0800015E  C4BC 0000  206          and.l     #255,D2
08000162  00FF      
08000164  262E 000C  207          move.l    12(A6),D3
                     208   ; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
08000168  2003       209          move.l    D3,D0
0800016A  E008       210          lsr.b     #8,D0
0800016C  E008       211          lsr.b     #8,D0
0800016E  1D40 FFFD  212          move.b    D0,-3(A6)
                     213   ; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
08000172  2003       214          move.l    D3,D0
08000174  E088       215          lsr.l     #8,D0
08000176  1D40 FFFE  216          move.b    D0,-2(A6)
                     217   ; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
0800017A  1D43 FFFF  218          move.b    D3,-1(A6)
                     219   ; IICSlaveAddress |= (blockSelect << 3);  
0800017E  102E FFFD  220          move.b    -3(A6),D0
08000182  E708       221          lsl.b     #3,D0
08000184  8400       222          or.b      D0,D2
                     223   ; // Transfer IIC Slave Address
                     224   ; WaitForInternalWrite(IICSlaveAddress);
08000186  C4BC 0000  225          and.l     #255,D2
0800018A  00FF      
0800018C  2F02       226          move.l    D2,-(A7)
0800018E  4EB9 0800  227          jsr       _WaitForInternalWrite
08000192  01E2      
08000194  584F       228          addq.w    #4,A7
                     229   ; // Transfer High EEProm Address
                     230   ; *IICTx = EEPROMAddress_High;	// fill the tx shift register
08000196  2055       231          move.l    (A5),A0
08000198  10AE FFFE  232          move.b    -2(A6),(A0)
                     233   ; *IICCommand = WR;	// set write bit
0800019C  2053       234          move.l    (A3),A0
0800019E  10BC 0010  235          move.b    #16,(A0)
                     236   ; WaitForEndOfTransfer();
080001A2  4E92       237          jsr       (A2)
                     238   ; WaitForAck();
080001A4  4E94       239          jsr       (A4)
                     240   ; // Transfer Low EEProm Address
                     241   ; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
080001A6  2055       242          move.l    (A5),A0
080001A8  10AE FFFF  243          move.b    -1(A6),(A0)
                     244   ; *IICCommand = WR;	// set write bit
080001AC  2053       245          move.l    (A3),A0
080001AE  10BC 0010  246          move.b    #16,(A0)
                     247   ; WaitForEndOfTransfer();
080001B2  4E92       248          jsr       (A2)
                     249   ; WaitForAck();
080001B4  4E94       250          jsr       (A4)
                     251   ; // Fetch Data
                     252   ; *IICTx = IICSlaveAddress | READ;
080001B6  1002       253          move.b    D2,D0
080001B8  803C 0001  254          or.b      #1,D0
080001BC  2055       255          move.l    (A5),A0
080001BE  1080       256          move.b    D0,(A0)
                     257   ; *IICCommand = WR | STA;	//send stop signal
080001C0  2053       258          move.l    (A3),A0
080001C2  10BC 0090  259          move.b    #144,(A0)
                     260   ; WaitForEndOfTransfer();
080001C6  4E92       261          jsr       (A2)
                     262   ; WaitForAck();
080001C8  4E94       263          jsr       (A4)
                     264   ; // read SDA line
                     265   ; *IICCommand = RD | STO | NACK;	//send stop signal
080001CA  2053       266          move.l    (A3),A0
080001CC  10BC 0068  267          move.b    #104,(A0)
                     268   ; WaitForEndOfTransfer();
080001D0  4E92       269          jsr       (A2)
                     270   ; return *IICRx;
080001D2  2079 0800  271          move.l    _IICRx.L,A0
080001D6  1A3A      
080001D8  1010       272          move.b    (A0),D0
080001DA  4CDF 3C0C  273          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
080001DE  4E5E       274          unlk      A6
080001E0  4E75       275          rts
                     276   ; }
                     277   ; void WaitForInternalWrite(unsigned char IICSlaveAddress) {
                     278   _WaitForInternalWrite:
080001E2  4E56 0000  279          link      A6,#0
                     280   ; do {
                     281   WaitForInternalWrite_1:
                     282   ; *IICTx = IICSlaveAddress | WRITE;	// fill the tx shift register
080001E6  102E 000B  283          move.b    11(A6),D0
080001EA  803C 0000  284          or.b      #0,D0
080001EE  2079 0800  285          move.l    _IICTx.L,A0
080001F2  1A36      
080001F4  1080       286          move.b    D0,(A0)
                     287   ; *IICCommand = STA | WR;	// set write bit
080001F6  2079 0800  288          move.l    _IICCommand.L,A0
080001FA  1A42      
080001FC  10BC 0090  289          move.b    #144,(A0)
                     290   ; WaitForEndOfTransfer();
08000200  4EB9 0800  291          jsr       _WaitForEndOfTransfer
08000204  003E      
08000206  4EB9 0800  292          jsr       _EEPROMInternalWritting
0800020A  006A      
0800020C  4A00       293          tst.b     D0
0800020E  67D6       294          beq       WaitForInternalWrite_1
08000210  4E5E       295          unlk      A6
08000212  4E75       296          rts
                     297   ; } while (!EEPROMInternalWritting());
                     298   ; }
                     299   ; void Write_128_Bytes(unsigned char IICSlaveAddress, unsigned int EEPROMAddress, unsigned char *iicArray) {
                     300   _Write_128_Bytes:
08000214  4E56 FFFC  301          link      A6,#-4
08000218  48E7 303C  302          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
0800021C  45F9 0800  303          lea       _WaitForAck.L,A2
08000220  0052      
08000222  47F9 0800  304          lea       _WaitForEndOfTransfer.L,A3
08000226  003E      
08000228  49F9 0800  305          lea       _IICCommand.L,A4
0800022C  1A42      
0800022E  4BF9 0800  306          lea       _IICTx.L,A5
08000232  1A36      
08000234  262E 000C  307          move.l    12(A6),D3
                     308   ; int i; 
                     309   ; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
08000238  2003       310          move.l    D3,D0
0800023A  E008       311          lsr.b     #8,D0
0800023C  E008       312          lsr.b     #8,D0
0800023E  1D40 FFFD  313          move.b    D0,-3(A6)
                     314   ; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
08000242  2003       315          move.l    D3,D0
08000244  E088       316          lsr.l     #8,D0
08000246  1D40 FFFE  317          move.b    D0,-2(A6)
                     318   ; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
0800024A  1D43 FFFF  319          move.b    D3,-1(A6)
                     320   ; IICSlaveAddress |= (blockSelect << 3);  
0800024E  102E FFFD  321          move.b    -3(A6),D0
08000252  E708       322          lsl.b     #3,D0
08000254  812E 000B  323          or.b      D0,11(A6)
                     324   ; // Transfer IIC Slave Address
                     325   ; WaitForInternalWrite(IICSlaveAddress);
08000258  122E 000B  326          move.b    11(A6),D1
0800025C  C2BC 0000  327          and.l     #255,D1
08000260  00FF      
08000262  2F01       328          move.l    D1,-(A7)
08000264  4EB9 0800  329          jsr       _WaitForInternalWrite
08000268  01E2      
0800026A  584F       330          addq.w    #4,A7
                     331   ; // Transfer High EEProm Address
                     332   ; *IICTx = EEPROMAddress_High;	// fill the tx shift register
0800026C  2055       333          move.l    (A5),A0
0800026E  10AE FFFE  334          move.b    -2(A6),(A0)
                     335   ; *IICCommand = WR;	// set write bit
08000272  2054       336          move.l    (A4),A0
08000274  10BC 0010  337          move.b    #16,(A0)
                     338   ; WaitForEndOfTransfer();
08000278  4E93       339          jsr       (A3)
                     340   ; WaitForAck();
0800027A  4E92       341          jsr       (A2)
                     342   ; // Transfer Low EEProm Address
                     343   ; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
0800027C  2055       344          move.l    (A5),A0
0800027E  10AE FFFF  345          move.b    -1(A6),(A0)
                     346   ; *IICCommand = WR;	// set write bit
08000282  2054       347          move.l    (A4),A0
08000284  10BC 0010  348          move.b    #16,(A0)
                     349   ; WaitForEndOfTransfer();
08000288  4E93       350          jsr       (A3)
                     351   ; WaitForAck();
0800028A  4E92       352          jsr       (A2)
                     353   ; for (i=0; i<127; i++)
0800028C  4282       354          clr.l     D2
                     355   Write_128_Bytes_1:
0800028E  0C82 0000  356          cmp.l     #127,D2
08000292  007F      
08000294  6C18       357          bge.s     Write_128_Bytes_3
                     358   ; {
                     359   ; *IICTx = iicArray[i];
08000296  206E 0010  360          move.l    16(A6),A0
0800029A  2255       361          move.l    (A5),A1
0800029C  12B0 2800  362          move.b    0(A0,D2.L),(A1)
                     363   ; *IICCommand = WR;	// set write bit
080002A0  2054       364          move.l    (A4),A0
080002A2  10BC 0010  365          move.b    #16,(A0)
                     366   ; WaitForEndOfTransfer();
080002A6  4E93       367          jsr       (A3)
                     368   ; WaitForAck();
080002A8  4E92       369          jsr       (A2)
080002AA  5282       370          addq.l    #1,D2
080002AC  60E0       371          bra       Write_128_Bytes_1
                     372   Write_128_Bytes_3:
                     373   ; }
                     374   ; // Send Data
                     375   ; *IICTx = iicArray[127];
080002AE  206E 0010  376          move.l    16(A6),A0
080002B2  2255       377          move.l    (A5),A1
080002B4  12A8 007F  378          move.b    127(A0),(A1)
                     379   ; *IICCommand = WR | STO;	//send stop signal
080002B8  2054       380          move.l    (A4),A0
080002BA  10BC 0050  381          move.b    #80,(A0)
                     382   ; WaitForEndOfTransfer();
080002BE  4E93       383          jsr       (A3)
                     384   ; WaitForAck();
080002C0  4E92       385          jsr       (A2)
080002C2  4CDF 3C0C  386          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
080002C6  4E5E       387          unlk      A6
080002C8  4E75       388          rts
                     389   ; }
                     390   ; void Read_128_Bytes(unsigned char IICSlaveAddress, unsigned int EEPROMAddress, unsigned char *buffer){
                     391   _Read_128_Bytes:
080002CA  4E56 FFFC  392          link      A6,#-4
080002CE  48E7 383C  393          movem.l   D2/D3/D4/A2/A3/A4/A5,-(A7)
080002D2  45F9 0800  394          lea       _WaitForEndOfTransfer.L,A2
080002D6  003E      
080002D8  47F9 0800  395          lea       _IICCommand.L,A3
080002DC  1A42      
080002DE  49F9 0800  396          lea       _WaitForAck.L,A4
080002E2  0052      
080002E4  4BF9 0800  397          lea       _IICTx.L,A5
080002E8  1A36      
080002EA  162E 000B  398          move.b    11(A6),D3
080002EE  C6BC 0000  399          and.l     #255,D3
080002F2  00FF      
080002F4  282E 000C  400          move.l    12(A6),D4
                     401   ; int i; 
                     402   ; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
080002F8  2004       403          move.l    D4,D0
080002FA  E008       404          lsr.b     #8,D0
080002FC  E008       405          lsr.b     #8,D0
080002FE  1D40 FFFD  406          move.b    D0,-3(A6)
                     407   ; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
08000302  2004       408          move.l    D4,D0
08000304  E088       409          lsr.l     #8,D0
08000306  1D40 FFFE  410          move.b    D0,-2(A6)
                     411   ; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
0800030A  1D44 FFFF  412          move.b    D4,-1(A6)
                     413   ; IICSlaveAddress |= (blockSelect << 3);  
0800030E  102E FFFD  414          move.b    -3(A6),D0
08000312  E708       415          lsl.b     #3,D0
08000314  8600       416          or.b      D0,D3
                     417   ; // Transfer IIC Slave Address
                     418   ; WaitForInternalWrite(IICSlaveAddress);
08000316  C6BC 0000  419          and.l     #255,D3
0800031A  00FF      
0800031C  2F03       420          move.l    D3,-(A7)
0800031E  4EB9 0800  421          jsr       _WaitForInternalWrite
08000322  01E2      
08000324  584F       422          addq.w    #4,A7
                     423   ; // Transfer High EEProm Address
                     424   ; *IICTx = EEPROMAddress_High;	// fill the tx shift register
08000326  2055       425          move.l    (A5),A0
08000328  10AE FFFE  426          move.b    -2(A6),(A0)
                     427   ; *IICCommand = WR;	// set write bit
0800032C  2053       428          move.l    (A3),A0
0800032E  10BC 0010  429          move.b    #16,(A0)
                     430   ; WaitForEndOfTransfer();
08000332  4E92       431          jsr       (A2)
                     432   ; WaitForAck();
08000334  4E94       433          jsr       (A4)
                     434   ; // Transfer Low EEProm Address
                     435   ; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
08000336  2055       436          move.l    (A5),A0
08000338  10AE FFFF  437          move.b    -1(A6),(A0)
                     438   ; *IICCommand = WR;	// set write bit
0800033C  2053       439          move.l    (A3),A0
0800033E  10BC 0010  440          move.b    #16,(A0)
                     441   ; WaitForEndOfTransfer();
08000342  4E92       442          jsr       (A2)
                     443   ; WaitForAck();
08000344  4E94       444          jsr       (A4)
                     445   ; // Fetch Data
                     446   ; *IICTx = IICSlaveAddress | READ;
08000346  1003       447          move.b    D3,D0
08000348  803C 0001  448          or.b      #1,D0
0800034C  2055       449          move.l    (A5),A0
0800034E  1080       450          move.b    D0,(A0)
                     451   ; *IICCommand = WR | STA;	//send start signal
08000350  2053       452          move.l    (A3),A0
08000352  10BC 0090  453          move.b    #144,(A0)
                     454   ; WaitForEndOfTransfer();
08000356  4E92       455          jsr       (A2)
                     456   ; WaitForAck();
08000358  4E94       457          jsr       (A4)
                     458   ; for (i=0; i<127; i++)
0800035A  4282       459          clr.l     D2
                     460   Read_128_Bytes_1:
0800035C  0C82 0000  461          cmp.l     #127,D2
08000360  007F      
08000362  6C1A       462          bge.s     Read_128_Bytes_3
                     463   ; {
                     464   ; *IICCommand = RD;
08000364  2053       465          move.l    (A3),A0
08000366  10BC 0020  466          move.b    #32,(A0)
                     467   ; WaitForEndOfTransfer();
0800036A  4E92       468          jsr       (A2)
                     469   ; buffer[i] = *IICRx; 
0800036C  2079 0800  470          move.l    _IICRx.L,A0
08000370  1A3A      
08000372  226E 0010  471          move.l    16(A6),A1
08000376  1390 2800  472          move.b    (A0),0(A1,D2.L)
0800037A  5282       473          addq.l    #1,D2
0800037C  60DE       474          bra       Read_128_Bytes_1
                     475   Read_128_Bytes_3:
                     476   ; }
                     477   ; // read SDA line
                     478   ; *IICCommand = RD | STO | NACK;	//send stop signal
0800037E  2053       479          move.l    (A3),A0
08000380  10BC 0068  480          move.b    #104,(A0)
                     481   ; WaitForEndOfTransfer();
08000384  4E92       482          jsr       (A2)
                     483   ; buffer[127] = *IICRx; 
08000386  2079 0800  484          move.l    _IICRx.L,A0
0800038A  1A3A      
0800038C  226E 0010  485          move.l    16(A6),A1
08000390  1350 007F  486          move.b    (A0),127(A1)
08000394  4CDF 3C1C  487          movem.l   (A7)+,D2/D3/D4/A2/A3/A4/A5
08000398  4E5E       488          unlk      A6
0800039A  4E75       489          rts
                     490   ; }
                     491   ; void WriteBytes(unsigned char IICSlaveAddress, unsigned int EEPROMAddress, unsigned char *iicArray, unsigned int length){
                     492   _WriteBytes:
0800039C  4E56 FFF4  493          link      A6,#-12
080003A0  48E7 3F3C  494          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
080003A4  282E 000C  495          move.l    12(A6),D4
080003A8  45F9 0800  496          lea       _IICCommand.L,A2
080003AC  1A42      
080003AE  47F9 0800  497          lea       _WaitForAck.L,A3
080003B2  0052      
080003B4  49F9 0800  498          lea       _WaitForEndOfTransfer.L,A4
080003B8  003E      
080003BA  4BF9 0800  499          lea       _IICTx.L,A5
080003BE  1A36      
080003C0  2C2E 0010  500          move.l    16(A6),D6
080003C4  1E2E 000B  501          move.b    11(A6),D7
080003C8  CEBC 0000  502          and.l     #255,D7
080003CC  00FF      
                     503   ; int i; 
                     504   ; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
080003CE  2004       505          move.l    D4,D0
080003D0  E008       506          lsr.b     #8,D0
080003D2  E008       507          lsr.b     #8,D0
080003D4  1D40 FFF5  508          move.b    D0,-11(A6)
                     509   ; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
080003D8  2004       510          move.l    D4,D0
080003DA  E088       511          lsr.l     #8,D0
080003DC  1D40 FFF6  512          move.b    D0,-10(A6)
                     513   ; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
080003E0  1D44 FFF7  514          move.b    D4,-9(A6)
                     515   ; unsigned int bytesToWrite; 
                     516   ; unsigned char lengthFlag = 0; 
080003E4  422E FFFD  517          clr.b     -3(A6)
                     518   ; int lengthCopy = (int)length;  
080003E8  2A2E 0014  519          move.l    20(A6),D5
                     520   ; unsigned int CurrentAddress = EEPROMAddress; 
080003EC  2404       521          move.l    D4,D2
                     522   ; unsigned char CurrentAddress_High;
                     523   ; unsigned char CurrentAddress_Low; 
                     524   ; IICSlaveAddress |= (blockSelect << 3);  
080003EE  102E FFF5  525          move.b    -11(A6),D0
080003F2  E708       526          lsl.b     #3,D0
080003F4  8E00       527          or.b      D0,D7
                     528   ; // Transfer IIC Slave Address
                     529   ; WaitForInternalWrite(IICSlaveAddress);
080003F6  CEBC 0000  530          and.l     #255,D7
080003FA  00FF      
080003FC  2F07       531          move.l    D7,-(A7)
080003FE  4EB9 0800  532          jsr       _WaitForInternalWrite
08000402  01E2      
08000404  584F       533          addq.w    #4,A7
                     534   ; // Transfer High EEProm Address
                     535   ; *IICTx = EEPROMAddress_High;	// fill the tx shift register
08000406  2055       536          move.l    (A5),A0
08000408  10AE FFF6  537          move.b    -10(A6),(A0)
                     538   ; *IICCommand = WR;	// set write bit
0800040C  2052       539          move.l    (A2),A0
0800040E  10BC 0010  540          move.b    #16,(A0)
                     541   ; WaitForEndOfTransfer();
08000412  4E94       542          jsr       (A4)
                     543   ; WaitForAck();
08000414  4E93       544          jsr       (A3)
                     545   ; // Transfer Low EEProm Address
                     546   ; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
08000416  2055       547          move.l    (A5),A0
08000418  10AE FFF7  548          move.b    -9(A6),(A0)
                     549   ; *IICCommand = WR;	// set write bit
0800041C  2052       550          move.l    (A2),A0
0800041E  10BC 0010  551          move.b    #16,(A0)
                     552   ; WaitForEndOfTransfer();
08000422  4E94       553          jsr       (A4)
                     554   ; WaitForAck();
08000424  4E93       555          jsr       (A3)
                     556   ; // Check difference between starting address and next block 
                     557   ; bytesToWrite = 128-EEPROMAddress%128; 
08000426  303C 0080  558          move.w    #128,D0
0800042A  48C0       559          ext.l     D0
0800042C  2F04       560          move.l    D4,-(A7)
0800042E  4878 0080  561          pea       128
08000432  4EB9 0800  562          jsr       ULDIV
08000436  0DAC      
08000438  222F 0004  563          move.l    4(A7),D1
0800043C  504F       564          addq.w    #8,A7
0800043E  9081       565          sub.l     D1,D0
08000440  2D40 FFF8  566          move.l    D0,-8(A6)
                     567   ; // First block 
                     568   ; for (i=0; i<bytesToWrite; i++)
08000444  4283       569          clr.l     D3
                     570   WriteBytes_1:
08000446  B6AE FFF8  571          cmp.l     -8(A6),D3
0800044A  6400 005E  572          bhs       WriteBytes_3
                     573   ; {
                     574   ; printf("\r\nEntered First Block Loop"); 
0800044E  4879 0800  575          pea       @iic_dr~1_1.L
08000452  1810      
08000454  4EB9 0800  576          jsr       _printf
08000458  0E8A      
0800045A  584F       577          addq.w    #4,A7
                     578   ; *IICTx = iicArray[i];
0800045C  2046       579          move.l    D6,A0
0800045E  2255       580          move.l    (A5),A1
08000460  12B0 3800  581          move.b    0(A0,D3.L),(A1)
                     582   ; if ( (i+1 >= length) || (i==(bytesToWrite-1)))
08000464  2003       583          move.l    D3,D0
08000466  5280       584          addq.l    #1,D0
08000468  B0AE 0014  585          cmp.l     20(A6),D0
0800046C  640A       586          bhs.s     WriteBytes_6
0800046E  202E FFF8  587          move.l    -8(A6),D0
08000472  5380       588          subq.l    #1,D0
08000474  B680       589          cmp.l     D0,D3
08000476  6618       590          bne.s     WriteBytes_4
                     591   WriteBytes_6:
                     592   ; {
                     593   ; if (i+1 >= length)
08000478  2003       594          move.l    D3,D0
0800047A  5280       595          addq.l    #1,D0
0800047C  B0AE 0014  596          cmp.l     20(A6),D0
08000480  6506       597          blo.s     WriteBytes_7
                     598   ; lengthFlag = 1;
08000482  1D7C 0001  599          move.b    #1,-3(A6)
08000486  FFFD      
                     600   WriteBytes_7:
                     601   ; *IICCommand = WR | STO;	//send stop signal 
08000488  2052       602          move.l    (A2),A0
0800048A  10BC 0050  603          move.b    #80,(A0)
0800048E  6006       604          bra.s     WriteBytes_5
                     605   WriteBytes_4:
                     606   ; }
                     607   ; else
                     608   ; {
                     609   ; *IICCommand = WR;	// set write bit
08000490  2052       610          move.l    (A2),A0
08000492  10BC 0010  611          move.b    #16,(A0)
                     612   WriteBytes_5:
                     613   ; }
                     614   ; WaitForEndOfTransfer();
08000496  4E94       615          jsr       (A4)
                     616   ; WaitForAck();
08000498  4E93       617          jsr       (A3)
                     618   ; lengthCopy--; 
0800049A  5385       619          subq.l    #1,D5
                     620   ; CurrentAddress++; 
0800049C  5282       621          addq.l    #1,D2
                     622   ; if (lengthFlag)
0800049E  4A2E FFFD  623          tst.b     -3(A6)
080004A2  6702       624          beq.s     WriteBytes_9
                     625   ; {
                     626   ; break; 
080004A4  6004       627          bra.s     WriteBytes_3
                     628   WriteBytes_9:
080004A6  5283       629          addq.l    #1,D3
080004A8  609C       630          bra       WriteBytes_1
                     631   WriteBytes_3:
                     632   ; }
                     633   ; }
                     634   ; // Other blocks
                     635   ; if (!lengthFlag)
080004AA  4A2E FFFD  636          tst.b     -3(A6)
080004AE  6600 0112  637          bne       WriteBytes_16
                     638   ; {
                     639   ; // Complete blocks
                     640   ; while (lengthCopy >= 128)
                     641   WriteBytes_13:
080004B2  0C85 0000  642          cmp.l     #128,D5
080004B6  0080      
080004B8  6D00 0050  643          blt       WriteBytes_15
                     644   ; {
                     645   ; printf("\r\n Entered Intermediate Loop"); 
080004BC  4879 0800  646          pea       @iic_dr~1_2.L
080004C0  182C      
080004C2  4EB9 0800  647          jsr       _printf
080004C6  0E8A      
080004C8  584F       648          addq.w    #4,A7
                     649   ; printf("\r\n Current Address Index: %x", CurrentAddress-EEPROMAddress); 
080004CA  2202       650          move.l    D2,D1
080004CC  9284       651          sub.l     D4,D1
080004CE  2F01       652          move.l    D1,-(A7)
080004D0  4879 0800  653          pea       @iic_dr~1_3.L
080004D4  184A      
080004D6  4EB9 0800  654          jsr       _printf
080004DA  0E8A      
080004DC  504F       655          addq.w    #8,A7
                     656   ; Write_128_Bytes(0xA6, CurrentAddress, &(iicArray[CurrentAddress-EEPROMAddress])); 
080004DE  2206       657          move.l    D6,D1
080004E0  2F00       658          move.l    D0,-(A7)
080004E2  2002       659          move.l    D2,D0
080004E4  9084       660          sub.l     D4,D0
080004E6  D280       661          add.l     D0,D1
080004E8  201F       662          move.l    (A7)+,D0
080004EA  2F01       663          move.l    D1,-(A7)
080004EC  2F02       664          move.l    D2,-(A7)
080004EE  4878 00A6  665          pea       166
080004F2  4EB9 0800  666          jsr       _Write_128_Bytes
080004F6  0214      
080004F8  DEFC 000C  667          add.w     #12,A7
                     668   ; CurrentAddress+=128; 
080004FC  0682 0000  669          add.l     #128,D2
08000500  0080      
                     670   ; lengthCopy-=128; 
08000502  0485 0000  671          sub.l     #128,D5
08000506  0080      
08000508  60A8       672          bra       WriteBytes_13
                     673   WriteBytes_15:
                     674   ; }
                     675   ; if (lengthCopy>0)
0800050A  0C85 0000  676          cmp.l     #0,D5
0800050E  0000      
08000510  6F00 00B0  677          ble       WriteBytes_16
                     678   ; {
                     679   ; // Prepare for write to final block
                     680   ; blockSelect = (unsigned char)CurrentAddress>>16; 
08000514  2002       681          move.l    D2,D0
08000516  E008       682          lsr.b     #8,D0
08000518  E008       683          lsr.b     #8,D0
0800051A  1D40 FFF5  684          move.b    D0,-11(A6)
                     685   ; CurrentAddress_High = (unsigned char)(CurrentAddress>>8);
0800051E  2002       686          move.l    D2,D0
08000520  E088       687          lsr.l     #8,D0
08000522  1D40 FFFE  688          move.b    D0,-2(A6)
                     689   ; CurrentAddress_Low = (unsigned char)(CurrentAddress);
08000526  1D42 FFFF  690          move.b    D2,-1(A6)
                     691   ; IICSlaveAddress |= (blockSelect << 3);  
0800052A  102E FFF5  692          move.b    -11(A6),D0
0800052E  E708       693          lsl.b     #3,D0
08000530  8E00       694          or.b      D0,D7
                     695   ; // Transfer IIC Slave Address
                     696   ; WaitForInternalWrite(IICSlaveAddress);
08000532  CEBC 0000  697          and.l     #255,D7
08000536  00FF      
08000538  2F07       698          move.l    D7,-(A7)
0800053A  4EB9 0800  699          jsr       _WaitForInternalWrite
0800053E  01E2      
08000540  584F       700          addq.w    #4,A7
                     701   ; // Transfer High EEProm Address
                     702   ; *IICTx = CurrentAddress_High;	// fill the tx shift register
08000542  2055       703          move.l    (A5),A0
08000544  10AE FFFE  704          move.b    -2(A6),(A0)
                     705   ; *IICCommand = WR;	// set write bit
08000548  2052       706          move.l    (A2),A0
0800054A  10BC 0010  707          move.b    #16,(A0)
                     708   ; WaitForEndOfTransfer();
0800054E  4E94       709          jsr       (A4)
                     710   ; WaitForAck();
08000550  4E93       711          jsr       (A3)
                     712   ; // Transfer Low EEProm Address
                     713   ; *IICTx = CurrentAddress_Low;	// fill the tx shift register
08000552  2055       714          move.l    (A5),A0
08000554  10AE FFFF  715          move.b    -1(A6),(A0)
                     716   ; *IICCommand = WR;	// set write bit
08000558  2052       717          move.l    (A2),A0
0800055A  10BC 0010  718          move.b    #16,(A0)
                     719   ; WaitForEndOfTransfer();
0800055E  4E94       720          jsr       (A4)
                     721   ; WaitForAck();
08000560  4E93       722          jsr       (A3)
                     723   ; // Last block
                     724   ; for (i=0; i<lengthCopy-1; i++)
08000562  4283       725          clr.l     D3
                     726   WriteBytes_18:
08000564  2005       727          move.l    D5,D0
08000566  5380       728          subq.l    #1,D0
08000568  B680       729          cmp.l     D0,D3
0800056A  6C00 0040  730          bge       WriteBytes_20
                     731   ; {
                     732   ; printf("\r\n Entered Last Block Loop"); 
0800056E  4879 0800  733          pea       @iic_dr~1_4.L
08000572  1868      
08000574  4EB9 0800  734          jsr       _printf
08000578  0E8A      
0800057A  584F       735          addq.w    #4,A7
                     736   ; printf("\r\n Current Address Index: %x", CurrentAddress-EEPROMAddress); 
0800057C  2202       737          move.l    D2,D1
0800057E  9284       738          sub.l     D4,D1
08000580  2F01       739          move.l    D1,-(A7)
08000582  4879 0800  740          pea       @iic_dr~1_3.L
08000586  184A      
08000588  4EB9 0800  741          jsr       _printf
0800058C  0E8A      
0800058E  504F       742          addq.w    #8,A7
                     743   ; *IICTx = iicArray[CurrentAddress-EEPROMAddress];
08000590  2046       744          move.l    D6,A0
08000592  2002       745          move.l    D2,D0
08000594  9084       746          sub.l     D4,D0
08000596  2255       747          move.l    (A5),A1
08000598  12B0 0800  748          move.b    0(A0,D0.L),(A1)
                     749   ; *IICCommand = WR;	// set write bit
0800059C  2052       750          move.l    (A2),A0
0800059E  10BC 0010  751          move.b    #16,(A0)
                     752   ; WaitForEndOfTransfer();
080005A2  4E94       753          jsr       (A4)
                     754   ; WaitForAck();
080005A4  4E93       755          jsr       (A3)
                     756   ; CurrentAddress+=1; 
080005A6  5282       757          addq.l    #1,D2
080005A8  5283       758          addq.l    #1,D3
080005AA  60B8       759          bra       WriteBytes_18
                     760   WriteBytes_20:
                     761   ; }
                     762   ; // Final byte
                     763   ; *IICTx = iicArray[CurrentAddress-EEPROMAddress];
080005AC  2046       764          move.l    D6,A0
080005AE  2002       765          move.l    D2,D0
080005B0  9084       766          sub.l     D4,D0
080005B2  2255       767          move.l    (A5),A1
080005B4  12B0 0800  768          move.b    0(A0,D0.L),(A1)
                     769   ; *IICCommand = WR | STO;	// set write bit
080005B8  2052       770          move.l    (A2),A0
080005BA  10BC 0050  771          move.b    #80,(A0)
                     772   ; WaitForEndOfTransfer();
080005BE  4E94       773          jsr       (A4)
                     774   ; WaitForAck();
080005C0  4E93       775          jsr       (A3)
                     776   WriteBytes_16:
                     777   ; }
                     778   ; }
                     779   ; printf("\r\n Exited All Loops"); 
080005C2  4879 0800  780          pea       @iic_dr~1_5.L
080005C6  1884      
080005C8  4EB9 0800  781          jsr       _printf
080005CC  0E8A      
080005CE  584F       782          addq.w    #4,A7
080005D0  4CDF 3CFC  783          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
080005D4  4E5E       784          unlk      A6
080005D6  4E75       785          rts
                     786   ; }
                     787   ; void ReadBytes(unsigned char IICSlaveAddress, unsigned int EEPROMAddress, unsigned char *buffer, unsigned int length){
                     788   _ReadBytes:
080005D8  4E56 FFF4  789          link      A6,#-12
080005DC  48E7 3F3C  790          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
080005E0  45F9 0800  791          lea       _IICCommand.L,A2
080005E4  1A42      
080005E6  282E 000C  792          move.l    12(A6),D4
080005EA  47F9 0800  793          lea       _WaitForEndOfTransfer.L,A3
080005EE  003E      
080005F0  49F9 0800  794          lea       _printf.L,A4
080005F4  0E8A      
080005F6  4BF9 0800  795          lea       _WaitForAck.L,A5
080005FA  0052      
080005FC  1A2E 000B  796          move.b    11(A6),D5
08000600  CABC 0000  797          and.l     #255,D5
08000604  00FF      
08000606  2E2E 0010  798          move.l    16(A6),D7
                     799   ; int i; 
                     800   ; unsigned char blockSelect = (unsigned char)EEPROMAddress>>16; 
0800060A  2004       801          move.l    D4,D0
0800060C  E008       802          lsr.b     #8,D0
0800060E  E008       803          lsr.b     #8,D0
08000610  1D40 FFF5  804          move.b    D0,-11(A6)
                     805   ; unsigned char EEPROMAddress_High = (unsigned char)(EEPROMAddress>>8); 
08000614  2004       806          move.l    D4,D0
08000616  E088       807          lsr.l     #8,D0
08000618  1D40 FFF6  808          move.b    D0,-10(A6)
                     809   ; unsigned char EEPROMAddress_Low = (unsigned char)EEPROMAddress; 
0800061C  1D44 FFF7  810          move.b    D4,-9(A6)
                     811   ; unsigned int bytesToRead; 
                     812   ; unsigned char lengthFlag = 0; 
08000620  422E FFFD  813          clr.b     -3(A6)
                     814   ; int lengthCopy = (int)length;  
08000624  2C2E 0014  815          move.l    20(A6),D6
                     816   ; unsigned int CurrentAddress = EEPROMAddress; 
08000628  2404       817          move.l    D4,D2
                     818   ; unsigned char CurrentAddress_High;
                     819   ; unsigned char CurrentAddress_Low; 
                     820   ; IICSlaveAddress |= (blockSelect << 3);  
0800062A  102E FFF5  821          move.b    -11(A6),D0
0800062E  E708       822          lsl.b     #3,D0
08000630  8A00       823          or.b      D0,D5
                     824   ; // Transfer IIC Slave Address
                     825   ; WaitForInternalWrite(IICSlaveAddress);
08000632  CABC 0000  826          and.l     #255,D5
08000636  00FF      
08000638  2F05       827          move.l    D5,-(A7)
0800063A  4EB9 0800  828          jsr       _WaitForInternalWrite
0800063E  01E2      
08000640  584F       829          addq.w    #4,A7
                     830   ; // Transfer High EEProm Address
                     831   ; *IICTx = EEPROMAddress_High;	// fill the tx shift register
08000642  2079 0800  832          move.l    _IICTx.L,A0
08000646  1A36      
08000648  10AE FFF6  833          move.b    -10(A6),(A0)
                     834   ; *IICCommand = WR;	// set write bit
0800064C  2052       835          move.l    (A2),A0
0800064E  10BC 0010  836          move.b    #16,(A0)
                     837   ; WaitForEndOfTransfer();
08000652  4E93       838          jsr       (A3)
                     839   ; WaitForAck();
08000654  4E95       840          jsr       (A5)
                     841   ; // Transfer Low EEProm Address
                     842   ; *IICTx = EEPROMAddress_Low;	// fill the tx shift register
08000656  2079 0800  843          move.l    _IICTx.L,A0
0800065A  1A36      
0800065C  10AE FFF7  844          move.b    -9(A6),(A0)
                     845   ; *IICCommand = WR;	// set write bit
08000660  2052       846          move.l    (A2),A0
08000662  10BC 0010  847          move.b    #16,(A0)
                     848   ; WaitForEndOfTransfer();
08000666  4E93       849          jsr       (A3)
                     850   ; WaitForAck();
08000668  4E95       851          jsr       (A5)
                     852   ; // Fetch Data
                     853   ; *IICTx = IICSlaveAddress | READ;
0800066A  1005       854          move.b    D5,D0
0800066C  803C 0001  855          or.b      #1,D0
08000670  2079 0800  856          move.l    _IICTx.L,A0
08000674  1A36      
08000676  1080       857          move.b    D0,(A0)
                     858   ; *IICCommand = WR | STA;	//send start signal
08000678  2052       859          move.l    (A2),A0
0800067A  10BC 0090  860          move.b    #144,(A0)
                     861   ; WaitForEndOfTransfer();
0800067E  4E93       862          jsr       (A3)
                     863   ; WaitForAck();
08000680  4E95       864          jsr       (A5)
                     865   ; // Check difference between starting address and next block 
                     866   ; bytesToRead = 128-EEPROMAddress%128; 
08000682  303C 0080  867          move.w    #128,D0
08000686  48C0       868          ext.l     D0
08000688  2F04       869          move.l    D4,-(A7)
0800068A  4878 0080  870          pea       128
0800068E  4EB9 0800  871          jsr       ULDIV
08000692  0DAC      
08000694  222F 0004  872          move.l    4(A7),D1
08000698  504F       873          addq.w    #8,A7
0800069A  9081       874          sub.l     D1,D0
0800069C  2D40 FFF8  875          move.l    D0,-8(A6)
                     876   ; // First block 
                     877   ; for (i=0; i<bytesToRead; i++)
080006A0  4283       878          clr.l     D3
                     879   ReadBytes_1:
080006A2  B6AE FFF8  880          cmp.l     -8(A6),D3
080006A6  6400 005C  881          bhs       ReadBytes_3
                     882   ; {
                     883   ; printf("\r\nEntered First Block Loop"); 
080006AA  4879 0800  884          pea       @iic_dr~1_1.L
080006AE  1810      
080006B0  4E94       885          jsr       (A4)
080006B2  584F       886          addq.w    #4,A7
                     887   ; if ( (i+1 >= length) || (i==(bytesToRead-1)))
080006B4  2003       888          move.l    D3,D0
080006B6  5280       889          addq.l    #1,D0
080006B8  B0AE 0014  890          cmp.l     20(A6),D0
080006BC  640A       891          bhs.s     ReadBytes_6
080006BE  202E FFF8  892          move.l    -8(A6),D0
080006C2  5380       893          subq.l    #1,D0
080006C4  B680       894          cmp.l     D0,D3
080006C6  6618       895          bne.s     ReadBytes_4
                     896   ReadBytes_6:
                     897   ; {
                     898   ; if (i+1 >= length)
080006C8  2003       899          move.l    D3,D0
080006CA  5280       900          addq.l    #1,D0
080006CC  B0AE 0014  901          cmp.l     20(A6),D0
080006D0  6506       902          blo.s     ReadBytes_7
                     903   ; lengthFlag = 1;
080006D2  1D7C 0001  904          move.b    #1,-3(A6)
080006D6  FFFD      
                     905   ReadBytes_7:
                     906   ; *IICCommand = RD | STO | NACK;	//send stop signal 
080006D8  2052       907          move.l    (A2),A0
080006DA  10BC 0068  908          move.b    #104,(A0)
080006DE  6006       909          bra.s     ReadBytes_5
                     910   ReadBytes_4:
                     911   ; }
                     912   ; else
                     913   ; {
                     914   ; *IICCommand = RD;	// set write bit
080006E0  2052       915          move.l    (A2),A0
080006E2  10BC 0020  916          move.b    #32,(A0)
                     917   ReadBytes_5:
                     918   ; }
                     919   ; WaitForEndOfTransfer();
080006E6  4E93       920          jsr       (A3)
                     921   ; buffer[i] = *IICRx; 
080006E8  2079 0800  922          move.l    _IICRx.L,A0
080006EC  1A3A      
080006EE  2247       923          move.l    D7,A1
080006F0  1390 3800  924          move.b    (A0),0(A1,D3.L)
                     925   ; lengthCopy--; 
080006F4  5386       926          subq.l    #1,D6
                     927   ; CurrentAddress++; 
080006F6  5282       928          addq.l    #1,D2
                     929   ; if (lengthFlag)
080006F8  4A2E FFFD  930          tst.b     -3(A6)
080006FC  6702       931          beq.s     ReadBytes_9
                     932   ; {
                     933   ; break; 
080006FE  6004       934          bra.s     ReadBytes_3
                     935   ReadBytes_9:
08000700  5283       936          addq.l    #1,D3
08000702  609E       937          bra       ReadBytes_1
                     938   ReadBytes_3:
                     939   ; }
                     940   ; }
                     941   ; // Other blocks
                     942   ; if (!lengthFlag)
08000704  4A2E FFFD  943          tst.b     -3(A6)
08000708  6600 0126  944          bne       ReadBytes_16
                     945   ; {
                     946   ; // Complete blocks
                     947   ; while (lengthCopy >= 128)
                     948   ReadBytes_13:
0800070C  0C86 0000  949          cmp.l     #128,D6
08000710  0080      
08000712  6D00 0048  950          blt       ReadBytes_15
                     951   ; {
                     952   ; printf("\r\n Entered Intermediate Loop"); 
08000716  4879 0800  953          pea       @iic_dr~1_2.L
0800071A  182C      
0800071C  4E94       954          jsr       (A4)
0800071E  584F       955          addq.w    #4,A7
                     956   ; printf("\r\n Current Address Index: %x", CurrentAddress-EEPROMAddress); 
08000720  2202       957          move.l    D2,D1
08000722  9284       958          sub.l     D4,D1
08000724  2F01       959          move.l    D1,-(A7)
08000726  4879 0800  960          pea       @iic_dr~1_3.L
0800072A  184A      
0800072C  4E94       961          jsr       (A4)
0800072E  504F       962          addq.w    #8,A7
                     963   ; Read_128_Bytes(0xA6, CurrentAddress, &(buffer[CurrentAddress-EEPROMAddress])); 
08000730  2207       964          move.l    D7,D1
08000732  2F00       965          move.l    D0,-(A7)
08000734  2002       966          move.l    D2,D0
08000736  9084       967          sub.l     D4,D0
08000738  D280       968          add.l     D0,D1
0800073A  201F       969          move.l    (A7)+,D0
0800073C  2F01       970          move.l    D1,-(A7)
0800073E  2F02       971          move.l    D2,-(A7)
08000740  4878 00A6  972          pea       166
08000744  4EB9 0800  973          jsr       _Read_128_Bytes
08000748  02CA      
0800074A  DEFC 000C  974          add.w     #12,A7
                     975   ; CurrentAddress+=128; 
0800074E  0682 0000  976          add.l     #128,D2
08000752  0080      
                     977   ; lengthCopy-=128; 
08000754  0486 0000  978          sub.l     #128,D6
08000758  0080      
0800075A  60B0       979          bra       ReadBytes_13
                     980   ReadBytes_15:
                     981   ; }
                     982   ; if (lengthCopy>0)
0800075C  0C86 0000  983          cmp.l     #0,D6
08000760  0000      
08000762  6F00 00CC  984          ble       ReadBytes_16
                     985   ; {
                     986   ; // Prepare for write to final block
                     987   ; blockSelect = (unsigned char)CurrentAddress>>16; 
08000766  2002       988          move.l    D2,D0
08000768  E008       989          lsr.b     #8,D0
0800076A  E008       990          lsr.b     #8,D0
0800076C  1D40 FFF5  991          move.b    D0,-11(A6)
                     992   ; CurrentAddress_High = (unsigned char)(CurrentAddress>>8);
08000770  2002       993          move.l    D2,D0
08000772  E088       994          lsr.l     #8,D0
08000774  1D40 FFFE  995          move.b    D0,-2(A6)
                     996   ; CurrentAddress_Low = (unsigned char)(CurrentAddress);
08000778  1D42 FFFF  997          move.b    D2,-1(A6)
                     998   ; IICSlaveAddress |= (blockSelect << 3);  
0800077C  102E FFF5  999          move.b    -11(A6),D0
08000780  E708      1000          lsl.b     #3,D0
08000782  8A00      1001          or.b      D0,D5
                    1002   ; // Transfer IIC Slave Address
                    1003   ; WaitForInternalWrite(IICSlaveAddress);
08000784  CABC 0000 1004          and.l     #255,D5
08000788  00FF      
0800078A  2F05      1005          move.l    D5,-(A7)
0800078C  4EB9 0800 1006          jsr       _WaitForInternalWrite
08000790  01E2      
08000792  584F      1007          addq.w    #4,A7
                    1008   ; // Transfer High EEProm Address
                    1009   ; *IICTx = CurrentAddress_High;	// fill the tx shift register
08000794  2079 0800 1010          move.l    _IICTx.L,A0
08000798  1A36      
0800079A  10AE FFFE 1011          move.b    -2(A6),(A0)
                    1012   ; *IICCommand = WR;	// set write bit
0800079E  2052      1013          move.l    (A2),A0
080007A0  10BC 0010 1014          move.b    #16,(A0)
                    1015   ; WaitForEndOfTransfer();
080007A4  4E93      1016          jsr       (A3)
                    1017   ; WaitForAck();
080007A6  4E95      1018          jsr       (A5)
                    1019   ; // Transfer Low EEProm Address
                    1020   ; *IICTx = CurrentAddress_Low;	// fill the tx shift register
080007A8  2079 0800 1021          move.l    _IICTx.L,A0
080007AC  1A36      
080007AE  10AE FFFF 1022          move.b    -1(A6),(A0)
                    1023   ; *IICCommand = WR;	// set write bit
080007B2  2052      1024          move.l    (A2),A0
080007B4  10BC 0010 1025          move.b    #16,(A0)
                    1026   ; WaitForEndOfTransfer();
080007B8  4E93      1027          jsr       (A3)
                    1028   ; WaitForAck();
080007BA  4E95      1029          jsr       (A5)
                    1030   ; // Fetch Data
                    1031   ; *IICTx = IICSlaveAddress | READ;
080007BC  1005      1032          move.b    D5,D0
080007BE  803C 0001 1033          or.b      #1,D0
080007C2  2079 0800 1034          move.l    _IICTx.L,A0
080007C6  1A36      
080007C8  1080      1035          move.b    D0,(A0)
                    1036   ; *IICCommand = WR | STA;	//send start signal
080007CA  2052      1037          move.l    (A2),A0
080007CC  10BC 0090 1038          move.b    #144,(A0)
                    1039   ; WaitForEndOfTransfer();
080007D0  4E93      1040          jsr       (A3)
                    1041   ; WaitForAck();
080007D2  4E95      1042          jsr       (A5)
                    1043   ; // Last block
                    1044   ; for (i=0; i<lengthCopy-1; i++)
080007D4  4283      1045          clr.l     D3
                    1046   ReadBytes_18:
080007D6  2006      1047          move.l    D6,D0
080007D8  5380      1048          subq.l    #1,D0
080007DA  B680      1049          cmp.l     D0,D3
080007DC  6C00 003A 1050          bge       ReadBytes_20
                    1051   ; {
                    1052   ; printf("\r\n Entered Last Block Loop"); 
080007E0  4879 0800 1053          pea       @iic_dr~1_4.L
080007E4  1868      
080007E6  4E94      1054          jsr       (A4)
080007E8  584F      1055          addq.w    #4,A7
                    1056   ; printf("\r\n Current Address Index: %x", CurrentAddress-EEPROMAddress); 
080007EA  2202      1057          move.l    D2,D1
080007EC  9284      1058          sub.l     D4,D1
080007EE  2F01      1059          move.l    D1,-(A7)
080007F0  4879 0800 1060          pea       @iic_dr~1_3.L
080007F4  184A      
080007F6  4E94      1061          jsr       (A4)
080007F8  504F      1062          addq.w    #8,A7
                    1063   ; *IICCommand = RD;	// set read bit
080007FA  2052      1064          move.l    (A2),A0
080007FC  10BC 0020 1065          move.b    #32,(A0)
                    1066   ; WaitForEndOfTransfer();
08000800  4E93      1067          jsr       (A3)
                    1068   ; buffer[CurrentAddress-EEPROMAddress] = *IICRx; 
08000802  2079 0800 1069          move.l    _IICRx.L,A0
08000806  1A3A      
08000808  2247      1070          move.l    D7,A1
0800080A  2002      1071          move.l    D2,D0
0800080C  9084      1072          sub.l     D4,D0
0800080E  1390 0800 1073          move.b    (A0),0(A1,D0.L)
                    1074   ; CurrentAddress+=1; 
08000812  5282      1075          addq.l    #1,D2
08000814  5283      1076          addq.l    #1,D3
08000816  60BE      1077          bra       ReadBytes_18
                    1078   ReadBytes_20:
                    1079   ; }
                    1080   ; // Final byte
                    1081   ; *IICCommand = RD | STO | NACK;	// set read bit
08000818  2052      1082          move.l    (A2),A0
0800081A  10BC 0068 1083          move.b    #104,(A0)
                    1084   ; WaitForEndOfTransfer();
0800081E  4E93      1085          jsr       (A3)
                    1086   ; buffer[CurrentAddress-EEPROMAddress] = *IICRx; 
08000820  2079 0800 1087          move.l    _IICRx.L,A0
08000824  1A3A      
08000826  2247      1088          move.l    D7,A1
08000828  2002      1089          move.l    D2,D0
0800082A  9084      1090          sub.l     D4,D0
0800082C  1390 0800 1091          move.b    (A0),0(A1,D0.L)
                    1092   ReadBytes_16:
                    1093   ; }
                    1094   ; }
                    1095   ; printf("\r\n Exited All Loops"); 
08000830  4879 0800 1096          pea       @iic_dr~1_5.L
08000834  1884      
08000836  4E94      1097          jsr       (A4)
08000838  584F      1098          addq.w    #4,A7
0800083A  4CDF 3CFC 1099          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0800083E  4E5E      1100          unlk      A6
08000840  4E75      1101          rts
                    1102   ; }
                    1103   ; C:\M68KV6.0 - 640BY480\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS\PROGRAMS\LAB5\M68KUSERPROGRAM (DE1).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1104   ; #include <stdio.h>
                    1105   ; #include <string.h>
                    1106   ; #include <ctype.h>
                    1107   ; #include "IIC_Driver.h"
                    1108   ; #include "ADC_DAC.h"
                    1109   ; //IMPORTANT
                    1110   ; //
                    1111   ; // Uncomment one of the two #defines below
                    1112   ; // Define StartOfExceptionVectorTable as 08030000 if running programs from sram or
                    1113   ; // 0B000000 for running programs from dram
                    1114   ; //
                    1115   ; // In your labs, you will initially start by designing a system with SRam and later move to
                    1116   ; // Dram, so these constants will need to be changed based on the version of the system you have
                    1117   ; // building
                    1118   ; //
                    1119   ; // The working 68k system SOF file posted on canvas that you can use for your pre-lab
                    1120   ; // is based around Dram so #define accordingly before building
                    1121   ; #define MAX_SPI_ADDRESS 0x7FFFF
                    1122   ; #define NUM_SECTORS 128
                    1123   ; #define WRITES_PER_SECTOR 16
                    1124   ; // #define StartOfExceptionVectorTable 0x08030000
                    1125   ; #define StartOfExceptionVectorTable 0x0B000000
                    1126   ; // #define CLOCK_FREQUENCY 45000000
                    1127   ; #define CLOCK_FREQUENCY 25000000
                    1128   ; /**********************************************************************************************
                    1129   ; **	Parallel port addresses
                    1130   ; **********************************************************************************************/
                    1131   ; #define PortA   *(volatile unsigned char *)(0x00400000)
                    1132   ; #define PortB   *(volatile unsigned char *)(0x00400002)
                    1133   ; #define PortC   *(volatile unsigned char *)(0x00400004)
                    1134   ; #define PortD   *(volatile unsigned char *)(0x00400006)
                    1135   ; #define PortE   *(volatile unsigned char *)(0x00400008)
                    1136   ; // /*********************************************************************************************
                    1137   ; // **	Hex 7 seg displays port addresses
                    1138   ; // *********************************************************************************************/
                    1139   ; #define HEX_A        *(volatile unsigned char *)(0x00400010)
                    1140   ; #define HEX_B        *(volatile unsigned char *)(0x00400012)
                    1141   ; #define HEX_C        *(volatile unsigned char *)(0x00400014)    // de2 only
                    1142   ; #define HEX_D        *(volatile unsigned char *)(0x00400016)    // de2 only
                    1143   ; /**********************************************************************************************
                    1144   ; **	LCD display port addresses
                    1145   ; **********************************************************************************************/
                    1146   ; #define LCDcommand   *(volatile unsigned char *)(0x00400020)
                    1147   ; #define LCDdata      *(volatile unsigned char *)(0x00400022)
                    1148   ; /*******************************************************************************************
                    1149   ; **	Timer Port addresses
                    1150   ; ********************************************************************************************/
                    1151   ; #define Timer1Data      *(volatile unsigned char *)(0x00400030)
                    1152   ; #define Timer1Control   *(volatile unsigned char *)(0x00400032)
                    1153   ; #define Timer1Status    *(volatile unsigned char *)(0x00400032)
                    1154   ; #define Timer2Data      *(volatile unsigned char *)(0x00400034)
                    1155   ; #define Timer2Control   *(volatile unsigned char *)(0x00400036)
                    1156   ; #define Timer2Status    *(volatile unsigned char *)(0x00400036)
                    1157   ; #define Timer3Data      *(volatile unsigned char *)(0x00400038)
                    1158   ; #define Timer3Control   *(volatile unsigned char *)(0x0040003A)
                    1159   ; #define Timer3Status    *(volatile unsigned char *)(0x0040003A)
                    1160   ; #define Timer4Data      *(volatile unsigned char *)(0x0040003C)
                    1161   ; #define Timer4Control   *(volatile unsigned char *)(0x0040003E)
                    1162   ; #define Timer4Status    *(volatile unsigned char *)(0x0040003E)
                    1163   ; // /*********************************************************************************************
                    1164   ; // **	RS232 port addresses
                    1165   ; // *********************************************************************************************/
                    1166   ; #define RS232_Control     *(volatile unsigned char *)(0x00400040)
                    1167   ; #define RS232_Status      *(volatile unsigned char *)(0x00400040)
                    1168   ; #define RS232_TxData      *(volatile unsigned char *)(0x00400042)
                    1169   ; #define RS232_RxData      *(volatile unsigned char *)(0x00400042)
                    1170   ; #define RS232_Baud        *(volatile unsigned char *)(0x00400044)
                    1171   ; /*********************************************************************************************
                    1172   ; **	PIA 1 and 2 port addresses
                    1173   ; *********************************************************************************************/
                    1174   ; #define PIA1_PortA_Data     *(volatile unsigned char *)(0x00400050)         // combined data and data direction register share same address
                    1175   ; #define PIA1_PortA_Control *(volatile unsigned char *)(0x00400052)
                    1176   ; #define PIA1_PortB_Data     *(volatile unsigned char *)(0x00400054)         // combined data and data direction register share same address
                    1177   ; #define PIA1_PortB_Control *(volatile unsigned char *)(0x00400056)
                    1178   ; #define PIA2_PortA_Data     *(volatile unsigned char *)(0x00400060)         // combined data and data direction register share same address
                    1179   ; #define PIA2_PortA_Control *(volatile unsigned char *)(0x00400062)
                    1180   ; #define PIA2_PortB_data     *(volatile unsigned char *)(0x00400064)         // combined data and data direction register share same address
                    1181   ; #define PIA2_PortB_Control *(volatile unsigned char *)(0x00400066)
                    1182   ; // SPI Registers
                    1183   ; #define SPI_Control         (*(volatile unsigned char *)(0x00408020))
                    1184   ; #define SPI_Status          (*(volatile unsigned char *)(0x00408022))
                    1185   ; #define SPI_Data            (*(volatile unsigned char *)(0x00408024))
                    1186   ; #define SPI_Ext             (*(volatile unsigned char *)(0x00408026))
                    1187   ; #define SPI_CS              (*(volatile unsigned char *)(0x00408028))
                    1188   ; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
                    1189   ; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
                    1190   ; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
                    1191   ; // and write FF to disable it
                    1192   ; #define   Enable_SPI_CS()             SPI_CS = 0xFE
                    1193   ; #define   Disable_SPI_CS()            SPI_CS = 0xFF 
                    1194   ; typedef struct 
                    1195   ; {
                    1196   ; unsigned char SPR       : 2;
                    1197   ; unsigned char CPHA      : 1;
                    1198   ; unsigned char CPOL      : 1; 
                    1199   ; unsigned char MSTR      : 1;
                    1200   ; unsigned char reserved  : 1; 
                    1201   ; unsigned char SPE       : 1;
                    1202   ; unsigned char SPIE      : 1; 
                    1203   ; } ControlRegister_t; 
                    1204   ; typedef struct 
                    1205   ; {
                    1206   ; unsigned char ESPR      : 2;
                    1207   ; unsigned char Reserved  : 4;
                    1208   ; unsigned char ICNT      : 2; 
                    1209   ; } ExtRegister_t;
                    1210   ; typedef struct 
                    1211   ; {
                    1212   ; unsigned char CS0       : 1; 
                    1213   ; unsigned char CS1       : 1; 
                    1214   ; unsigned char CS2       : 1; 
                    1215   ; unsigned char CS3       : 1; 
                    1216   ; unsigned char CS4       : 1; 
                    1217   ; unsigned char CS5       : 1; 
                    1218   ; unsigned char CS6       : 1; 
                    1219   ; unsigned char CS7       : 1; 
                    1220   ; } CSRegister_t;
                    1221   ; typedef struct 
                    1222   ; {
                    1223   ; unsigned char SPIF      : 1;
                    1224   ; unsigned char WCOL      : 1;
                    1225   ; unsigned char reserved  : 2; 
                    1226   ; unsigned char WF_FULL   : 1;
                    1227   ; unsigned char WF_EMPTY  : 1; 
                    1228   ; unsigned char RF_FULL   : 1;
                    1229   ; unsigned char RF_EMPTY  : 1; 
                    1230   ; } StatusRegister_t; 
                    1231   ; /*********************************************************************************************************************************
                    1232   ; (( DO NOT initialise global variables here, do it main even if you want 0
                    1233   ; (( it's a limitation of the compiler
                    1234   ; (( YOU HAVE BEEN WARNED
                    1235   ; *********************************************************************************************************************************/
                    1236   ; unsigned int x, y, z, PortA_Count;
                    1237   ; unsigned char Timer1Count, Timer2Count, Timer3Count, Timer4Count ;
                    1238   ; volatile unsigned long int counter, rollovers;
                    1239   ; int a[100][100], b[100][100], c[100][100];
                    1240   ; int i, j, k, sum;
                    1241   ; /*******************************************************************************************
                    1242   ; ** Function Prototypes
                    1243   ; *******************************************************************************************/
                    1244   ; void Wait1ms(void);
                    1245   ; void Wait3ms(void);
                    1246   ; void Init_LCD(void) ;
                    1247   ; void LCDOutchar(int c);
                    1248   ; void LCDOutMess(char *theMessage);
                    1249   ; void LCDClearln(void);
                    1250   ; void LCDline1Message(char *theMessage);
                    1251   ; void LCDline2Message(char *theMessage);
                    1252   ; int sprintf(char *out, const char *format, ...) ;
                    1253   ; void startTimer(void);
                    1254   ; unsigned long int endTimer(void);
                    1255   ; /*****************************************************************************************
                    1256   ; **	Interrupt service routine for Timers
                    1257   ; **
                    1258   ; **  Timers 1 - 4 share a common IRQ on the CPU  so this function uses polling to figure
                    1259   ; **  out which timer is producing the interrupt
                    1260   ; **
                    1261   ; *****************************************************************************************/
                    1262   ; void Timer_ISR()
                    1263   ; {
                    1264   _Timer_ISR:
                    1265   ; if(Timer1Status == 1) {         // Did Timer 1 produce the Interrupt?
08000842  1039 0040 1266          move.b    4194354,D0
08000846  0032      
08000848  0C00 0001 1267          cmp.b     #1,D0
0800084C  661C      1268          bne.s     Timer_ISR_3
                    1269   ; Timer1Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0800084E  13FC 0003 1270          move.b    #3,4194354
08000852  0040 0032 
                    1271   ; //PortA = Timer1Count++ ;     // increment an LED count on PortA with each tick of Timer 1
                    1272   ; counter++;
08000856  52B9 0800 1273          addq.l    #1,_counter.L
0800085A  1A6A      
                    1274   ; if (!counter)   //handle the counter rolling over, who knows, maybe something will take an eternity to run
0800085C  4AB9 0800 1275          tst.l     _counter.L
08000860  1A6A      
08000862  6606      1276          bne.s     Timer_ISR_3
                    1277   ; rollovers++;
08000864  52B9 0800 1278          addq.l    #1,_rollovers.L
08000868  1A6E      
                    1279   Timer_ISR_3:
                    1280   ; }
                    1281   ; if(Timer2Status == 1) {         // Did Timer 2 produce the Interrupt?
0800086A  1039 0040 1282          move.b    4194358,D0
0800086E  0036      
08000870  0C00 0001 1283          cmp.b     #1,D0
08000874  661A      1284          bne.s     Timer_ISR_5
                    1285   ; Timer2Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
08000876  13FC 0003 1286          move.b    #3,4194358
0800087A  0040 0036 
                    1287   ; PortC = Timer2Count++ ;     // increment an LED count on PortC with each tick of Timer 2
0800087E  1039 0800 1288          move.b    _Timer2Count.L,D0
08000882  1A64      
08000884  5239 0800 1289          addq.b    #1,_Timer2Count.L
08000888  1A64      
0800088A  13C0 0040 1290          move.b    D0,4194308
0800088E  0004      
                    1291   Timer_ISR_5:
                    1292   ; }
                    1293   ; if(Timer3Status == 1) {         // Did Timer 3 produce the Interrupt?
08000890  1039 0040 1294          move.b    4194362,D0
08000894  003A      
08000896  0C00 0001 1295          cmp.b     #1,D0
0800089A  661A      1296          bne.s     Timer_ISR_7
                    1297   ; Timer3Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0800089C  13FC 0003 1298          move.b    #3,4194362
080008A0  0040 003A 
                    1299   ; HEX_A = Timer3Count++ ;     // increment a HEX count on Port HEX_A with each tick of Timer 3
080008A4  1039 0800 1300          move.b    _Timer3Count.L,D0
080008A8  1A66      
080008AA  5239 0800 1301          addq.b    #1,_Timer3Count.L
080008AE  1A66      
080008B0  13C0 0040 1302          move.b    D0,4194320
080008B4  0010      
                    1303   Timer_ISR_7:
                    1304   ; }
                    1305   ; if(Timer4Status == 1) {         // Did Timer 4 produce the Interrupt?
080008B6  1039 0040 1306          move.b    4194366,D0
080008BA  003E      
080008BC  0C00 0001 1307          cmp.b     #1,D0
080008C0  661A      1308          bne.s     Timer_ISR_9
                    1309   ; Timer4Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
080008C2  13FC 0003 1310          move.b    #3,4194366
080008C6  0040 003E 
                    1311   ; HEX_B = Timer4Count++ ;     // increment a HEX count on HEX_B with each tick of Timer 4
080008CA  1039 0800 1312          move.b    _Timer4Count.L,D0
080008CE  1A68      
080008D0  5239 0800 1313          addq.b    #1,_Timer4Count.L
080008D4  1A68      
080008D6  13C0 0040 1314          move.b    D0,4194322
080008DA  0012      
                    1315   Timer_ISR_9:
080008DC  4E75      1316          rts
                    1317   ; }
                    1318   ; }
                    1319   ; /*****************************************************************************************
                    1320   ; **	Interrupt service routine for ACIA. This device has it's own dedicate IRQ level
                    1321   ; **  Add your code here to poll Status register and clear interrupt
                    1322   ; *****************************************************************************************/
                    1323   ; void ACIA_ISR()
                    1324   ; {}
                    1325   _ACIA_ISR:
080008DE  4E75      1326          rts
                    1327   ; /***************************************************************************************
                    1328   ; **	Interrupt service routine for PIAs 1 and 2. These devices share an IRQ level
                    1329   ; **  Add your code here to poll Status register and clear interrupt
                    1330   ; *****************************************************************************************/
                    1331   ; void PIA_ISR()
                    1332   ; {}
                    1333   _PIA_ISR:
080008E0  4E75      1334          rts
                    1335   ; /***********************************************************************************
                    1336   ; **	Interrupt service routine for Key 2 on DE1 board. Add your own response here
                    1337   ; ************************************************************************************/
                    1338   ; void Key2PressISR()
                    1339   ; {}
                    1340   _Key2PressISR:
080008E2  4E75      1341          rts
                    1342   ; /***********************************************************************************
                    1343   ; **	Interrupt service routine for Key 1 on DE1 board. Add your own response here
                    1344   ; ************************************************************************************/
                    1345   ; void Key1PressISR()
                    1346   ; {}
                    1347   _Key1PressISR:
080008E4  4E75      1348          rts
                    1349   ; /************************************************************************************
                    1350   ; **   Delay Subroutine to give the 68000 something useless to do to waste 1 mSec
                    1351   ; ************************************************************************************/
                    1352   ; void Wait1ms(void)
                    1353   ; {
                    1354   _Wait1ms:
080008E6  2F02      1355          move.l    D2,-(A7)
                    1356   ; int  i ;
                    1357   ; for(i = 0; i < 1000; i ++)
080008E8  4282      1358          clr.l     D2
                    1359   Wait1ms_1:
080008EA  0C82 0000 1360          cmp.l     #1000,D2
080008EE  03E8      
080008F0  6C04      1361          bge.s     Wait1ms_3
080008F2  5282      1362          addq.l    #1,D2
080008F4  60F4      1363          bra       Wait1ms_1
                    1364   Wait1ms_3:
080008F6  241F      1365          move.l    (A7)+,D2
080008F8  4E75      1366          rts
                    1367   ; ;
                    1368   ; }
                    1369   ; /************************************************************************************
                    1370   ; **  Subroutine to give the 68000 something useless to do to waste 3 mSec
                    1371   ; **************************************************************************************/
                    1372   ; void Wait3ms(void)
                    1373   ; {
                    1374   _Wait3ms:
080008FA  2F02      1375          move.l    D2,-(A7)
                    1376   ; int i ;
                    1377   ; for(i = 0; i < 3; i++)
080008FC  4282      1378          clr.l     D2
                    1379   Wait3ms_1:
080008FE  0C82 0000 1380          cmp.l     #3,D2
08000902  0003      
08000904  6C0A      1381          bge.s     Wait3ms_3
                    1382   ; Wait1ms() ;
08000906  4EB9 0800 1383          jsr       _Wait1ms
0800090A  08E6      
0800090C  5282      1384          addq.l    #1,D2
0800090E  60EE      1385          bra       Wait3ms_1
                    1386   Wait3ms_3:
08000910  241F      1387          move.l    (A7)+,D2
08000912  4E75      1388          rts
                    1389   ; }
                    1390   ; /*********************************************************************************************
                    1391   ; **  Subroutine to initialise the LCD display by writing some commands to the LCD internal registers
                    1392   ; **  Sets it for parallel port and 2 line display mode (if I recall correctly)
                    1393   ; *********************************************************************************************/
                    1394   ; void Init_LCD(void)
                    1395   ; {
                    1396   _Init_LCD:
                    1397   ; LCDcommand = 0x0c ;
08000914  13FC 000C 1398          move.b    #12,4194336
08000918  0040 0020 
                    1399   ; Wait3ms() ;
0800091C  4EB9 0800 1400          jsr       _Wait3ms
08000920  08FA      
                    1401   ; LCDcommand = 0x38 ;
08000922  13FC 0038 1402          move.b    #56,4194336
08000926  0040 0020 
                    1403   ; Wait3ms() ;
0800092A  4EB9 0800 1404          jsr       _Wait3ms
0800092E  08FA      
08000930  4E75      1405          rts
                    1406   ; }
                    1407   ; /*********************************************************************************************
                    1408   ; **  Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    1409   ; *********************************************************************************************/
                    1410   ; void Init_RS232(void)
                    1411   ; {
                    1412   _Init_RS232:
                    1413   ; RS232_Control = 0x15 ; //  %00010101 set up 6850 uses divide by 16 clock, set RTS low, 8 bits no parity, 1 stop bit, transmitter interrupt disabled
08000932  13FC 0015 1414          move.b    #21,4194368
08000936  0040 0040 
                    1415   ; RS232_Baud = 0x1 ;      // program baud rate generator 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
0800093A  13FC 0001 1416          move.b    #1,4194372
0800093E  0040 0044 
08000942  4E75      1417          rts
                    1418   ; }
                    1419   ; /*********************************************************************************************************
                    1420   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    1421   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    1422   ; **  to allow the board to communicate with HyperTerminal Program
                    1423   ; **
                    1424   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    1425   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    1426   ; **  call _putch() also
                    1427   ; *********************************************************************************************************/
                    1428   ; int _putch( int c)
                    1429   ; {
                    1430   __putch:
08000944  4E56 0000 1431          link      A6,#0
                    1432   ; while((RS232_Status & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    1433   _putch_1:
08000948  1039 0040 1434          move.b    4194368,D0
0800094C  0040      
0800094E  C03C 0002 1435          and.b     #2,D0
08000952  0C00 0002 1436          cmp.b     #2,D0
08000956  6702      1437          beq.s     _putch_3
08000958  60EE      1438          bra       _putch_1
                    1439   _putch_3:
                    1440   ; ;
                    1441   ; RS232_TxData = (c & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
0800095A  202E 0008 1442          move.l    8(A6),D0
0800095E  C0BC 0000 1443          and.l     #127,D0
08000962  007F      
08000964  13C0 0040 1444          move.b    D0,4194370
08000968  0042      
                    1445   ; return c ;                                              // putchar() expects the character to be returned
0800096A  202E 0008 1446          move.l    8(A6),D0
0800096E  4E5E      1447          unlk      A6
08000970  4E75      1448          rts
                    1449   ; }
                    1450   ; /*********************************************************************************************************
                    1451   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    1452   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    1453   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    1454   ; **
                    1455   ; **  NOTE you do not call this function directly, instead you call the normal getchar() function
                    1456   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call getchar() so will
                    1457   ; **  call _getch() also
                    1458   ; *********************************************************************************************************/
                    1459   ; int _getch( void )
                    1460   ; {
                    1461   __getch:
08000972  4E56 FFFC 1462          link      A6,#-4
                    1463   ; char c ;
                    1464   ; while((RS232_Status & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    1465   _getch_1:
08000976  1039 0040 1466          move.b    4194368,D0
0800097A  0040      
0800097C  C03C 0001 1467          and.b     #1,D0
08000980  0C00 0001 1468          cmp.b     #1,D0
08000984  6702      1469          beq.s     _getch_3
08000986  60EE      1470          bra       _getch_1
                    1471   _getch_3:
                    1472   ; ;
                    1473   ; return (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
08000988  1039 0040 1474          move.b    4194370,D0
0800098C  0042      
0800098E  C0BC 0000 1475          and.l     #255,D0
08000992  00FF      
08000994  C0BC 0000 1476          and.l     #127,D0
08000998  007F      
0800099A  4E5E      1477          unlk      A6
0800099C  4E75      1478          rts
                    1479   ; }
                    1480   ; /******************************************************************************
                    1481   ; **  Subroutine to output a single character to the 2 row LCD display
                    1482   ; **  It is assumed the character is an ASCII code and it will be displayed at the
                    1483   ; **  current cursor position
                    1484   ; *******************************************************************************/
                    1485   ; void LCDOutchar(int c)
                    1486   ; {
                    1487   _LCDOutchar:
0800099E  4E56 0000 1488          link      A6,#0
                    1489   ; LCDdata = (char)(c);
080009A2  202E 0008 1490          move.l    8(A6),D0
080009A6  13C0 0040 1491          move.b    D0,4194338
080009AA  0022      
                    1492   ; Wait1ms() ;
080009AC  4EB9 0800 1493          jsr       _Wait1ms
080009B0  08E6      
080009B2  4E5E      1494          unlk      A6
080009B4  4E75      1495          rts
                    1496   ; }
                    1497   ; /**********************************************************************************
                    1498   ; *subroutine to output a message at the current cursor position of the LCD display
                    1499   ; ************************************************************************************/
                    1500   ; void LCDOutMessage(char *theMessage)
                    1501   ; {
                    1502   _LCDOutMessage:
080009B6  4E56 FFFC 1503          link      A6,#-4
                    1504   ; char c ;
                    1505   ; while((c = *theMessage++) != 0)     // output characters from the string until NULL
                    1506   LCDOutMessage_1:
080009BA  206E 0008 1507          move.l    8(A6),A0
080009BE  52AE 0008 1508          addq.l    #1,8(A6)
080009C2  1D50 FFFF 1509          move.b    (A0),-1(A6)
080009C6  1010      1510          move.b    (A0),D0
080009C8  6714      1511          beq.s     LCDOutMessage_3
                    1512   ; LCDOutchar(c) ;
080009CA  122E FFFF 1513          move.b    -1(A6),D1
080009CE  4881      1514          ext.w     D1
080009D0  48C1      1515          ext.l     D1
080009D2  2F01      1516          move.l    D1,-(A7)
080009D4  4EB9 0800 1517          jsr       _LCDOutchar
080009D8  099E      
080009DA  584F      1518          addq.w    #4,A7
080009DC  60DC      1519          bra       LCDOutMessage_1
                    1520   LCDOutMessage_3:
080009DE  4E5E      1521          unlk      A6
080009E0  4E75      1522          rts
                    1523   ; }
                    1524   ; /******************************************************************************
                    1525   ; *subroutine to clear the line by issuing 24 space characters
                    1526   ; *******************************************************************************/
                    1527   ; void LCDClearln(void)
                    1528   ; {
                    1529   _LCDClearln:
080009E2  2F02      1530          move.l    D2,-(A7)
                    1531   ; int i ;
                    1532   ; for(i = 0; i < 24; i ++)
080009E4  4282      1533          clr.l     D2
                    1534   LCDClearln_1:
080009E6  0C82 0000 1535          cmp.l     #24,D2
080009EA  0018      
080009EC  6C10      1536          bge.s     LCDClearln_3
                    1537   ; LCDOutchar(' ') ;       // write a space char to the LCD display
080009EE  4878 0020 1538          pea       32
080009F2  4EB9 0800 1539          jsr       _LCDOutchar
080009F6  099E      
080009F8  584F      1540          addq.w    #4,A7
080009FA  5282      1541          addq.l    #1,D2
080009FC  60E8      1542          bra       LCDClearln_1
                    1543   LCDClearln_3:
080009FE  241F      1544          move.l    (A7)+,D2
08000A00  4E75      1545          rts
                    1546   ; }
                    1547   ; /******************************************************************************
                    1548   ; **  Subroutine to move the LCD cursor to the start of line 1 and clear that line
                    1549   ; *******************************************************************************/
                    1550   ; void LCDLine1Message(char *theMessage)
                    1551   ; {
                    1552   _LCDLine1Message:
08000A02  4E56 0000 1553          link      A6,#0
                    1554   ; LCDcommand = 0x80 ;
08000A06  13FC 0080 1555          move.b    #128,4194336
08000A0A  0040 0020 
                    1556   ; Wait3ms();
08000A0E  4EB9 0800 1557          jsr       _Wait3ms
08000A12  08FA      
                    1558   ; LCDClearln() ;
08000A14  4EB9 0800 1559          jsr       _LCDClearln
08000A18  09E2      
                    1560   ; LCDcommand = 0x80 ;
08000A1A  13FC 0080 1561          move.b    #128,4194336
08000A1E  0040 0020 
                    1562   ; Wait3ms() ;
08000A22  4EB9 0800 1563          jsr       _Wait3ms
08000A26  08FA      
                    1564   ; LCDOutMessage(theMessage) ;
08000A28  2F2E 0008 1565          move.l    8(A6),-(A7)
08000A2C  4EB9 0800 1566          jsr       _LCDOutMessage
08000A30  09B6      
08000A32  584F      1567          addq.w    #4,A7
08000A34  4E5E      1568          unlk      A6
08000A36  4E75      1569          rts
                    1570   ; }
                    1571   ; /******************************************************************************
                    1572   ; **  Subroutine to move the LCD cursor to the start of line 2 and clear that line
                    1573   ; *******************************************************************************/
                    1574   ; void LCDLine2Message(char *theMessage)
                    1575   ; {
                    1576   _LCDLine2Message:
08000A38  4E56 0000 1577          link      A6,#0
                    1578   ; LCDcommand = 0xC0 ;
08000A3C  13FC 00C0 1579          move.b    #192,4194336
08000A40  0040 0020 
                    1580   ; Wait3ms();
08000A44  4EB9 0800 1581          jsr       _Wait3ms
08000A48  08FA      
                    1582   ; LCDClearln() ;
08000A4A  4EB9 0800 1583          jsr       _LCDClearln
08000A4E  09E2      
                    1584   ; LCDcommand = 0xC0 ;
08000A50  13FC 00C0 1585          move.b    #192,4194336
08000A54  0040 0020 
                    1586   ; Wait3ms() ;
08000A58  4EB9 0800 1587          jsr       _Wait3ms
08000A5C  08FA      
                    1588   ; LCDOutMessage(theMessage) ;
08000A5E  2F2E 0008 1589          move.l    8(A6),-(A7)
08000A62  4EB9 0800 1590          jsr       _LCDOutMessage
08000A66  09B6      
08000A68  584F      1591          addq.w    #4,A7
08000A6A  4E5E      1592          unlk      A6
08000A6C  4E75      1593          rts
                    1594   ; }
                    1595   ; /*********************************************************************************************************************************
                    1596   ; **  IMPORTANT FUNCTION
                    1597   ; **  This function install an exception handler so you can capture and deal with any 68000 exception in your program
                    1598   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    1599   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    1600   ; **  Calling this function allows you to deal with Interrupts for example
                    1601   ; ***********************************************************************************************************************************/
                    1602   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    1603   ; {
                    1604   _InstallExceptionHandler:
08000A6E  4E56 FFFC 1605          link      A6,#-4
                    1606   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
08000A72  2D7C 0B00 1607          move.l    #184549376,-4(A6)
08000A76  0000 FFFC 
                    1608   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
08000A7A  206E FFFC 1609          move.l    -4(A6),A0
08000A7E  202E 000C 1610          move.l    12(A6),D0
08000A82  E588      1611          lsl.l     #2,D0
08000A84  21AE 0008 1612          move.l    8(A6),0(A0,D0.L)
08000A88  0800      
08000A8A  4E5E      1613          unlk      A6
08000A8C  4E75      1614          rts
                    1615   ; }
                    1616   ; /******************************************************************************************
                    1617   ; ** The following code is for the SPI controller
                    1618   ; *******************************************************************************************/
                    1619   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1620   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1621   ; int TestForSPITransmitDataComplete(void)    {
                    1622   _TestForSPITransmitDataComplete:
                    1623   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    1624   ; return (SPI_Status>>7);
08000A8E  1039 0040 1625          move.b    4227106,D0
08000A92  8022      
08000A94  C0BC 0000 1626          and.l     #255,D0
08000A98  00FF      
08000A9A  EE88      1627          lsr.l     #7,D0
08000A9C  4E75      1628          rts
                    1629   ; }
                    1630   ; /************************************************************************************
                    1631   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1632   ; ************************************************************************************/
                    1633   ; void SPI_Init(void)
                    1634   ; {
                    1635   _SPI_Init:
                    1636   ; //TODO
                    1637   ; //
                    1638   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1639   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1640   ; //
                    1641   ; // Here are some settings we want to create
                    1642   ; //
                    1643   ; // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
                    1644   ; // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1645   ; // SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
                    1646   ; // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1647   ; // ControlRegister_t tempControl; 
                    1648   ; // memset(&SPI_Control, 0, sizeof(unsigned char)); 
                    1649   ; // memset(&tempControl, 0, sizeof(ControlRegister_t));
                    1650   ; // tempControl.SPIE = 0; 
                    1651   ; // tempControl.SPE = 1; 
                    1652   ; // tempControl.MSTR = 1; 
                    1653   ; // tempControl.CPOL = 0;
                    1654   ; // tempControl.CPHA = 0; 
                    1655   ; // tempControl.SPR = 3; 
                    1656   ; // SPI_Control = (volatile unsigned char)tempControl; 
                    1657   ; // SPI_Control = (unsigned char)0b01010011; 
                    1658   ; SPI_Control = (unsigned char)0x53;
08000A9E  13FC 0053 1659          move.b    #83,4227104
08000AA2  0040 8020 
                    1660   ; SPI_Ext = (unsigned char)0x00; 
08000AA6  4239 0040 1661          clr.b     4227110
08000AAA  8026      
                    1662   ; Disable_SPI_CS(); 
08000AAC  13FC 00FF 1663          move.b    #255,4227112
08000AB0  0040 8028 
08000AB4  4E75      1664          rts
                    1665   ; }
                    1666   ; /************************************************************************************
                    1667   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1668   ; ************************************************************************************/
                    1669   ; void WaitForSPITransmitComplete(void)
                    1670   ; {
                    1671   _WaitForSPITransmitComplete:
                    1672   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1673   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1674   ; // just in case they were set
                    1675   ; // while ((SPI_Status>>7)==0);
                    1676   ; while (1) {
                    1677   WaitForSPITransmitComplete_1:
                    1678   ; if (SPI_Status & (unsigned char)0x80) {
08000AB6  1039 0040 1679          move.b    4227106,D0
08000ABA  8022      
08000ABC  C03C 0080 1680          and.b     #128,D0
08000AC0  6702      1681          beq.s     WaitForSPITransmitComplete_4
                    1682   ; break;
08000AC2  6002      1683          bra.s     WaitForSPITransmitComplete_3
                    1684   WaitForSPITransmitComplete_4:
08000AC4  60F0      1685          bra       WaitForSPITransmitComplete_1
                    1686   WaitForSPITransmitComplete_3:
                    1687   ; }
                    1688   ; }
                    1689   ; // SPI_Status &= 0x3F; // And with 00111111 to clear top two bits
                    1690   ; SPI_Status = (unsigned char)0xC0;  
08000AC6  13FC 00C0 1691          move.b    #192,4227106
08000ACA  0040 8022 
08000ACE  4E75      1692          rts
                    1693   ; }
                    1694   ; /************************************************************************************
                    1695   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1696   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1697   ; ************************************************************************************/
                    1698   ; int WriteSPIChar(int c)
                    1699   ; {
                    1700   _WriteSPIChar:
08000AD0  4E56 FFFC 1701          link      A6,#-4
                    1702   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    1703   ; // wait for completion of transmission
                    1704   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    1705   ; // by reading fom the SPI controller Data Register.
                    1706   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    1707   ; //
                    1708   ; // modify '0' below to return back read byte from data register
                    1709   ; //
                    1710   ; unsigned char temp;
                    1711   ; // Load data register
                    1712   ; SPI_Data = (unsigned char)c; 
08000AD4  202E 0008 1713          move.l    8(A6),D0
08000AD8  13C0 0040 1714          move.b    D0,4227108
08000ADC  8024      
                    1715   ; // Poll for completion 
                    1716   ; WaitForSPITransmitComplete(); 
08000ADE  4EB9 0800 1717          jsr       _WaitForSPITransmitComplete
08000AE2  0AB6      
                    1718   ; temp = SPI_Data;
08000AE4  1D79 0040 1719          move.b    4227108,-1(A6)
08000AE8  8024 FFFF 
                    1720   ; // printf("\r\nRead: %x", temp);
                    1721   ; // Read data register
                    1722   ; return (int)temp;  
08000AEC  102E FFFF 1723          move.b    -1(A6),D0
08000AF0  C0BC 0000 1724          and.l     #255,D0
08000AF4  00FF      
08000AF6  4E5E      1725          unlk      A6
08000AF8  4E75      1726          rts
                    1727   ; }
                    1728   ; void ChipErase() {
                    1729   _ChipErase:
08000AFA  2F0A      1730          move.l    A2,-(A7)
08000AFC  45F9 0800 1731          lea       _WriteSPIChar.L,A2
08000B00  0AD0      
                    1732   ; // wren
                    1733   ; Enable_SPI_CS();
08000B02  13FC 00FE 1734          move.b    #254,4227112
08000B06  0040 8028 
                    1735   ; WriteSPIChar(0x06);
08000B0A  4878 0006 1736          pea       6
08000B0E  4E92      1737          jsr       (A2)
08000B10  584F      1738          addq.w    #4,A7
                    1739   ; Disable_SPI_CS(); 
08000B12  13FC 00FF 1740          move.b    #255,4227112
08000B16  0040 8028 
                    1741   ; //chip erase
                    1742   ; Enable_SPI_CS();
08000B1A  13FC 00FE 1743          move.b    #254,4227112
08000B1E  0040 8028 
                    1744   ; WriteSPIChar(0x60);
08000B22  4878 0060 1745          pea       96
08000B26  4E92      1746          jsr       (A2)
08000B28  584F      1747          addq.w    #4,A7
                    1748   ; Disable_SPI_CS(); 
08000B2A  13FC 00FF 1749          move.b    #255,4227112
08000B2E  0040 8028 
                    1750   ; //wait for WIP
                    1751   ; Enable_SPI_CS();
08000B32  13FC 00FE 1752          move.b    #254,4227112
08000B36  0040 8028 
                    1753   ; WriteSPIChar(0x05);
08000B3A  4878 0005 1754          pea       5
08000B3E  4E92      1755          jsr       (A2)
08000B40  584F      1756          addq.w    #4,A7
                    1757   ; while((WriteSPIChar(0x55)&0x01) == 1);
                    1758   ChipErase_1:
08000B42  4878 0055 1759          pea       85
08000B46  4E92      1760          jsr       (A2)
08000B48  584F      1761          addq.w    #4,A7
08000B4A  C0BC 0000 1762          and.l     #1,D0
08000B4E  0001      
08000B50  0C80 0000 1763          cmp.l     #1,D0
08000B54  0001      
08000B56  6602      1764          bne.s     ChipErase_3
08000B58  60E8      1765          bra       ChipErase_1
                    1766   ChipErase_3:
                    1767   ; Disable_SPI_CS();
08000B5A  13FC 00FF 1768          move.b    #255,4227112
08000B5E  0040 8028 
08000B62  245F      1769          move.l    (A7)+,A2
08000B64  4E75      1770          rts
                    1771   ; }
                    1772   ; void WriteData(int startAddress, unsigned char *dataArray, int numBytes) {
                    1773   _WriteData:
08000B66  4E56 0000 1774          link      A6,#0
08000B6A  48E7 3020 1775          movem.l   D2/D3/A2,-(A7)
08000B6E  45F9 0800 1776          lea       _WriteSPIChar.L,A2
08000B72  0AD0      
08000B74  262E 0008 1777          move.l    8(A6),D3
                    1778   ; int i = 0;
08000B78  4282      1779          clr.l     D2
                    1780   ; // wren command
                    1781   ; Enable_SPI_CS();
08000B7A  13FC 00FE 1782          move.b    #254,4227112
08000B7E  0040 8028 
                    1783   ; WriteSPIChar(0x06);
08000B82  4878 0006 1784          pea       6
08000B86  4E92      1785          jsr       (A2)
08000B88  584F      1786          addq.w    #4,A7
                    1787   ; Disable_SPI_CS(); 
08000B8A  13FC 00FF 1788          move.b    #255,4227112
08000B8E  0040 8028 
                    1789   ; // write command
                    1790   ; Enable_SPI_CS();
08000B92  13FC 00FE 1791          move.b    #254,4227112
08000B96  0040 8028 
                    1792   ; WriteSPIChar(0x02); //page program command
08000B9A  4878 0002 1793          pea       2
08000B9E  4E92      1794          jsr       (A2)
08000BA0  584F      1795          addq.w    #4,A7
                    1796   ; WriteSPIChar(startAddress>>16); //addres high
08000BA2  2203      1797          move.l    D3,D1
08000BA4  E081      1798          asr.l     #8,D1
08000BA6  E081      1799          asr.l     #8,D1
08000BA8  2F01      1800          move.l    D1,-(A7)
08000BAA  4E92      1801          jsr       (A2)
08000BAC  584F      1802          addq.w    #4,A7
                    1803   ; WriteSPIChar(startAddress>>8); // address middle
08000BAE  2203      1804          move.l    D3,D1
08000BB0  E081      1805          asr.l     #8,D1
08000BB2  2F01      1806          move.l    D1,-(A7)
08000BB4  4E92      1807          jsr       (A2)
08000BB6  584F      1808          addq.w    #4,A7
                    1809   ; WriteSPIChar(startAddress); //address low
08000BB8  2F03      1810          move.l    D3,-(A7)
08000BBA  4E92      1811          jsr       (A2)
08000BBC  584F      1812          addq.w    #4,A7
                    1813   ; //stream data
                    1814   ; for (i; i < numBytes; i++) {
                    1815   WriteData_1:
08000BBE  B4AE 0010 1816          cmp.l     16(A6),D2
08000BC2  6C18      1817          bge.s     WriteData_3
                    1818   ; WriteSPIChar((int)dataArray[i]);
08000BC4  206E 000C 1819          move.l    12(A6),A0
08000BC8  1230 2800 1820          move.b    0(A0,D2.L),D1
08000BCC  C2BC 0000 1821          and.l     #255,D1
08000BD0  00FF      
08000BD2  2F01      1822          move.l    D1,-(A7)
08000BD4  4E92      1823          jsr       (A2)
08000BD6  584F      1824          addq.w    #4,A7
08000BD8  5282      1825          addq.l    #1,D2
08000BDA  60E2      1826          bra       WriteData_1
                    1827   WriteData_3:
                    1828   ; }
                    1829   ; Disable_SPI_CS();
08000BDC  13FC 00FF 1830          move.b    #255,4227112
08000BE0  0040 8028 
                    1831   ; //wait for internal writing    
                    1832   ; Enable_SPI_CS();
08000BE4  13FC 00FE 1833          move.b    #254,4227112
08000BE8  0040 8028 
                    1834   ; WriteSPIChar(0x05);
08000BEC  4878 0005 1835          pea       5
08000BF0  4E92      1836          jsr       (A2)
08000BF2  584F      1837          addq.w    #4,A7
                    1838   ; while((WriteSPIChar(0x55)&0x01) == 1);
                    1839   WriteData_4:
08000BF4  4878 0055 1840          pea       85
08000BF8  4E92      1841          jsr       (A2)
08000BFA  584F      1842          addq.w    #4,A7
08000BFC  C0BC 0000 1843          and.l     #1,D0
08000C00  0001      
08000C02  0C80 0000 1844          cmp.l     #1,D0
08000C06  0001      
08000C08  6602      1845          bne.s     WriteData_6
08000C0A  60E8      1846          bra       WriteData_4
                    1847   WriteData_6:
                    1848   ; Disable_SPI_CS();
08000C0C  13FC 00FF 1849          move.b    #255,4227112
08000C10  0040 8028 
08000C14  4CDF 040C 1850          movem.l   (A7)+,D2/D3/A2
08000C18  4E5E      1851          unlk      A6
08000C1A  4E75      1852          rts
                    1853   ; }
                    1854   ; void ReadData(int startAddress, int numBytes, unsigned char *data) {
                    1855   _ReadData:
08000C1C  4E56 0000 1856          link      A6,#0
08000C20  48E7 3020 1857          movem.l   D2/D3/A2,-(A7)
08000C24  45F9 0800 1858          lea       _WriteSPIChar.L,A2
08000C28  0AD0      
08000C2A  262E 0008 1859          move.l    8(A6),D3
                    1860   ; int i = 0;
08000C2E  4282      1861          clr.l     D2
                    1862   ; Enable_SPI_CS();
08000C30  13FC 00FE 1863          move.b    #254,4227112
08000C34  0040 8028 
                    1864   ; WriteSPIChar(0x03); //read command
08000C38  4878 0003 1865          pea       3
08000C3C  4E92      1866          jsr       (A2)
08000C3E  584F      1867          addq.w    #4,A7
                    1868   ; WriteSPIChar(startAddress>>16); //addres high
08000C40  2203      1869          move.l    D3,D1
08000C42  E081      1870          asr.l     #8,D1
08000C44  E081      1871          asr.l     #8,D1
08000C46  2F01      1872          move.l    D1,-(A7)
08000C48  4E92      1873          jsr       (A2)
08000C4A  584F      1874          addq.w    #4,A7
                    1875   ; WriteSPIChar(startAddress>>8); // address middle
08000C4C  2203      1876          move.l    D3,D1
08000C4E  E081      1877          asr.l     #8,D1
08000C50  2F01      1878          move.l    D1,-(A7)
08000C52  4E92      1879          jsr       (A2)
08000C54  584F      1880          addq.w    #4,A7
                    1881   ; WriteSPIChar(startAddress); //address low
08000C56  2F03      1882          move.l    D3,-(A7)
08000C58  4E92      1883          jsr       (A2)
08000C5A  584F      1884          addq.w    #4,A7
                    1885   ; //stream data
                    1886   ; for (i; i < numBytes; i++) {
                    1887   ReadData_1:
08000C5C  B4AE 000C 1888          cmp.l     12(A6),D2
08000C60  6C14      1889          bge.s     ReadData_3
                    1890   ; data[i] = (unsigned char)WriteSPIChar(0x55); //dummy byte
08000C62  4878 0055 1891          pea       85
08000C66  4E92      1892          jsr       (A2)
08000C68  584F      1893          addq.w    #4,A7
08000C6A  206E 0010 1894          move.l    16(A6),A0
08000C6E  1180 2800 1895          move.b    D0,0(A0,D2.L)
08000C72  5282      1896          addq.l    #1,D2
08000C74  60E6      1897          bra       ReadData_1
                    1898   ReadData_3:
                    1899   ; }
                    1900   ; Disable_SPI_CS();
08000C76  13FC 00FF 1901          move.b    #255,4227112
08000C7A  0040 8028 
08000C7E  4CDF 040C 1902          movem.l   (A7)+,D2/D3/A2
08000C82  4E5E      1903          unlk      A6
08000C84  4E75      1904          rts
                    1905   ; }
                    1906   ; void startTimer(void) {
                    1907   _startTimer:
                    1908   ; counter = 0;
08000C86  42B9 0800 1909          clr.l     _counter.L
08000C8A  1A6A      
                    1910   ; rollovers = 0;
08000C8C  42B9 0800 1911          clr.l     _rollovers.L
08000C90  1A6E      
08000C92  4E75      1912          rts
                    1913   ; }
                    1914   ; unsigned long int endTimer(void) {
                    1915   _endTimer:
                    1916   ; return counter + (rollovers * sizeof(counter) * 256);
08000C94  2039 0800 1917          move.l    _counter.L,D0
08000C98  1A6A      
08000C9A  2F39 0800 1918          move.l    _rollovers.L,-(A7)
08000C9E  1A6E      
08000CA0  4878 0004 1919          pea       4
08000CA4  4EB9 0800 1920          jsr       ULMUL
08000CA8  0EBA      
08000CAA  2217      1921          move.l    (A7),D1
08000CAC  504F      1922          addq.w    #8,A7
08000CAE  2F01      1923          move.l    D1,-(A7)
08000CB0  4878 0100 1924          pea       256
08000CB4  4EB9 0800 1925          jsr       ULMUL
08000CB8  0EBA      
08000CBA  2217      1926          move.l    (A7),D1
08000CBC  504F      1927          addq.w    #8,A7
08000CBE  D081      1928          add.l     D1,D0
08000CC0  4E75      1929          rts
                    1930   ; }
                    1931   ; /******************************************************************************************************************************
                    1932   ; * Start of user program
                    1933   ; ******************************************************************************************************************************/
                    1934   ; void main()
                    1935   ; {
                    1936   _main:
08000CC2  4E56 FBF0 1937          link      A6,#-1040
08000CC6  2F02      1938          move.l    D2,-(A7)
                    1939   ; unsigned char iicArray[512]; 
                    1940   ; unsigned char readBuffer[512]; 
                    1941   ; unsigned char temp;
                    1942   ; unsigned int address; 
                    1943   ; unsigned int startingAddress = 0x40; 
08000CC8  2D7C 0000 1944          move.l    #64,-8(A6)
08000CCC  0040 FFF8 
                    1945   ; int i; 
                    1946   ; int length = 500; 
08000CD0  2D7C 0000 1947          move.l    #500,-4(A6)
08000CD4  01F4 FFFC 
                    1948   ; // Populate test array 
                    1949   ; for (i=0; i<length; i++)
08000CD8  4282      1950          clr.l     D2
                    1951   main_1:
08000CDA  B4AE FFFC 1952          cmp.l     -4(A6),D2
08000CDE  6C0E      1953          bge.s     main_3
                    1954   ; {
                    1955   ; iicArray[i] = 0xFF; 
08000CE0  41EE FBF2 1956          lea       -1038(A6),A0
08000CE4  11BC 00FF 1957          move.b    #255,0(A0,D2.L)
08000CE8  2800      
08000CEA  5282      1958          addq.l    #1,D2
08000CEC  60EC      1959          bra       main_1
                    1960   main_3:
                    1961   ; }
                    1962   ; printf("\r\nInitializing IIC Controller");
08000CEE  4879 0800 1963          pea       @m68kus~1_1.L
08000CF2  1898      
08000CF4  4EB9 0800 1964          jsr       _printf
08000CF8  0E8A      
08000CFA  584F      1965          addq.w    #4,A7
                    1966   ; Init_IIC();
08000CFC  4EB9 0800 1967          jsr       _Init_IIC
08000D00  0084      
                    1968   ; printf("\r\nDone initialization, sending a byte...");
08000D02  4879 0800 1969          pea       @m68kus~1_2.L
08000D06  18B6      
08000D08  4EB9 0800 1970          jsr       _printf
08000D0C  0E8A      
08000D0E  584F      1971          addq.w    #4,A7
                    1972   ; // WriteByte(0xA6, 0x42, (unsigned int)0x55);
                    1973   ; // printf("\r\nDone writing!");
                    1974   ; // temp = ReadByte(0xA6, (unsigned int)0x55);
                    1975   ; // printf("\r\nRead back %x!", temp);
                    1976   ; // Write_128_Bytes(0xA6, 0x00, iicArray); 
                    1977   ; // temp = ReadByte(0xA6, 0x00);
                    1978   ; // printf("\r\nRead back %x!", temp);
                    1979   ; // temp = ReadByte(0xA6, 0x05);
                    1980   ; // printf("\r\nRead back %x!", temp);
                    1981   ; // temp = ReadByte(0xA6, 0x7F);
                    1982   ; // printf("\r\nRead back %x!", temp);
                    1983   ; // Read_128_Bytes(0xA6, 0x00, readBuffer); 
                    1984   ; // for (i=0; i<128; i++)
                    1985   ; // {
                    1986   ; //     printf("\r\nRead back %x!", readBuffer[i]);
                    1987   ; // }
                    1988   ; /**********************************************
                    1989   ; * Testing Read/Write Bytes functions
                    1990   ; **********************************************/
                    1991   ; // WriteBytes(0xA6, startingAddress, iicArray, length); 
                    1992   ; // ReadBytes(0xA6, startingAddress, readBuffer, length); 
                    1993   ; // for (i=0; i<length; i++)
                    1994   ; // {
                    1995   ; //     printf("\r\nRead back %x from %x!", readBuffer[i], startingAddress+i);
                    1996   ; // }
                    1997   ; // temp = ReadByte(0xA6, 0x40);
                    1998   ; // printf("\r\nRead back %x!", temp);
                    1999   ; // temp = ReadByte(0xA6, 0x7f);
                    2000   ; // printf("\r\nRead back %x!", temp);
                    2001   ; // temp = ReadByte(0xA6, 0x80);
                    2002   ; // printf("\r\nRead back %x!", temp);
                    2003   ; // temp = ReadByte(0xA6, 0x81);
                    2004   ; // printf("\r\nRead back %x!", temp);
                    2005   ; // for (address = startingAddress; address < startingAddress+length; address++)
                    2006   ; // {
                    2007   ; //     temp = ReadByte(0xA6, address);
                    2008   ; //     printf("\r\nRead back %x from %x!", temp, address);
                    2009   ; // }
                    2010   ; DigitalToAnalog(ADC_SLAVE_ADDRESS, iicArray, sizeof(iicArray)); 
08000D10  4878 0200 2011          pea       512
08000D14  486E FBF2 2012          pea       -1038(A6)
08000D18  4878 009E 2013          pea       158
08000D1C  4EB9 0800 2014          jsr       _DigitalToAnalog
08000D20  0D28      
08000D22  DEFC 000C 2015          add.w     #12,A7
                    2016   ; while(1);
                    2017   main_4:
08000D26  60FE      2018          bra       main_4
                    2019   ; }
                    2020   ; C:\M68KV6.0 - 640BY480\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS\PROGRAMS\LAB5\ADC_DAC.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    2021   ; #include <stdio.h> 
                    2022   ; #include "IIC_Driver.h"
                    2023   ; #include "ADC_DAC.h"
                    2024   ; // Globals
                    2025   ; volatile unsigned char *IICTx_ = (unsigned char *)IIC_TRANSMIT;
                    2026   ; volatile unsigned char *IICRx_ = (unsigned char *)IIC_RECEIVE;
                    2027   ; volatile unsigned char *IICCommand_ = (unsigned char *)IIC_COMMAND;
                    2028   ; /* Functions */ 
                    2029   ; void DigitalToAnalog(unsigned char slaveAddress, unsigned char *data, unsigned int size) {
                    2030   _DigitalToAnalog:
08000D28  4E56 0000 2031          link      A6,#0
08000D2C  48E7 203C 2032          movem.l   D2/A2/A3/A4/A5,-(A7)
08000D30  45F9 0800 2033          lea       _WaitForAck.L,A2
08000D34  0052      
08000D36  47F9 0800 2034          lea       _WaitForEndOfTransfer.L,A3
08000D3A  003E      
08000D3C  49F9 0800 2035          lea       _IICCommand_.L,A4
08000D40  1A4E      
08000D42  4BF9 0800 2036          lea       _IICTx_.L,A5
08000D46  1A46      
                    2037   ; int i; 
                    2038   ; // Generate IIC start signal
                    2039   ; *IICTx_ = slaveAddress | WRITE;	// fill the tx shift register
08000D48  102E 000B 2040          move.b    11(A6),D0
08000D4C  803C 0000 2041          or.b      #0,D0
08000D50  2055      2042          move.l    (A5),A0
08000D52  1080      2043          move.b    D0,(A0)
                    2044   ; *IICCommand_ = STA | WR;	// set write bit
08000D54  2054      2045          move.l    (A4),A0
08000D56  10BC 0090 2046          move.b    #144,(A0)
                    2047   ; WaitForEndOfTransfer();
08000D5A  4E93      2048          jsr       (A3)
                    2049   ; WaitForAck(); 
08000D5C  4E92      2050          jsr       (A2)
                    2051   ; printf("\r\n Generated Start Signal"); 
08000D5E  4879 0800 2052          pea       @adc_dac_1.L
08000D62  18E0      
08000D64  4EB9 0800 2053          jsr       _printf
08000D68  0E8A      
08000D6A  584F      2054          addq.w    #4,A7
                    2055   ; // Send Control Byte 
                    2056   ; *IICTx_ = ANALOG_OUTPUT_ENABLE | SINGLE_ENDED | AD_CH_0; 
08000D6C  2055      2057          move.l    (A5),A0
08000D6E  10BC 0040 2058          move.b    #64,(A0)
                    2059   ; *IICCommand_ = WR;	// set write bit
08000D72  2054      2060          move.l    (A4),A0
08000D74  10BC 0010 2061          move.b    #16,(A0)
                    2062   ; WaitForEndOfTransfer();
08000D78  4E93      2063          jsr       (A3)
                    2064   ; WaitForAck();
08000D7A  4E92      2065          jsr       (A2)
                    2066   ; printf("\r\n Sent Control Byte"); 
08000D7C  4879 0800 2067          pea       @adc_dac_2.L
08000D80  18FA      
08000D82  4EB9 0800 2068          jsr       _printf
08000D86  0E8A      
08000D88  584F      2069          addq.w    #4,A7
                    2070   ; // Steam Data Byte 
                    2071   ; while (1)
                    2072   DigitalToAnalog_1:
                    2073   ; {
                    2074   ; for (i = 0; i < size; i++)
08000D8A  4282      2075          clr.l     D2
                    2076   DigitalToAnalog_4:
08000D8C  B4AE 0010 2077          cmp.l     16(A6),D2
08000D90  6418      2078          bhs.s     DigitalToAnalog_6
                    2079   ; {
                    2080   ; *IICTx_ = data[i]; 
08000D92  206E 000C 2081          move.l    12(A6),A0
08000D96  2255      2082          move.l    (A5),A1
08000D98  12B0 2800 2083          move.b    0(A0,D2.L),(A1)
                    2084   ; *IICCommand_ = WR; 
08000D9C  2054      2085          move.l    (A4),A0
08000D9E  10BC 0010 2086          move.b    #16,(A0)
                    2087   ; WaitForEndOfTransfer();
08000DA2  4E93      2088          jsr       (A3)
                    2089   ; WaitForAck();
08000DA4  4E92      2090          jsr       (A2)
08000DA6  5282      2091          addq.l    #1,D2
08000DA8  60E2      2092          bra       DigitalToAnalog_4
                    2093   DigitalToAnalog_6:
08000DAA  60DE      2094          bra       DigitalToAnalog_1
                    2095   ; }
                    2096   ; }
                    2097   ; }
                    2098   ULDIV:
08000DAC  4E56 0000 2099          link    A6,#0
08000DB0  48E7 C000 2100          movem.l D0/D1,-(A7)
08000DB4  222E 0008 2101          move.l  8(A6),D1
08000DB8  202E 000C 2102          move.l  12(A6),D0
08000DBC  6036      2103          bra.s   ldiv_3
                    2104   LDIV:
08000DBE  4E56 0000 2105          link    A6,#0
08000DC2  48E7 C000 2106          movem.l D0/D1,-(A7)
08000DC6  222E 0008 2107          move.l  8(A6),D1
08000DCA  202E 000C 2108          move.l  12(A6),D0
08000DCE  4A80      2109          tst.l   D0
08000DD0  6A0E      2110          bpl.s   ldiv_1
08000DD2  4480      2111          neg.l   D0
08000DD4  4A81      2112          tst.l   D1
08000DD6  6A14      2113          bpl.s   ldiv_2
08000DD8  4481      2114          neg.l   D1
08000DDA  612A      2115          bsr.s   dodiv
08000DDC  4481      2116          neg.l   D1
08000DDE  6016      2117          bra.s   ldiv_4
                    2118   ldiv_1:
08000DE0  4A81      2119          tst.l   D1
08000DE2  6A10      2120          bpl.s   ldiv_3
08000DE4  4481      2121          neg.l   D1
08000DE6  611E      2122          bsr.s   dodiv
08000DE8  4480      2123          neg.l   D0
08000DEA  600A      2124          bra.s   ldiv_4
                    2125   ldiv_2:
08000DEC  6118      2126          bsr.s   dodiv
08000DEE  4480      2127          neg.l   D0
08000DF0  4481      2128          neg.l   D1
08000DF2  6002      2129          bra.s   ldiv_4
                    2130   ldiv_3:
08000DF4  6110      2131          bsr.s   dodiv
                    2132   ldiv_4:
08000DF6  2D40 0008 2133          move.l  D0,8(A6)
08000DFA  2D41 000C 2134          move.l  D1,12(A6)
08000DFE  4CDF 0003 2135          movem.l (A7)+,D0/D1
08000E02  4E5E      2136          unlk    A6
08000E04  4E75      2137          rts
                    2138   dodiv:
08000E06  0C81 0000 2139          cmpi.l  #$FFFF,D1
08000E0A  FFFF      
08000E0C  6236      2140          bhi.s   dodiv_2
08000E0E  0C80 0000 2141          cmpi.l  #$FFFF,D0
08000E12  FFFF      
08000E14  6210      2142          bhi.s   dodiv_1
08000E16  80C1      2143          divu    D1,D0
08000E18  2200      2144          move.l  D0,D1
08000E1A  4241      2145          clr.w   D1
08000E1C  4841      2146          swap    D1
08000E1E  0280 0000 2147          andi.l  #$FFFF,D0
08000E22  FFFF      
08000E24  4E75      2148          rts
                    2149   dodiv_1:
08000E26  48A7 A000 2150          movem.w D0/D2,-(A7)
08000E2A  4240      2151          clr.w   D0
08000E2C  4840      2152          swap    D0
08000E2E  80C1      2153          divu    D1,D0
08000E30  3400      2154          move.w  D0,D2
08000E32  301F      2155          move.w  (A7)+,D0
08000E34  80C1      2156          divu    D1,D0
08000E36  4840      2157          swap    D0
08000E38  4281      2158          clr.l   D1
08000E3A  3200      2159          move.w  D0,D1
08000E3C  3002      2160          move.w  D2,D0
08000E3E  4840      2161          swap    D0
08000E40  341F      2162          move.w  (A7)+,D2
08000E42  4E75      2163          rts
                    2164   dodiv_2:
08000E44  48E7 3800 2165          movem.l D2/D3/D4,-(A7)
08000E48  2401      2166          move.l  D1,D2
08000E4A  4242      2167          clr.w   D2
08000E4C  4842      2168          swap    D2
08000E4E  5282      2169          addq.l  #1,D2
08000E50  2600      2170          move.l  D0,D3
08000E52  2801      2171          move.l  D1,D4
08000E54  2202      2172          move.l  D2,D1
08000E56  61CE      2173          bsr.s   dodiv_1
08000E58  2204      2174          move.l  D4,D1
08000E5A  82C2      2175          divu    D2,D1
08000E5C  80C1      2176          divu    D1,D0
08000E5E  0280 0000 2177          andi.l  #$FFFF,D0
08000E62  FFFF      
                    2178   dodiv_3:
08000E64  2204      2179          move.l  D4,D1
08000E66  2404      2180          move.l  D4,D2
08000E68  4842      2181          swap    D2
08000E6A  C2C0      2182          mulu    D0,D1
08000E6C  C4C0      2183          mulu    D0,D2
08000E6E  4842      2184          swap    D2
08000E70  D282      2185          add.l   D2,D1
08000E72  9283      2186          sub.l   D3,D1
08000E74  620A      2187          bhi.s   dodiv_4
08000E76  4481      2188          neg.l   D1
08000E78  B881      2189          cmp.l   D1,D4
08000E7A  6208      2190          bhi.s   dodiv_5
08000E7C  5280      2191          addq.l  #1,D0
08000E7E  60E4      2192          bra.s   dodiv_3
                    2193   dodiv_4:
08000E80  5380      2194          subq.l  #1,D0
08000E82  60E0      2195          bra.s   dodiv_3
                    2196   dodiv_5:
08000E84  4CDF 001C 2197          movem.l (A7)+,D2/D3/D4
08000E88  4E75      2198          rts
                    2199   _printf:
08000E8A  4E56 FFFC 2200          link      A6,#-4
08000E8E  2F02      2201          move.l    D2,-(A7)
08000E90  41EE 0008 2202          lea       8(A6),A0
08000E94  5848      2203          addq.w    #4,A0
08000E96  2408      2204          move.l    A0,D2
08000E98  2F02      2205          move.l    D2,-(A7)
08000E9A  2F2E 0008 2206          move.l    8(A6),-(A7)
08000E9E  42A7      2207          clr.l     -(A7)
08000EA0  4EB9 0800 2208          jsr       _doprint
08000EA4  1002      
08000EA6  DEFC 000C 2209          add.w     #12,A7
08000EAA  2D40 FFFC 2210          move.l    D0,-4(A6)
08000EAE  4282      2211          clr.l     D2
08000EB0  202E FFFC 2212          move.l    -4(A6),D0
08000EB4  241F      2213          move.l    (A7)+,D2
08000EB6  4E5E      2214          unlk      A6
08000EB8  4E75      2215          rts
                    2216   ULMUL:
08000EBA  4E56 0000 2217          link    A6,#0
08000EBE  48E7 C000 2218          movem.l D0/D1,-(A7)
08000EC2  222E 0008 2219          move.l  8(A6),D1
08000EC6  202E 000C 2220          move.l  12(A6),D0
08000ECA  602C      2221          bra.s   lmul_3
                    2222   LMUL:
08000ECC  4E56 0000 2223          link    A6,#0
08000ED0  48E7 C000 2224          movem.l D0/D1,-(A7)
08000ED4  222E 0008 2225          move.l  8(A6),D1
08000ED8  202E 000C 2226          move.l  12(A6),D0
08000EDC  4A80      2227          tst.l   D0
08000EDE  6A0A      2228          bpl.s   lmul_1
08000EE0  4480      2229          neg.l   D0
08000EE2  4A81      2230          tst.l   D1
08000EE4  6A0A      2231          bpl.s   lmul_2
08000EE6  4481      2232          neg.l   D1
08000EE8  600E      2233          bra.s   lmul_3
                    2234   lmul_1:
08000EEA  4A81      2235          tst.l   D1
08000EEC  6A0A      2236          bpl.s   lmul_3
08000EEE  4481      2237          neg.l   D1
                    2238   lmul_2:
08000EF0  6114      2239          bsr.s   domul
08000EF2  4481      2240          neg.l   D1
08000EF4  4080      2241          negx.l  D0
08000EF6  6002      2242          bra.s   lmul_4
                    2243   lmul_3:
08000EF8  610C      2244          bsr.s   domul
                    2245   lmul_4:
08000EFA  2D41 0008 2246          move.l  D1,8(A6)
08000EFE  4CDF 0003 2247          movem.l (A7)+,D0/D1
08000F02  4E5E      2248          unlk    A6
08000F04  4E75      2249          rts
                    2250   domul:
08000F06  0C81 0000 2251          cmpi.l  #$FFFF,D1
08000F0A  FFFF      
08000F0C  620C      2252          bhi.s   domul_1
08000F0E  0C80 0000 2253          cmpi.l  #$FFFF,D0
08000F12  FFFF      
08000F14  620E      2254          bhi.s   domul_2
08000F16  C2C0      2255          mulu    D0,D1
08000F18  4E75      2256          rts
                    2257   domul_1:
08000F1A  0C80 0000 2258          cmpi.l  #$FFFF,D0
08000F1E  FFFF      
08000F20  6218      2259          bhi.s   domul_4
08000F22  6002      2260          bra.s   domul_3
                    2261   domul_2
08000F24  C141      2262          exg     D0,D1
                    2263   domul_3:
08000F26  2F02      2264          move.l  D2,-(A7)
08000F28  2401      2265          move.l  D1,D2
08000F2A  4842      2266          swap    D2
08000F2C  C2C0      2267          mulu    D0,D1
08000F2E  C4C0      2268          mulu    D0,D2
08000F30  4842      2269          swap    D2
08000F32  4242      2270          clr.w   D2
08000F34  D282      2271          add.l   D2,D1
08000F36  241F      2272          move.l  (A7)+,D2
08000F38  4E75      2273          rts
                    2274   domul_4:
08000F3A  48E7 3000 2275          movem.l D2/D3,-(A7)
08000F3E  2401      2276          move.l  D1,D2
08000F40  2601      2277          move.l  D1,D3
08000F42  C2C0      2278          mulu    D0,D1
08000F44  4842      2279          swap    D2
08000F46  C4C0      2280          mulu    D0,D2
08000F48  4840      2281          swap    D0
08000F4A  C6C0      2282          mulu    D0,D3
08000F4C  D483      2283          add.l   D3,D2
08000F4E  4842      2284          swap    D2
08000F50  4242      2285          clr.w   D2
08000F52  D282      2286          add.l   D2,D1
08000F54  4CDF 000C 2287          movem.l (A7)+,D2/D3
08000F58  4E75      2288          rts
                    2289   @doprint_copy:
08000F5A  4E56 0000 2290          link      A6,#0
08000F5E  206E 0008 2291          move.l    8(A6),A0
08000F62  4A90      2292          tst.l     (A0)
08000F64  6710      2293          beq.s     @doprint_copy_1
08000F66  202E 000C 2294          move.l    12(A6),D0
08000F6A  206E 0008 2295          move.l    8(A6),A0
08000F6E  2250      2296          move.l    (A0),A1
08000F70  5290      2297          addq.l    #1,(A0)
08000F72  1280      2298          move.b    D0,(A1)
08000F74  600C      2299          bra.s     @doprint_copy_2
                    2300   @doprint_copy_1:
08000F76  2F2E 000C 2301          move.l    12(A6),-(A7)
08000F7A  4EB9 0800 2302          jsr       _putch
08000F7E  17B4      
08000F80  584F      2303          addq.w    #4,A7
                    2304   @doprint_copy_2:
08000F82  4E5E      2305          unlk      A6
08000F84  4E75      2306          rts
                    2307   @doprint_getval:
08000F86  4E56 0000 2308          link      A6,#0
08000F8A  48E7 3000 2309          movem.l   D2/D3,-(A7)
08000F8E  262E 0008 2310          move.l    8(A6),D3
08000F92  4282      2311          clr.l     D2
08000F94  2043      2312          move.l    D3,A0
08000F96  2050      2313          move.l    (A0),A0
08000F98  1010      2314          move.b    (A0),D0
08000F9A  0C00 002A 2315          cmp.b     #42,D0
08000F9E  6612      2316          bne.s     @doprint_getval_1
08000FA0  206E 000C 2317          move.l    12(A6),A0
08000FA4  2250      2318          move.l    (A0),A1
08000FA6  5890      2319          addq.l    #4,(A0)
08000FA8  2411      2320          move.l    (A1),D2
08000FAA  2043      2321          move.l    D3,A0
08000FAC  5290      2322          addq.l    #1,(A0)
08000FAE  6000 0048 2323          bra       @doprint_getval_5
                    2324   @doprint_getval_1:
08000FB2  7001      2325          moveq     #1,D0
08000FB4  2043      2326          move.l    D3,A0
08000FB6  2050      2327          move.l    (A0),A0
08000FB8  1210      2328          move.b    (A0),D1
08000FBA  4881      2329          ext.w     D1
08000FBC  48C1      2330          ext.l     D1
08000FBE  D081      2331          add.l     D1,D0
08000FC0  41F9 0800 2332          lea       __ctype.L,A0
08000FC4  191C      
08000FC6  1030 0800 2333          move.b    0(A0,D0.L),D0
08000FCA  C03C 0004 2334          and.b     #4,D0
08000FCE  6728      2335          beq.s     @doprint_getval_5
08000FD0  2F02      2336          move.l    D2,-(A7)
08000FD2  4878 000A 2337          pea       10
08000FD6  4EB9 0800 2338          jsr       LMUL
08000FDA  0ECC      
08000FDC  2017      2339          move.l    (A7),D0
08000FDE  504F      2340          addq.w    #8,A7
08000FE0  2043      2341          move.l    D3,A0
08000FE2  2250      2342          move.l    (A0),A1
08000FE4  5290      2343          addq.l    #1,(A0)
08000FE6  1211      2344          move.b    (A1),D1
08000FE8  4881      2345          ext.w     D1
08000FEA  48C1      2346          ext.l     D1
08000FEC  D081      2347          add.l     D1,D0
08000FEE  0480 0000 2348          sub.l     #48,D0
08000FF2  0030      
08000FF4  2400      2349          move.l    D0,D2
08000FF6  60BA      2350          bra       @doprint_getval_1
                    2351   @doprint_getval_5:
08000FF8  2002      2352          move.l    D2,D0
08000FFA  4CDF 000C 2353          movem.l   (A7)+,D2/D3
08000FFE  4E5E      2354          unlk      A6
08001000  4E75      2355          rts
                    2356   _doprint:
08001002  4E56 FFCC 2357          link      A6,#-52
08001006  48E7 3F3C 2358          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0800100A  45EE 0008 2359          lea       8(A6),A2
0800100E  47F9 0800 2360          lea       @doprint_copy.L,A3
08001012  0F5A      
08001014  49F9 0800 2361          lea       _ultoa.L,A4
08001018  173C      
0800101A  4286      2362          clr.l     D6
                    2363   doprint_1:
0800101C  206E 000C 2364          move.l    12(A6),A0
08001020  4A10      2365          tst.b     (A0)
08001022  6700 05F0 2366          beq       doprint_3
08001026  206E 000C 2367          move.l    12(A6),A0
0800102A  1010      2368          move.b    (A0),D0
0800102C  0C00 0025 2369          cmp.b     #37,D0
08001030  671C      2370          beq.s     doprint_4
08001032  206E 000C 2371          move.l    12(A6),A0
08001036  52AE 000C 2372          addq.l    #1,12(A6)
0800103A  1210      2373          move.b    (A0),D1
0800103C  4881      2374          ext.w     D1
0800103E  48C1      2375          ext.l     D1
08001040  2F01      2376          move.l    D1,-(A7)
08001042  2F0A      2377          move.l    A2,-(A7)
08001044  4E93      2378          jsr       (A3)
08001046  504F      2379          addq.w    #8,A7
08001048  5286      2380          addq.l    #1,D6
0800104A  6000 05C4 2381          bra       doprint_2
                    2382   doprint_4:
0800104E  52AE 000C 2383          addq.l    #1,12(A6)
08001052  422E FFD3 2384          clr.b     -45(A6)
08001056  422E FFD2 2385          clr.b     -46(A6)
0800105A  422E FFD0 2386          clr.b     -48(A6)
0800105E  422E FFCF 2387          clr.b     -49(A6)
08001062  422E FFCE 2388          clr.b     -50(A6)
08001066  422E FFCD 2389          clr.b     -51(A6)
0800106A  42AE FFFC 2390          clr.l     -4(A6)
0800106E  7AFF      2391          moveq     #-1,D5
08001070  41EE FFDC 2392          lea       -36(A6),A0
08001074  2608      2393          move.l    A0,D3
08001076  2408      2394          move.l    A0,D2
                    2395   doprint_6:
08001078  206E 000C 2396          move.l    12(A6),A0
0800107C  1010      2397          move.b    (A0),D0
0800107E  4880      2398          ext.w     D0
08001080  48C0      2399          ext.l     D0
08001082  0C80 0000 2400          cmp.l     #43,D0
08001086  002B      
08001088  6730      2401          beq.s     doprint_12
0800108A  6E18      2402          bgt.s     doprint_15
0800108C  0C80 0000 2403          cmp.l     #35,D0
08001090  0023      
08001092  6700 003E 2404          beq       doprint_14
08001096  6E00 0046 2405          bgt       doprint_9
0800109A  0C80 0000 2406          cmp.l     #32,D0
0800109E  0020      
080010A0  6724      2407          beq.s     doprint_13
080010A2  603A      2408          bra.s     doprint_9
                    2409   doprint_15:
080010A4  0C80 0000 2410          cmp.l     #45,D0
080010A8  002D      
080010AA  6702      2411          beq.s     doprint_11
080010AC  6030      2412          bra.s     doprint_9
                    2413   doprint_11:
080010AE  1D7C 0001 2414          move.b    #1,-51(A6)
080010B2  FFCD      
080010B4  52AE 000C 2415          addq.l    #1,12(A6)
080010B8  6026      2416          bra.s     doprint_7
                    2417   doprint_12:
080010BA  1D7C 0001 2418          move.b    #1,-50(A6)
080010BE  FFCE      
080010C0  52AE 000C 2419          addq.l    #1,12(A6)
080010C4  601A      2420          bra.s     doprint_7
                    2421   doprint_13:
080010C6  1D7C 0001 2422          move.b    #1,-49(A6)
080010CA  FFCF      
080010CC  52AE 000C 2423          addq.l    #1,12(A6)
080010D0  600E      2424          bra.s     doprint_7
                    2425   doprint_14:
080010D2  1D7C 0001 2426          move.b    #1,-48(A6)
080010D6  FFD0      
080010D8  52AE 000C 2427          addq.l    #1,12(A6)
080010DC  6002      2428          bra.s     doprint_7
                    2429   doprint_9:
080010DE  6002      2430          bra.s     doprint_8
                    2431   doprint_7:
080010E0  6096      2432          bra       doprint_6
                    2433   doprint_8:
080010E2  206E 000C 2434          move.l    12(A6),A0
080010E6  1010      2435          move.b    (A0),D0
080010E8  0C00 0030 2436          cmp.b     #48,D0
080010EC  660A      2437          bne.s     doprint_16
080010EE  52AE 000C 2438          addq.l    #1,12(A6)
080010F2  1D7C 0001 2439          move.b    #1,-46(A6)
080010F6  FFD2      
                    2440   doprint_16:
080010F8  486E 0010 2441          pea       16(A6)
080010FC  486E 000C 2442          pea       12(A6)
08001100  4EB9 0800 2443          jsr       @doprint_getval
08001104  0F86      
08001106  504F      2444          addq.w    #8,A7
08001108  2A40      2445          move.l    D0,A5
0800110A  206E 000C 2446          move.l    12(A6),A0
0800110E  1010      2447          move.b    (A0),D0
08001110  0C00 002E 2448          cmp.b     #46,D0
08001114  6616      2449          bne.s     doprint_18
08001116  52AE 000C 2450          addq.l    #1,12(A6)
0800111A  486E 0010 2451          pea       16(A6)
0800111E  486E 000C 2452          pea       12(A6)
08001122  4EB9 0800 2453          jsr       @doprint_getval
08001126  0F86      
08001128  504F      2454          addq.w    #8,A7
0800112A  2A00      2455          move.l    D0,D5
                    2456   doprint_18:
0800112C  206E 000C 2457          move.l    12(A6),A0
08001130  1010      2458          move.b    (A0),D0
08001132  0C00 006C 2459          cmp.b     #108,D0
08001136  660A      2460          bne.s     doprint_20
08001138  52AE 000C 2461          addq.l    #1,12(A6)
0800113C  1D7C 0001 2462          move.b    #1,-45(A6)
08001140  FFD3      
                    2463   doprint_20:
08001142  206E 000C 2464          move.l    12(A6),A0
08001146  1010      2465          move.b    (A0),D0
08001148  4880      2466          ext.w     D0
0800114A  48C0      2467          ext.l     D0
0800114C  0C80 0000 2468          cmp.l     #111,D0
08001150  006F      
08001152  6700 00D8 2469          beq       doprint_27
08001156  6E34      2470          bgt.s     doprint_33
08001158  0C80 0000 2471          cmp.l     #100,D0
0800115C  0064      
0800115E  6700 0054 2472          beq       doprint_24
08001162  6E1C      2473          bgt.s     doprint_34
08001164  0C80 0000 2474          cmp.l     #99,D0
08001168  0063      
0800116A  6700 0130 2475          beq       doprint_30
0800116E  6E00 0174 2476          bgt       doprint_22
08001172  0C80 0000 2477          cmp.l     #88,D0
08001176  0058      
08001178  6700 00EA 2478          beq       doprint_28
0800117C  6000 0166 2479          bra       doprint_22
                    2480   doprint_34:
08001180  0C80 0000 2481          cmp.l     #105,D0
08001184  0069      
08001186  672C      2482          beq.s     doprint_24
08001188  6000 015A 2483          bra       doprint_22
                    2484   doprint_33:
0800118C  0C80 0000 2485          cmp.l     #117,D0
08001190  0075      
08001192  6700 0060 2486          beq       doprint_26
08001196  6E0E      2487          bgt.s     doprint_35
08001198  0C80 0000 2488          cmp.l     #115,D0
0800119C  0073      
0800119E  6700 0124 2489          beq       doprint_31
080011A2  6000 0140 2490          bra       doprint_22
                    2491   doprint_35:
080011A6  0C80 0000 2492          cmp.l     #120,D0
080011AA  0078      
080011AC  6700 00B6 2493          beq       doprint_28
080011B0  6000 0132 2494          bra       doprint_22
                    2495   doprint_24:
080011B4  4A2E FFD3 2496          tst.b     -45(A6)
080011B8  671C      2497          beq.s     doprint_36
080011BA  4878 000A 2498          pea       10
080011BE  2F03      2499          move.l    D3,-(A7)
080011C0  206E 0010 2500          move.l    16(A6),A0
080011C4  58AE 0010 2501          addq.l    #4,16(A6)
080011C8  2F10      2502          move.l    (A0),-(A7)
080011CA  4EB9 0800 2503          jsr       _ltoa
080011CE  16B4      
080011D0  DEFC 000C 2504          add.w     #12,A7
080011D4  601A      2505          bra.s     doprint_37
                    2506   doprint_36:
080011D6  4878 000A 2507          pea       10
080011DA  2F03      2508          move.l    D3,-(A7)
080011DC  206E 0010 2509          move.l    16(A6),A0
080011E0  58AE 0010 2510          addq.l    #4,16(A6)
080011E4  2F10      2511          move.l    (A0),-(A7)
080011E6  4EB9 0800 2512          jsr       _ltoa
080011EA  16B4      
080011EC  DEFC 000C 2513          add.w     #12,A7
                    2514   doprint_37:
080011F0  6000 0100 2515          bra       doprint_23
                    2516   doprint_26:
080011F4  4A2E FFD3 2517          tst.b     -45(A6)
080011F8  6718      2518          beq.s     doprint_38
080011FA  4878 000A 2519          pea       10
080011FE  2F03      2520          move.l    D3,-(A7)
08001200  206E 0010 2521          move.l    16(A6),A0
08001204  58AE 0010 2522          addq.l    #4,16(A6)
08001208  2F10      2523          move.l    (A0),-(A7)
0800120A  4E94      2524          jsr       (A4)
0800120C  DEFC 000C 2525          add.w     #12,A7
08001210  6016      2526          bra.s     doprint_39
                    2527   doprint_38:
08001212  4878 000A 2528          pea       10
08001216  2F03      2529          move.l    D3,-(A7)
08001218  206E 0010 2530          move.l    16(A6),A0
0800121C  58AE 0010 2531          addq.l    #4,16(A6)
08001220  2F10      2532          move.l    (A0),-(A7)
08001222  4E94      2533          jsr       (A4)
08001224  DEFC 000C 2534          add.w     #12,A7
                    2535   doprint_39:
08001228  6000 00C8 2536          bra       doprint_23
                    2537   doprint_27:
0800122C  4A2E FFD3 2538          tst.b     -45(A6)
08001230  6718      2539          beq.s     doprint_40
08001232  4878 0008 2540          pea       8
08001236  2F03      2541          move.l    D3,-(A7)
08001238  206E 0010 2542          move.l    16(A6),A0
0800123C  58AE 0010 2543          addq.l    #4,16(A6)
08001240  2F10      2544          move.l    (A0),-(A7)
08001242  4E94      2545          jsr       (A4)
08001244  DEFC 000C 2546          add.w     #12,A7
08001248  6016      2547          bra.s     doprint_41
                    2548   doprint_40:
0800124A  4878 0008 2549          pea       8
0800124E  2F03      2550          move.l    D3,-(A7)
08001250  206E 0010 2551          move.l    16(A6),A0
08001254  58AE 0010 2552          addq.l    #4,16(A6)
08001258  2F10      2553          move.l    (A0),-(A7)
0800125A  4E94      2554          jsr       (A4)
0800125C  DEFC 000C 2555          add.w     #12,A7
                    2556   doprint_41:
08001260  6000 0090 2557          bra       doprint_23
                    2558   doprint_28:
08001264  4A2E FFD3 2559          tst.b     -45(A6)
08001268  6718      2560          beq.s     doprint_42
0800126A  4878 0010 2561          pea       16
0800126E  2F03      2562          move.l    D3,-(A7)
08001270  206E 0010 2563          move.l    16(A6),A0
08001274  58AE 0010 2564          addq.l    #4,16(A6)
08001278  2F10      2565          move.l    (A0),-(A7)
0800127A  4E94      2566          jsr       (A4)
0800127C  DEFC 000C 2567          add.w     #12,A7
08001280  6016      2568          bra.s     doprint_43
                    2569   doprint_42:
08001282  4878 0010 2570          pea       16
08001286  2F03      2571          move.l    D3,-(A7)
08001288  206E 0010 2572          move.l    16(A6),A0
0800128C  58AE 0010 2573          addq.l    #4,16(A6)
08001290  2F10      2574          move.l    (A0),-(A7)
08001292  4E94      2575          jsr       (A4)
08001294  DEFC 000C 2576          add.w     #12,A7
                    2577   doprint_43:
08001298  6000 0058 2578          bra       doprint_23
                    2579   doprint_30:
0800129C  206E 0010 2580          move.l    16(A6),A0
080012A0  58AE 0010 2581          addq.l    #4,16(A6)
080012A4  2010      2582          move.l    (A0),D0
080012A6  2042      2583          move.l    D2,A0
080012A8  5282      2584          addq.l    #1,D2
080012AA  1080      2585          move.b    D0,(A0)
080012AC  2042      2586          move.l    D2,A0
080012AE  4210      2587          clr.b     (A0)
080012B0  200D      2588          move.l    A5,D0
080012B2  6704      2589          beq.s     doprint_44
080012B4  200D      2590          move.l    A5,D0
080012B6  6006      2591          bra.s     doprint_45
                    2592   doprint_44:
080012B8  7001      2593          moveq     #1,D0
080012BA  4880      2594          ext.w     D0
080012BC  48C0      2595          ext.l     D0
                    2596   doprint_45:
080012BE  2A00      2597          move.l    D0,D5
080012C0  6000 0030 2598          bra       doprint_23
                    2599   doprint_31:
080012C4  206E 0010 2600          move.l    16(A6),A0
080012C8  58AE 0010 2601          addq.l    #4,16(A6)
080012CC  2610      2602          move.l    (A0),D3
080012CE  0C85 FFFF 2603          cmp.l     #-1,D5
080012D2  FFFF      
080012D4  660C      2604          bne.s     doprint_46
080012D6  2F03      2605          move.l    D3,-(A7)
080012D8  4EB9 0800 2606          jsr       _strlen
080012DC  17A2      
080012DE  584F      2607          addq.w    #4,A7
080012E0  2A00      2608          move.l    D0,D5
                    2609   doprint_46:
080012E2  600E      2610          bra.s     doprint_23
                    2611   doprint_22:
080012E4  206E 000C 2612          move.l    12(A6),A0
080012E8  2242      2613          move.l    D2,A1
080012EA  5282      2614          addq.l    #1,D2
080012EC  1290      2615          move.b    (A0),(A1)
080012EE  2042      2616          move.l    D2,A0
080012F0  4210      2617          clr.b     (A0)
                    2618   doprint_23:
080012F2  2F03      2619          move.l    D3,-(A7)
080012F4  4EB9 0800 2620          jsr       _strlen
080012F8  17A2      
080012FA  584F      2621          addq.w    #4,A7
080012FC  1800      2622          move.b    D0,D4
080012FE  206E 000C 2623          move.l    12(A6),A0
08001302  1010      2624          move.b    (A0),D0
08001304  0C00 0073 2625          cmp.b     #115,D0
08001308  661C      2626          bne.s     doprint_48
0800130A  0C85 0000 2627          cmp.l     #0,D5
0800130E  0000      
08001310  6D14      2628          blt.s     doprint_48
08001312  4884      2629          ext.w     D4
08001314  48C4      2630          ext.l     D4
08001316  B885      2631          cmp.l     D5,D4
08001318  6F04      2632          ble.s     doprint_50
0800131A  2005      2633          move.l    D5,D0
0800131C  6006      2634          bra.s     doprint_51
                    2635   doprint_50:
0800131E  1004      2636          move.b    D4,D0
08001320  4880      2637          ext.w     D0
08001322  48C0      2638          ext.l     D0
                    2639   doprint_51:
08001324  1800      2640          move.b    D0,D4
                    2641   doprint_48:
08001326  206E 000C 2642          move.l    12(A6),A0
0800132A  1010      2643          move.b    (A0),D0
0800132C  0C00 0058 2644          cmp.b     #88,D0
08001330  6600 0028 2645          bne       doprint_56
08001334  41EE FFDC 2646          lea       -36(A6),A0
08001338  2408      2647          move.l    A0,D2
                    2648   doprint_54:
0800133A  2042      2649          move.l    D2,A0
0800133C  4A10      2650          tst.b     (A0)
0800133E  671A      2651          beq.s     doprint_56
08001340  2042      2652          move.l    D2,A0
08001342  1210      2653          move.b    (A0),D1
08001344  4881      2654          ext.w     D1
08001346  48C1      2655          ext.l     D1
08001348  2F01      2656          move.l    D1,-(A7)
0800134A  4EB9 0800 2657          jsr       _toupper
0800134E  17E4      
08001350  584F      2658          addq.w    #4,A7
08001352  2042      2659          move.l    D2,A0
08001354  1080      2660          move.b    D0,(A0)
08001356  5282      2661          addq.l    #1,D2
08001358  60E0      2662          bra       doprint_54
                    2663   doprint_56:
0800135A  7E00      2664          moveq     #0,D7
0800135C  41EE FFD4 2665          lea       -44(A6),A0
08001360  2408      2666          move.l    A0,D2
08001362  206E 000C 2667          move.l    12(A6),A0
08001366  1010      2668          move.b    (A0),D0
08001368  0C00 0064 2669          cmp.b     #100,D0
0800136C  670E      2670          beq.s     doprint_59
0800136E  206E 000C 2671          move.l    12(A6),A0
08001372  1010      2672          move.b    (A0),D0
08001374  0C00 0069 2673          cmp.b     #105,D0
08001378  6600 0068 2674          bne       doprint_65
                    2675   doprint_59:
0800137C  102E FFCE 2676          move.b    -50(A6),D0
08001380  4880      2677          ext.w     D0
08001382  48C0      2678          ext.l     D0
08001384  4A80      2679          tst.l     D0
08001386  660C      2680          bne.s     doprint_62
08001388  2043      2681          move.l    D3,A0
0800138A  1010      2682          move.b    (A0),D0
0800138C  0C00 002D 2683          cmp.b     #45,D0
08001390  6600 0028 2684          bne       doprint_60
                    2685   doprint_62:
08001394  2043      2686          move.l    D3,A0
08001396  1010      2687          move.b    (A0),D0
08001398  0C00 002D 2688          cmp.b     #45,D0
0800139C  660E      2689          bne.s     doprint_63
0800139E  2043      2690          move.l    D3,A0
080013A0  5283      2691          addq.l    #1,D3
080013A2  2242      2692          move.l    D2,A1
080013A4  5282      2693          addq.l    #1,D2
080013A6  1290      2694          move.b    (A0),(A1)
080013A8  5304      2695          subq.b    #1,D4
080013AA  6008      2696          bra.s     doprint_64
                    2697   doprint_63:
080013AC  2042      2698          move.l    D2,A0
080013AE  5282      2699          addq.l    #1,D2
080013B0  10BC 002B 2700          move.b    #43,(A0)
                    2701   doprint_64:
080013B4  5287      2702          addq.l    #1,D7
080013B6  6000 002A 2703          bra       doprint_65
                    2704   doprint_60:
080013BA  4A2E FFCF 2705          tst.b     -49(A6)
080013BE  6722      2706          beq.s     doprint_65
080013C0  2043      2707          move.l    D3,A0
080013C2  1010      2708          move.b    (A0),D0
080013C4  0C00 002D 2709          cmp.b     #45,D0
080013C8  660E      2710          bne.s     doprint_67
080013CA  2043      2711          move.l    D3,A0
080013CC  5283      2712          addq.l    #1,D3
080013CE  2242      2713          move.l    D2,A1
080013D0  5282      2714          addq.l    #1,D2
080013D2  1290      2715          move.b    (A0),(A1)
080013D4  5304      2716          subq.b    #1,D4
080013D6  6008      2717          bra.s     doprint_68
                    2718   doprint_67:
080013D8  2042      2719          move.l    D2,A0
080013DA  5282      2720          addq.l    #1,D2
080013DC  10BC 0020 2721          move.b    #32,(A0)
                    2722   doprint_68:
080013E0  5287      2723          addq.l    #1,D7
                    2724   doprint_65:
080013E2  4A2E FFD0 2725          tst.b     -48(A6)
080013E6  6700 005A 2726          beq       doprint_77
080013EA  206E 000C 2727          move.l    12(A6),A0
080013EE  1010      2728          move.b    (A0),D0
080013F0  4880      2729          ext.w     D0
080013F2  48C0      2730          ext.l     D0
080013F4  0C80 0000 2731          cmp.l     #111,D0
080013F8  006F      
080013FA  671A      2732          beq.s     doprint_73
080013FC  6E0C      2733          bgt.s     doprint_76
080013FE  0C80 0000 2734          cmp.l     #88,D0
08001402  0058      
08001404  6710      2735          beq.s     doprint_73
08001406  6000 003A 2736          bra       doprint_77
                    2737   doprint_76:
0800140A  0C80 0000 2738          cmp.l     #120,D0
0800140E  0078      
08001410  6704      2739          beq.s     doprint_73
08001412  6000 002E 2740          bra       doprint_77
                    2741   doprint_73:
08001416  2042      2742          move.l    D2,A0
08001418  5282      2743          addq.l    #1,D2
0800141A  10BC 0030 2744          move.b    #48,(A0)
0800141E  5287      2745          addq.l    #1,D7
08001420  206E 000C 2746          move.l    12(A6),A0
08001424  1010      2747          move.b    (A0),D0
08001426  0C00 0078 2748          cmp.b     #120,D0
0800142A  670C      2749          beq.s     doprint_79
0800142C  206E 000C 2750          move.l    12(A6),A0
08001430  1010      2751          move.b    (A0),D0
08001432  0C00 0058 2752          cmp.b     #88,D0
08001436  660A      2753          bne.s     doprint_77
                    2754   doprint_79:
08001438  2042      2755          move.l    D2,A0
0800143A  5282      2756          addq.l    #1,D2
0800143C  10BC 0078 2757          move.b    #120,(A0)
08001440  5287      2758          addq.l    #1,D7
                    2759   doprint_77:
08001442  2042      2760          move.l    D2,A0
08001444  4210      2761          clr.b     (A0)
08001446  206E 000C 2762          move.l    12(A6),A0
0800144A  1010      2763          move.b    (A0),D0
0800144C  4880      2764          ext.w     D0
0800144E  48C0      2765          ext.l     D0
08001450  0C80 0000 2766          cmp.l     #105,D0
08001454  0069      
08001456  6700 0076 2767          beq       doprint_82
0800145A  6E42      2768          bgt.s     doprint_93
0800145C  0C80 0000 2769          cmp.l     #99,D0
08001460  0063      
08001462  6700 0084 2770          beq       doprint_96
08001466  6E1C      2771          bgt.s     doprint_94
08001468  0C80 0000 2772          cmp.l     #88,D0
0800146C  0058      
0800146E  6700 005E 2773          beq       doprint_82
08001472  6E00 0184 2774          bgt       doprint_80
08001476  0C80 0000 2775          cmp.l     #69,D0
0800147A  0045      
0800147C  6700 0050 2776          beq       doprint_82
08001480  6000 0176 2777          bra       doprint_80
                    2778   doprint_94:
08001484  0C80 0000 2779          cmp.l     #101,D0
08001488  0065      
0800148A  6700 0042 2780          beq       doprint_82
0800148E  6E00 0168 2781          bgt       doprint_80
08001492  0C80 0000 2782          cmp.l     #100,D0
08001496  0064      
08001498  6734      2783          beq.s     doprint_82
0800149A  6000 015C 2784          bra       doprint_80
                    2785   doprint_93:
0800149E  0C80 0000 2786          cmp.l     #117,D0
080014A2  0075      
080014A4  6728      2787          beq.s     doprint_82
080014A6  6E1A      2788          bgt.s     doprint_95
080014A8  0C80 0000 2789          cmp.l     #115,D0
080014AC  0073      
080014AE  6700 0038 2790          beq       doprint_96
080014B2  6E00 0144 2791          bgt       doprint_80
080014B6  0C80 0000 2792          cmp.l     #111,D0
080014BA  006F      
080014BC  6710      2793          beq.s     doprint_82
080014BE  6000 0138 2794          bra       doprint_80
                    2795   doprint_95:
080014C2  0C80 0000 2796          cmp.l     #120,D0
080014C6  0078      
080014C8  6704      2797          beq.s     doprint_82
080014CA  6000 012C 2798          bra       doprint_80
                    2799   doprint_82:
080014CE  4A2E FFD2 2800          tst.b     -46(A6)
080014D2  6714      2801          beq.s     doprint_96
080014D4  4A2E FFCD 2802          tst.b     -51(A6)
080014D8  660E      2803          bne.s     doprint_96
080014DA  200D      2804          move.l    A5,D0
080014DC  9087      2805          sub.l     D7,D0
080014DE  4884      2806          ext.w     D4
080014E0  48C4      2807          ext.l     D4
080014E2  9084      2808          sub.l     D4,D0
080014E4  2D40 FFFC 2809          move.l    D0,-4(A6)
                    2810   doprint_96:
080014E8  202E FFFC 2811          move.l    -4(A6),D0
080014EC  0C80 0000 2812          cmp.l     #0,D0
080014F0  0000      
080014F2  6C04      2813          bge.s     doprint_98
080014F4  42AE FFFC 2814          clr.l     -4(A6)
                    2815   doprint_98:
080014F8  4A2E FFCD 2816          tst.b     -51(A6)
080014FC  6600 0030 2817          bne       doprint_104
08001500  1004      2818          move.b    D4,D0
08001502  4880      2819          ext.w     D0
08001504  48C0      2820          ext.l     D0
08001506  D0AE FFFC 2821          add.l     -4(A6),D0
0800150A  D087      2822          add.l     D7,D0
0800150C  1D40 FFD1 2823          move.b    D0,-47(A6)
                    2824   doprint_102:
08001510  102E FFD1 2825          move.b    -47(A6),D0
08001514  4880      2826          ext.w     D0
08001516  48C0      2827          ext.l     D0
08001518  220D      2828          move.l    A5,D1
0800151A  534D      2829          subq.w    #1,A5
0800151C  B081      2830          cmp.l     D1,D0
0800151E  6C0E      2831          bge.s     doprint_104
08001520  4878 0020 2832          pea       32
08001524  2F0A      2833          move.l    A2,-(A7)
08001526  4E93      2834          jsr       (A3)
08001528  504F      2835          addq.w    #8,A7
0800152A  5286      2836          addq.l    #1,D6
0800152C  60E2      2837          bra       doprint_102
                    2838   doprint_104:
0800152E  41EE FFD4 2839          lea       -44(A6),A0
08001532  2408      2840          move.l    A0,D2
                    2841   doprint_105:
08001534  2042      2842          move.l    D2,A0
08001536  4A10      2843          tst.b     (A0)
08001538  6716      2844          beq.s     doprint_107
0800153A  2042      2845          move.l    D2,A0
0800153C  5282      2846          addq.l    #1,D2
0800153E  1210      2847          move.b    (A0),D1
08001540  4881      2848          ext.w     D1
08001542  48C1      2849          ext.l     D1
08001544  2F01      2850          move.l    D1,-(A7)
08001546  2F0A      2851          move.l    A2,-(A7)
08001548  4E93      2852          jsr       (A3)
0800154A  504F      2853          addq.w    #8,A7
0800154C  5286      2854          addq.l    #1,D6
0800154E  60E4      2855          bra       doprint_105
                    2856   doprint_107:
08001550  202E FFFC 2857          move.l    -4(A6),D0
08001554  1D40 FFD1 2858          move.b    D0,-47(A6)
                    2859   doprint_108:
08001558  102E FFD1 2860          move.b    -47(A6),D0
0800155C  532E FFD1 2861          subq.b    #1,-47(A6)
08001560  4A00      2862          tst.b     D0
08001562  670E      2863          beq.s     doprint_110
08001564  4878 0030 2864          pea       48
08001568  2F0A      2865          move.l    A2,-(A7)
0800156A  4E93      2866          jsr       (A3)
0800156C  504F      2867          addq.w    #8,A7
0800156E  5286      2868          addq.l    #1,D6
08001570  60E6      2869          bra       doprint_108
                    2870   doprint_110:
08001572  2043      2871          move.l    D3,A0
08001574  4A10      2872          tst.b     (A0)
08001576  6700 0048 2873          beq       doprint_113
0800157A  206E 000C 2874          move.l    12(A6),A0
0800157E  1010      2875          move.b    (A0),D0
08001580  4880      2876          ext.w     D0
08001582  48C0      2877          ext.l     D0
08001584  0C80 0000 2878          cmp.l     #115,D0
08001588  0073      
0800158A  670C      2879          beq.s     doprint_116
0800158C  6E18      2880          bgt.s     doprint_119
0800158E  0C80 0000 2881          cmp.l     #99,D0
08001592  0063      
08001594  6702      2882          beq.s     doprint_116
08001596  600E      2883          bra.s     doprint_119
                    2884   doprint_116:
08001598  2005      2885          move.l    D5,D0
0800159A  5385      2886          subq.l    #1,D5
0800159C  0C80 0000 2887          cmp.l     #0,D0
080015A0  0000      
080015A2  6E02      2888          bgt.s     doprint_119
080015A4  6016      2889          bra.s     doprint_115
                    2890   doprint_119:
080015A6  2043      2891          move.l    D3,A0
080015A8  5283      2892          addq.l    #1,D3
080015AA  1210      2893          move.b    (A0),D1
080015AC  4881      2894          ext.w     D1
080015AE  48C1      2895          ext.l     D1
080015B0  2F01      2896          move.l    D1,-(A7)
080015B2  2F0A      2897          move.l    A2,-(A7)
080015B4  4E93      2898          jsr       (A3)
080015B6  504F      2899          addq.w    #8,A7
080015B8  5286      2900          addq.l    #1,D6
080015BA  6002      2901          bra.s     doprint_112
                    2902   doprint_115:
080015BC  6002      2903          bra.s     doprint_113
                    2904   doprint_112:
080015BE  60B2      2905          bra       doprint_110
                    2906   doprint_113:
080015C0  4A2E FFCD 2907          tst.b     -51(A6)
080015C4  6700 0030 2908          beq       doprint_125
080015C8  1004      2909          move.b    D4,D0
080015CA  4880      2910          ext.w     D0
080015CC  48C0      2911          ext.l     D0
080015CE  D0AE FFFC 2912          add.l     -4(A6),D0
080015D2  D087      2913          add.l     D7,D0
080015D4  1D40 FFD1 2914          move.b    D0,-47(A6)
                    2915   doprint_123:
080015D8  102E FFD1 2916          move.b    -47(A6),D0
080015DC  4880      2917          ext.w     D0
080015DE  48C0      2918          ext.l     D0
080015E0  220D      2919          move.l    A5,D1
080015E2  534D      2920          subq.w    #1,A5
080015E4  B081      2921          cmp.l     D1,D0
080015E6  6C0E      2922          bge.s     doprint_125
080015E8  4878 0020 2923          pea       32
080015EC  2F0A      2924          move.l    A2,-(A7)
080015EE  4E93      2925          jsr       (A3)
080015F0  504F      2926          addq.w    #8,A7
080015F2  5386      2927          subq.l    #1,D6
080015F4  60E2      2928          bra       doprint_123
                    2929   doprint_125:
080015F6  6014      2930          bra.s     doprint_81
                    2931   doprint_80:
080015F8  206E 000C 2932          move.l    12(A6),A0
080015FC  1210      2933          move.b    (A0),D1
080015FE  4881      2934          ext.w     D1
08001600  48C1      2935          ext.l     D1
08001602  2F01      2936          move.l    D1,-(A7)
08001604  2F0A      2937          move.l    A2,-(A7)
08001606  4E93      2938          jsr       (A3)
08001608  504F      2939          addq.w    #8,A7
0800160A  5286      2940          addq.l    #1,D6
                    2941   doprint_81:
0800160C  52AE 000C 2942          addq.l    #1,12(A6)
                    2943   doprint_2:
08001610  6000 FA0A 2944          bra       doprint_1
                    2945   doprint_3:
08001614  4A92      2946          tst.l     (A2)
08001616  6710      2947          beq.s     doprint_126
08001618  4201      2948          clr.b     D1
0800161A  C2BC 0000 2949          and.l     #255,D1
0800161E  00FF      
08001620  2F01      2950          move.l    D1,-(A7)
08001622  2F0A      2951          move.l    A2,-(A7)
08001624  4E93      2952          jsr       (A3)
08001626  504F      2953          addq.w    #8,A7
                    2954   doprint_126:
08001628  2006      2955          move.l    D6,D0
0800162A  4CDF 3CFC 2956          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0800162E  4E5E      2957          unlk      A6
08001630  4E75      2958          rts
                    2959   @itoa_convert:
08001632  4E56 0000 2960          link      A6,#0
08001636  48E7 3C00 2961          movem.l   D2/D3/D4/D5,-(A7)
0800163A  242E 0008 2962          move.l    8(A6),D2
0800163E  262E 0010 2963          move.l    16(A6),D3
08001642  2A2E 000C 2964          move.l    12(A6),D5
08001646  2F05      2965          move.l    D5,-(A7)
08001648  2F03      2966          move.l    D3,-(A7)
0800164A  4EB9 0800 2967          jsr       ULDIV
0800164E  0DAC      
08001650  202F 0004 2968          move.l    4(A7),D0
08001654  504F      2969          addq.w    #8,A7
08001656  2800      2970          move.l    D0,D4
08001658  BA83      2971          cmp.l     D3,D5
0800165A  6520      2972          blo.s     @itoa_convert_1
0800165C  2F03      2973          move.l    D3,-(A7)
0800165E  2F05      2974          move.l    D5,-(A7)
08001660  2F03      2975          move.l    D3,-(A7)
08001662  4EB9 0800 2976          jsr       ULDIV
08001666  0DAC      
08001668  2217      2977          move.l    (A7),D1
0800166A  504F      2978          addq.w    #8,A7
0800166C  2F01      2979          move.l    D1,-(A7)
0800166E  2F02      2980          move.l    D2,-(A7)
08001670  4EB9 0800 2981          jsr       @itoa_convert
08001674  1632      
08001676  DEFC 000C 2982          add.w     #12,A7
0800167A  2400      2983          move.l    D0,D2
                    2984   @itoa_convert_1:
0800167C  0C84 0000 2985          cmp.l     #9,D4
08001680  0009      
08001682  6E0E      2986          bgt.s     @itoa_convert_3
08001684  2004      2987          move.l    D4,D0
08001686  7230      2988          moveq     #48,D1
08001688  C2BC 0000 2989          and.l     #255,D1
0800168C  00FF      
0800168E  D081      2990          add.l     D1,D0
08001690  6012      2991          bra.s     @itoa_convert_4
                    2992   @itoa_convert_3:
08001692  2004      2993          move.l    D4,D0
08001694  7261      2994          moveq     #97,D1
08001696  C2BC 0000 2995          and.l     #255,D1
0800169A  00FF      
0800169C  D081      2996          add.l     D1,D0
0800169E  0480 0000 2997          sub.l     #10,D0
080016A2  000A      
                    2998   @itoa_convert_4:
080016A4  2042      2999          move.l    D2,A0
080016A6  1080      3000          move.b    D0,(A0)
080016A8  2002      3001          move.l    D2,D0
080016AA  5280      3002          addq.l    #1,D0
080016AC  4CDF 003C 3003          movem.l   (A7)+,D2/D3/D4/D5
080016B0  4E5E      3004          unlk      A6
080016B2  4E75      3005          rts
                    3006   _ltoa:
080016B4  4E56 0000 3007          link      A6,#0
080016B8  48E7 3C00 3008          movem.l   D2/D3/D4/D5,-(A7)
080016BC  242E 0008 3009          move.l    8(A6),D2
080016C0  262E 000C 3010          move.l    12(A6),D3
080016C4  2A2E 0010 3011          move.l    16(A6),D5
080016C8  2803      3012          move.l    D3,D4
080016CA  0C85 0000 3013          cmp.l     #2,D5
080016CE  0002      
080016D0  6D08      3014          blt.s     ltoa_3
080016D2  0C85 0000 3015          cmp.l     #36,D5
080016D6  0024      
080016D8  6F06      3016          ble.s     ltoa_1
                    3017   ltoa_3:
080016DA  2003      3018          move.l    D3,D0
080016DC  6000 0056 3019          bra       ltoa_4
                    3020   ltoa_1:
080016E0  0C85 0000 3021          cmp.l     #10,D5
080016E4  000A      
080016E6  6600 0034 3022          bne       ltoa_5
080016EA  0C82 0000 3023          cmp.l     #0,D2
080016EE  0000      
080016F0  6C2A      3024          bge.s     ltoa_5
080016F2  2002      3025          move.l    D2,D0
080016F4  4480      3026          neg.l     D0
080016F6  2400      3027          move.l    D0,D2
080016F8  0C82 0000 3028          cmp.l     #0,D2
080016FC  0000      
080016FE  6C14      3029          bge.s     ltoa_7
08001700  4879 0800 3030          pea       @itoa_1.L
08001704  1910      
08001706  2F03      3031          move.l    D3,-(A7)
08001708  4EB9 0800 3032          jsr       _strcpy
0800170C  1800      
0800170E  504F      3033          addq.w    #8,A7
08001710  2003      3034          move.l    D3,D0
08001712  6020      3035          bra.s     ltoa_4
                    3036   ltoa_7:
08001714  2044      3037          move.l    D4,A0
08001716  5284      3038          addq.l    #1,D4
08001718  10BC 002D 3039          move.b    #45,(A0)
                    3040   ltoa_5:
0800171C  2F05      3041          move.l    D5,-(A7)
0800171E  2F02      3042          move.l    D2,-(A7)
08001720  2F04      3043          move.l    D4,-(A7)
08001722  4EB9 0800 3044          jsr       @itoa_convert
08001726  1632      
08001728  DEFC 000C 3045          add.w     #12,A7
0800172C  2800      3046          move.l    D0,D4
0800172E  2044      3047          move.l    D4,A0
08001730  4210      3048          clr.b     (A0)
08001732  2003      3049          move.l    D3,D0
                    3050   ltoa_4:
08001734  4CDF 003C 3051          movem.l   (A7)+,D2/D3/D4/D5
08001738  4E5E      3052          unlk      A6
0800173A  4E75      3053          rts
                    3054   _ultoa:
0800173C  4E56 0000 3055          link      A6,#0
08001740  48E7 3800 3056          movem.l   D2/D3/D4,-(A7)
08001744  262E 0010 3057          move.l    16(A6),D3
08001748  282E 000C 3058          move.l    12(A6),D4
0800174C  2404      3059          move.l    D4,D2
0800174E  0C83 0000 3060          cmp.l     #2,D3
08001752  0002      
08001754  6D08      3061          blt.s     ultoa_3
08001756  0C83 0000 3062          cmp.l     #36,D3
0800175A  0024      
0800175C  6F04      3063          ble.s     ultoa_1
                    3064   ultoa_3:
0800175E  2004      3065          move.l    D4,D0
08001760  601A      3066          bra.s     ultoa_4
                    3067   ultoa_1:
08001762  2F03      3068          move.l    D3,-(A7)
08001764  2F2E 0008 3069          move.l    8(A6),-(A7)
08001768  2F02      3070          move.l    D2,-(A7)
0800176A  4EB9 0800 3071          jsr       @itoa_convert
0800176E  1632      
08001770  DEFC 000C 3072          add.w     #12,A7
08001774  2400      3073          move.l    D0,D2
08001776  2042      3074          move.l    D2,A0
08001778  4210      3075          clr.b     (A0)
0800177A  2004      3076          move.l    D4,D0
                    3077   ultoa_4:
0800177C  4CDF 001C 3078          movem.l   (A7)+,D2/D3/D4
08001780  4E5E      3079          unlk      A6
08001782  4E75      3080          rts
                    3081   _itoa:
08001784  4E56 0000 3082          link      A6,#0
08001788  2F2E 0010 3083          move.l    16(A6),-(A7)
0800178C  2F2E 000C 3084          move.l    12(A6),-(A7)
08001790  2F2E 0008 3085          move.l    8(A6),-(A7)
08001794  4EB9 0800 3086          jsr       _ltoa
08001798  16B4      
0800179A  DEFC 000C 3087          add.w     #12,A7
0800179E  4E5E      3088          unlk      A6
080017A0  4E75      3089          rts
                    3090   _strlen:
080017A2  206F 0004 3091          move.l    (4,A7),A0
080017A6  2248      3092          move.l    A0,A1
                    3093   strlen_1:
080017A8  4A19      3094          tst.b     (A1)+
080017AA  66FC      3095          bne       strlen_1
080017AC  2009      3096          move.l    A1,D0
080017AE  9088      3097          sub.l     A0,D0
080017B0  5380      3098          subq.l    #1,D0
080017B2  4E75      3099          rts
                    3100   _putch:
080017B4  4E56 0000 3101          link      A6,#0
080017B8  2F02      3102          move.l    D2,-(A7)
080017BA  242E 0008 3103          move.l    8(A6),D2
080017BE  0C82 0000 3104          cmp.l     #10,D2
080017C2  000A      
080017C4  660C      3105          bne.s     putch_1
080017C6  4878 000D 3106          pea       13
080017CA  4EB9 0800 3107          jsr       __putch
080017CE  0944      
080017D0  584F      3108          addq.w    #4,A7
                    3109   putch_1:
080017D2  2F02      3110          move.l    D2,-(A7)
080017D4  4EB9 0800 3111          jsr       __putch
080017D8  0944      
080017DA  584F      3112          addq.w    #4,A7
080017DC  2002      3113          move.l    D2,D0
080017DE  241F      3114          move.l    (A7)+,D2
080017E0  4E5E      3115          unlk      A6
080017E2  4E75      3116          rts
                    3117   _toupper:
080017E4  202F 0004 3118          move.l    4(A7),D0
080017E8  0C80 0000 3119          cmp.l     #'a',D0
080017EC  0061      
080017EE  6D0E      3120          blt.s     toupper_1
080017F0  0C80 0000 3121          cmp.l     #'z',D0
080017F4  007A      
080017F6  6E06      3122          bgt.s     toupper_1
080017F8  0480 0000 3123          sub.l     #$20,D0
080017FC  0020      
                    3124   toupper_1:
080017FE  4E75      3125          rts
                    3126   _strcpy:
08001800  206F 0004 3127          move.l    (4,A7),A0
08001804  226F 0008 3128          move.l    (8,A7),A1
08001808  2008      3129          move.l    A0,D0
                    3130   strcpy_1:
0800180A  10D9      3131          move.b    (A1)+,(A0)+
0800180C  66FC      3132          bne.s     strcpy_1
0800180E  4E75      3133          rts
                    3134          section   const
08001810            3135                   align
                    3136   
                    3137   
                    3138   @iic_dr~1_1:
08001810  0D0A 456E 3139          dc.b      13,10,69,110,116,101,114,101,100,32,70,105,114
08001814  7465 7265 
08001818  6420 4669 
0800181C  72        
0800181D  7374 2042 3140          dc.b      115,116,32,66,108,111,99,107,32,76,111,111,112
08001821  6C6F 636B 
08001825  204C 6F6F 
08001829  70        
0800182A  00        3141          dc.b      0
                    3142   @iic_dr~1_2:
0800182C  0D0A 2045 3143          dc.b      13,10,32,69,110,116,101,114,101,100,32,73,110
08001830  6E74 6572 
08001834  6564 2049 
08001838  6E        
08001839  7465 726D 3144          dc.b      116,101,114,109,101,100,105,97,116,101,32,76
0800183D  6564 6961 
08001841  7465 204C 
08001845  6F6F 7000 3145          dc.b      111,111,112,0
                    3146   @iic_dr~1_3:
0800184A  0D0A 2043 3147          dc.b      13,10,32,67,117,114,114,101,110,116,32,65,100
0800184E  7572 7265 
08001852  6E74 2041 
08001856  64        
08001857  6472 6573 3148          dc.b      100,114,101,115,115,32,73,110,100,101,120,58
0800185B  7320 496E 
0800185F  6465 783A 
08001863  2025 7800 3149          dc.b      32,37,120,0
                    3150   @iic_dr~1_4:
08001868  0D0A 2045 3151          dc.b      13,10,32,69,110,116,101,114,101,100,32,76,97
0800186C  6E74 6572 
08001870  6564 204C 
08001874  61        
08001875  7374 2042 3152          dc.b      115,116,32,66,108,111,99,107,32,76,111,111,112
08001879  6C6F 636B 
0800187D  204C 6F6F 
08001881  70        
08001882  00        3153          dc.b      0
                    3154   @iic_dr~1_5:
08001884  0D0A 2045 3155          dc.b      13,10,32,69,120,105,116,101,100,32,65,108,108
08001888  7869 7465 
0800188C  6420 416C 
08001890  6C        
08001891  204C 6F6F 3156          dc.b      32,76,111,111,112,115,0
08001895  7073 00   
                    3157   @m68kus~1_1:
08001898  0D0A 496E 3158          dc.b      13,10,73,110,105,116,105,97,108,105,122,105
0800189C  6974 6961 
080018A0  6C69 7A69 
080018A4  6E67 2049 3159          dc.b      110,103,32,73,73,67,32,67,111,110,116,114,111
080018A8  4943 2043 
080018AC  6F6E 7472 
080018B0  6F        
080018B1  6C6C 6572 3160          dc.b      108,108,101,114,0
080018B5  00        
                    3161   @m68kus~1_2:
080018B6  0D0A 446F 3162          dc.b      13,10,68,111,110,101,32,105,110,105,116,105
080018BA  6E65 2069 
080018BE  6E69 7469 
080018C2  616C 697A 3163          dc.b      97,108,105,122,97,116,105,111,110,44,32,115
080018C6  6174 696F 
080018CA  6E2C 2073 
080018CE  656E 6469 3164          dc.b      101,110,100,105,110,103,32,97,32,98,121,116
080018D2  6E67 2061 
080018D6  2062 7974 
080018DA  652E 2E2E 3165          dc.b      101,46,46,46,0
080018DE  00        
                    3166   @adc_dac_1:
080018E0  0D0A 2047 3167          dc.b      13,10,32,71,101,110,101,114,97,116,101,100,32
080018E4  656E 6572 
080018E8  6174 6564 
080018EC  20        
080018ED  5374 6172 3168          dc.b      83,116,97,114,116,32,83,105,103,110,97,108,0
080018F1  7420 5369 
080018F5  676E 616C 
080018F9  00        
                    3169   @adc_dac_2:
080018FA  0D0A 2053 3170          dc.b      13,10,32,83,101,110,116,32,67,111,110,116,114
080018FE  656E 7420 
08001902  436F 6E74 
08001906  72        
08001907  6F6C 2042 3171          dc.b      111,108,32,66,121,116,101,0
0800190B  7974 6500 
                    3172   @itoa_1:
08001910  2D32 3134 3173          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
08001914  3734 3833 
08001918  3634 3800 
                    3174   __ctype:
0800191C  0040 4040 3175          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
08001920  4040 4040 
08001924  4040 5050 
08001928  5050 50   
0800192B  4040 4040 3176          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
0800192F  4040 4040 
08001933  4040 4040 
08001937  4040 40   
0800193A  4040 40D0 3177          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
0800193E  A0A0 A0A0 
08001942  A0A0 A0A0 
08001946  A0A0 A0A0 3178          dc.b      160,160,160,160,160,160,160,140,140,140,140
0800194A  A0A0 A08C 
0800194E  8C8C 8C   
08001951  8C8C 8C8C 3179          dc.b      140,140,140,140,140,140,160,160,160,160,160
08001955  8C8C A0A0 
08001959  A0A0 A0   
0800195C  A0A0 8A8A 3180          dc.b      160,160,138,138,138,138,138,138,130,130,130
08001960  8A8A 8A8A 
08001964  8282 82   
08001967  8282 8282 3181          dc.b      130,130,130,130,130,130,130,130,130,130,130
0800196B  8282 8282 
0800196F  8282 82   
08001972  8282 8282 3182          dc.b      130,130,130,130,130,130,160,160,160,160,160
08001976  8282 A0A0 
0800197A  A0A0 A0   
0800197D  A089 8989 3183          dc.b      160,137,137,137,137,137,137,129,129,129,129
08001981  8989 8981 
08001985  8181 81   
08001988  8181 8181 3184          dc.b      129,129,129,129,129,129,129,129,129,129,129
0800198C  8181 8181 
08001990  8181 81   
08001993  8181 8181 3185          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
08001997  81A0 A0A0 
0800199B  A040 0000 
0800199F  00        
080019A0  0000 0000 3186          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080019A4  0000 0000 
080019A8  0000 0000 
080019AC  0000 0000 
080019B0  0000 0000 
080019B4  0000      
080019B6  0000 0000 3187          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080019BA  0000 0000 
080019BE  0000 0000 
080019C2  0000 0000 
080019C6  0000 0000 
080019CA  0000      
080019CC  0000 0000 3188          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080019D0  0000 0000 
080019D4  0000 0000 
080019D8  0000 0000 
080019DC  0000 0000 
080019E0  0000      
080019E2  0000 0000 3189          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080019E6  0000 0000 
080019EA  0000 0000 
080019EE  0000 0000 
080019F2  0000 0000 
080019F6  0000      
080019F8  0000 0000 3190          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080019FC  0000 0000 
08001A00  0000 0000 
08001A04  0000 0000 
08001A08  0000 0000 
08001A0C  0000      
08001A0E  0000 0000 3191          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
08001A12  0000 0000 
08001A16  0000 0000 
08001A1A  0000 00   
                    3192          section   data
08001A1E            3193                   align
                    3194   
                    3195   *********************************************************************************************************************************************************
                    3196   * Section for Initialised Data (in theory should be copied to Ram at startup) but is part of program code as we copy whole program to ram at startup
                    3197   ********************************************************************************************************************************************************
                    3198   
          0800 1A1E 3199   DataStart       equ       *
08001A1E            3200   __ungetbuf:     ds.l      1                    ungetbuffer for stdio functions
08001A22            3201   __allocp:       ds.l      1                    start of free memory block list
08001A26            3202   __heap:         ds.l      1                    begin of free memory
                    3203   
                    3204   
                    3205   _IICClkPrescalerLow:
08001A2A  0040 8000 3206          dc.l      4227072
                    3207   _IICClkPrescalerHigh:
08001A2E  0040 8002 3208          dc.l      4227074
                    3209   _IICControl:
08001A32  0040 8004 3210          dc.l      4227076
                    3211   _IICTx:
08001A36  0040 8006 3212          dc.l      4227078
                    3213   _IICRx:
08001A3A  0040 8006 3214          dc.l      4227078
                    3215   _IICStatus:
08001A3E  0040 8008 3216          dc.l      4227080
                    3217   _IICCommand:
08001A42  0040 8008 3218          dc.l      4227080
                    3219   _IICTx_:
08001A46  0040 8006 3220          dc.l      4227078
                    3221   _IICRx_:
08001A4A  0040 8006 3222          dc.l      4227078
                    3223   _IICCommand_:
08001A4E  0040 8008 3224          dc.l      4227080
                    3225          section   bss
08001A52            3226                   align
                    3227   
          0800 1A52 3228   DataEnd         equ       *                    this label will equate to the address of the last byte of global variable in it
          0000 0034 3229   DataLength      equ       DataEnd-DataStart    length of data needed to copy to Ram on bootup
                    3230   
                    3231   *********************************************************************************************************
                    3232   * Section for uninitialised Data which is set to zero, i.e. we should set this space to zero at starup
                    3233   *********************************************************************************************************
          0800 1A52 3234   BssStart       equ       *
                    3235   
                    3236   _x:
08001A52            3237          ds.b      4
                    3238   _y:
08001A56            3239          ds.b      4
                    3240   _z:
08001A5A            3241          ds.b      4
                    3242   _PortA_Count:
08001A5E            3243          ds.b      4
                    3244   _Timer1Count:
08001A62            3245          ds.b      1
                    3246   _Timer2Count:
08001A64            3247          ds.b      1
                    3248   _Timer3Count:
08001A66            3249          ds.b      1
                    3250   _Timer4Count:
08001A68            3251          ds.b      1
                    3252   _counter:
08001A6A            3253          ds.b      4
                    3254   _rollovers:
08001A6E            3255          ds.b      4
                    3256   _a:
08001A72            3257          ds.b      40000
                    3258   _b:
0800B6B2            3259          ds.b      40000
                    3260   _c:
080152F2            3261          ds.b      40000
                    3262   _i:
0801EF32            3263          ds.b      4
                    3264   _j:
0801EF36            3265          ds.b      4
                    3266   _k:
0801EF3A            3267          ds.b      4
                    3268   _sum:
0801EF3E            3269          ds.b      4
                    3270          section   heap
0801EF42            3271                  align
                    3272   
          0801 EF42 3273   BssEnd         equ       *
          0001 D4F0 3274   BssLength      equ       BssEnd-BssStart       length of zeroed data needed to copy to Ram on bootup
                    3275   
                    3276   *********************************************************************************************************
                    3277   * Section for Heap
                    3278   *********************************************************************************************************
                    3279   
          0801 EF42 3280   heap           equ       *
0801EF42            3281                  align
          0800 0000

Assembly errors: 0

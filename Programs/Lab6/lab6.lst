680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 01 Apr 2019      Time: 15:08:11          Source: C:\M68KV6.0 - 640BY480\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS\PROGRAMS\LAB6\LAB6.SRC

                       1          section   code
                       2   ;********************************************************************************************************
                       3   ;                                               uC/OS-II
                       4   ;                                         The Real-Time Kernel
                       5   ;
                       6   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                       7   ;                                          All Rights Reserved
                       8   ;
                       9   ;
                      10   ;                                        IDE68K Specific boot code
                      11   ;
                      12   ;
                      13   ; File         : OS_BOOT.ASM
                      14   ; By           : PJ Davies to suit DE1 board
                      15   ;********************************************************************************************************
                      16   
                      17   ;********************************************************************************************************
                      18   ;                                               NOTES
                      19   ;
                      20   ; This is the "Board Support Package" or BSP for the DE1 board  It defines memory layout,
                      21   ; interrupt vectors and a few BIOS functions.
                      22   ;
                      23   ;********************************************************************************************************
                      24   
                      25   ;********************************************************************************************************
                      26   ;                                           REVISION HISTORY
                      27   ;
                      28   ; $Log$
                      29   ;
                      30   ;********************************************************************************************************
                      31   
          0000 0000   32   ROM        equ         $00000000       ; ROM starts at $00000000
          0800 0000   33   RAM        equ         $08000000       ; RAM starts at $08000000
          0001 0000   34   RAMsize    equ         $00010000       ; Size of RAM 64kbytes
                      35   
                      36   ;           option      S0              ; Generate S0 record in .hex file since Rom is at location 0
                      37   
00000000              38              org         ROM				; starting at location 0, generate the following constants
          0000 0000   39   begin_ROM  equ         *				; beginning of rom constant is 0
          0000 0000   40   code       equ         *				; code starts at 0
                      41   
                      42   
                      43   ;*******************************************************************************************************************
                      44   ; start of 68000 vector table (256 long word entries covering reset, interrupts, initial stack pointer etc)
                      45   ;*******************************************************************************************************************
                      46   
00000000  0801 0000   47   InitialSP       dc.l __stack          ;initial supervisor state stack pointer(stack decrements first before being used
00000004  0000 0400   48   InitialPC       dc.l startup             ;address of 1st instruction of program after a reset
00000008  0000 05D2   49   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 05E4   50   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 05F6   51   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0608   52   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 061A   53   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 062C   54   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 063E   55   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0650   56   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0662   57   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 0674   58   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 0686   59   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 0686   60   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 0686   61   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 0686   62   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 0686   63   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 0686   64   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 0686   65   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 0686   66   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 0686   67   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 0686   68   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 0686   69   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 0686   70   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 0686   71   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      72   *
                      73   *
00000064  0000 0434   74   Level1IRQ       dc.l Level1RamISR
00000068  0000 0446   75   Level2IRQ       dc.l Level2RamISR
0000006C  0800 0164   76   Level3IRQ       dc.l _OSTickISR        ;Level3RamISR (Timer Tick) - ISR needs to be installed at run time for DE1 timer
00000070  0000 046A   77   Level4IRQ       dc.l Level4RamISR
00000074  0000 047C   78   Level5IRQ       dc.l Level5RamISR
00000078  0000 048E   79   Level6IRQ       dc.l Level6RamISR
0000007C  0000 04A0   80   Level7IRQ       dc.l Level7RamISR
                      81   *
                      82   *
00000080  0800 0058   83   Trap0           dc.l _OSCtxSw           ; User installed trap handler (Context Switch) - invoked by a trap0 instruction contained in os_cpu.h file
00000084  0000 04C4   84   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 04D6   85   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 04E8   86   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 04FA   87   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 050C   88   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 051E   89   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 0530   90   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 0542   91   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 0554   92   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 0566   93   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 0578   94   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 058A   95   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 059C   96   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 05AE   97   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 05C0   98   Trap15          dc.l Trap15RamISR       ; User installed trap handler (System call - but a legacy from running on IDE68k simulator)
                      99   
                     100   
                     101   *
                     102   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                     103   *
                     104   
00000400             105                   org       $00000400    ; end of vector table/start of code
                     106   
                     107              ; this is where the program code initially begins (see table avove vector #1 - initial Program counter value is defined as "startup"
                     108              ; here we can write some boot code and carry out some memory/constant initialisation
                     109              ; add your own code here or you can do it later in C (try to keep assembler code to a minimum)
                     110   startup:
00000400  41F9 0800  111              lea         bss,A0			; put start address of unitialised variables into register A0
00000404  000C      
00000406  4218       112              clr.b       (A0)+           ; set bss section (unitialised variables) to zero (clear the byte pointed to by A0 and then increment A0)
00000408  B1FC 0800  113              cmp.l       #heap,A0			; compare A0 with immediate value defined by heap
0000040C  10FA      
0000040E  65F6       114              bcs.s       *-8				; if not there yet go back 8 bytes to clr.b instruction
00000410  23FC FFFF  115              move.l      #-1,__ungetbuf  ; initialose ungetbuffer for keyboard input (don't remove this otherwise scanf() etc will not work)
00000414  FFFF 0800 
00000418  0000      
                     116              ;
0000041A  23FC 0800  117              move.l      #(end_ROM-begin_ROM),__romsize	; initialise some values related to rom and ram limits (needed by OS)
0000041E  5950 0800 
00000422  00D8      
00000424  23FC 0000  118              move.l      #(end_RAM-begin_RAM),__ramsize
00000428  10FA 0800 
0000042C  00DC      
                     119              jsr         _main							; now call main() from our C program (yeah!!!!)
********  **** ****  Error: Undefined or illegal symbol
                     120   
                     121   *********************************************************************************************************
                     122   * Code to call Ram Based Interrupt handler and other exeception handler code
                     123   *********************************************************************************************************
00000434  48E7 FFFE  124   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000438  2079 0800  125                   move.l    VL1IRQ,a0               get ram based address into a0
0000043C  0070      
0000043E  4E90       126                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000440  4CDF 7FFF  127                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000444  4E73       128                   rte
00000446  48E7 FFFE  129   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000044A  2079 0800  130                   move.l    VL2IRQ,a0               get ram based address into a0
0000044E  0074      
00000450  4E90       131                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000452  4CDF 7FFF  132                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000456  4E73       133                   rte
00000458  48E7 FFFE  134   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000045C  2079 0800  135                   move.l    VL3IRQ,a0               get ram based address into a0
00000460  0078      
00000462  4E90       136                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000464  4CDF 7FFF  137                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000468  4E73       138                   rte
0000046A  48E7 FFFE  139   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000046E  2079 0800  140                   move.l    VL4IRQ,a0               get ram based address into a0
00000472  007C      
00000474  4E90       141                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000476  4CDF 7FFF  142                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000047A  4E73       143                   rte
                     144   
0000047C  48E7 FFFE  145   Level5RamISR    movem.l   d0-d7/a0-a6,-(SP)        save everything not automatically saved
00000480  2079 0800  146                   move.l    VL5IRQ,a0               get ram based address into a0
00000484  0080      
00000486  4E90       147                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000488  4CDF 7FFF  148                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000048C  4E73       149                   rte
                     150   
0000048E  48E7 FFFE  151   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000492  2079 0800  152                   move.l    VL6IRQ,a0               get ram based address into a0
00000496  0084      
00000498  4E90       153                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000049A  4CDF 7FFF  154                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000049E  4E73       155                   rte
                     156   
000004A0  48E7 FFFE  157   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004A4  2079 0800  158                   move.l    VL7IRQ,a0               get ram based address into a0
000004A8  0088      
000004AA  4E90       159                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004AC  4CDF 7FFF  160                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004B0  4E73       161                   rte
                     162   
                     163   
                     164   ********************************************************************************************************
                     165   * Ram based Trap handler and other exeception handler code
                     166   *********************************************************************************************************
                     167   
000004B2  48E7 FFFE  168   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B6  2079 0800  169                   move.l    VTrap0,a0                get ram based address into a0
000004BA  008C      
000004BC  4E90       170                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004BE  4CDF 7FFF  171                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004C2  4E73       172                   rte
                     173   
000004C4  48E7 FFFE  174   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C8  2079 0800  175                   move.l    VTrap1,a0                get ram based address into a0
000004CC  0090      
000004CE  4E90       176                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004D0  4CDF 7FFF  177                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004D4  4E73       178                   rte
                     179   
000004D6  48E7 FFFE  180   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004DA  2079 0800  181                   move.l    VTrap2,a0                get ram based address into a0
000004DE  0094      
000004E0  4E90       182                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004E2  4CDF 7FFF  183                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E6  4E73       184                   rte
                     185   
000004E8  48E7 FFFE  186   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004EC  2079 0800  187                   move.l    VTrap3,a0                get ram based address into a0
000004F0  0098      
000004F2  4E90       188                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004F4  4CDF 7FFF  189                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004F8  4E73       190                   rte
                     191   
000004FA  48E7 FFFE  192   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004FE  2079 0800  193                   move.l    VTrap4,a0                get ram based address into a0
00000502  009C      
00000504  4E90       194                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000506  4CDF 7FFF  195                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000050A  4E73       196                   rte
                     197   
0000050C  48E7 FFFE  198   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000510  2079 0800  199                   move.l    VTrap5,a0                get ram based address into a0
00000514  00A0      
00000516  4E90       200                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000518  4CDF 7FFF  201                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000051C  4E73       202                   rte
                     203   
0000051E  48E7 FFFE  204   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000522  2079 0800  205                   move.l    VTrap6,a0                get ram based address into a0
00000526  00A4      
00000528  4E90       206                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000052A  4CDF 7FFF  207                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000052E  4E73       208                   rte
                     209   
00000530  48E7 FFFE  210   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000534  2079 0800  211                   move.l    VTrap7,a0                get ram based address into a0
00000538  00A8      
0000053A  4E90       212                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000053C  4CDF 7FFF  213                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000540  4E73       214                   rte
                     215   
00000542  48E7 FFFE  216   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000546  2079 0800  217                   move.l    VTrap8,a0                get ram based address into a0
0000054A  00AC      
0000054C  4E90       218                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000054E  4CDF 7FFF  219                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000552  4E73       220                   rte
                     221   
00000554  48E7 FFFE  222   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000558  2079 0800  223                   move.l    VTrap9,a0                get ram based address into a0
0000055C  00B0      
0000055E  4E90       224                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000560  4CDF 7FFF  225                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000564  4E73       226                   rte
                     227   
00000566  48E7 FFFE  228   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000056A  2079 0800  229                   move.l    VTrap10,a0                get ram based address into a0
0000056E  00B4      
00000570  4E90       230                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000572  4CDF 7FFF  231                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000576  4E73       232                   rte
                     233   
00000578  48E7 FFFE  234   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000057C  2079 0800  235                   move.l    VTrap11,a0                get ram based address into a0
00000580  00B8      
00000582  4E90       236                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000584  4CDF 7FFF  237                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000588  4E73       238                   rte
                     239   
0000058A  48E7 FFFE  240   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000058E  2079 0800  241                   move.l    VTrap12,a0                get ram based address into a0
00000592  00BC      
00000594  4E90       242                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000596  4CDF 7FFF  243                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000059A  4E73       244                   rte
                     245   
0000059C  48E7 FFFE  246   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005A0  2079 0800  247                   move.l    VTrap13,a0                get ram based address into a0
000005A4  00C0      
000005A6  4E90       248                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005A8  4CDF 7FFF  249                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005AC  4E73       250                   rte
                     251   
000005AE  48E7 FFFE  252   Trap14RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005B2  2079 0800  253                   move.l    VTrap14,a0              get ram based address into a0
000005B6  00C4      
000005B8  4E90       254                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005BA  4CDF 7FFF  255                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005BE  4E73       256                   rte
                     257   
000005C0  48E7 FFFE  258   Trap15RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005C4  2079 0800  259                   move.l    VTrap15,a0              get ram based address into a0
000005C8  00C8      
000005CA  4E90       260                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005CC  4CDF 7FFF  261                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005D0  4E73       262                   rte
                     263   
                     264   *********************************************************************************************************
                     265   *Default exception handler for everything without a specific handler
                     266   *********************************************************************************************************
                     267   
000005D2  48E7 FFFE  268   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005D6  2079 0800  269                   move.l    VBusError,a0            get ram based address into a0
000005DA  0014      
000005DC  4E90       270                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005DE  4CDF 7FFF  271                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005E2  4E73       272                   rte
000005E4  48E7 FFFE  273   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005E8  2079 0800  274                   move.l    VAddressError,a0        get ram based address into a0
000005EC  0018      
000005EE  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005F0  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005F4  4E73       277                   rte
000005F6  48E7 FFFE  278   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005FA  2079 0800  279                   move.l    VIllegalInstr,a0        get ram based address into a0
000005FE  001C      
00000600  4E90       280                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000602  4CDF 7FFF  281                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000606  4E73       282                   rte
00000608  48E7 FFFE  283   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000060C  2079 0800  284                   move.l    VDividebyZero,a0        get ram based address into a0
00000610  0020      
00000612  4E90       285                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000614  4CDF 7FFF  286                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000618  4E73       287                   rte
0000061A  48E7 FFFE  288   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000061E  2079 0800  289                   move.l    VCheck,a0               get ram based address into a0
00000622  0024      
00000624  4E90       290                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000626  4CDF 7FFF  291                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000062A  4E73       292                   rte
0000062C  48E7 FFFE  293   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000630  2079 0800  294                   move.l    VTrapV,a0               get ram based address into a0
00000634  0028      
00000636  4E90       295                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000638  4CDF 7FFF  296                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000063C  4E73       297                   rte
0000063E  48E7 FFFE  298   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000642  2079 0800  299                   move.l    VPrivilege,a0           get ram based address into a0
00000646  002C      
00000648  4E90       300                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000064A  4CDF 7FFF  301                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000064E  4E73       302                   rte
00000650  48E7 FFFE  303   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000654  2079 0800  304                   move.l    VTrace,a0               get ram based address into a0
00000658  0030      
0000065A  4E90       305                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000065C  4CDF 7FFF  306                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000660  4E73       307                   rte
00000662  48E7 FFFE  308   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000666  2079 0800  309                   move.l    VLine1010emul,a0        get ram based address into a0
0000066A  0034      
0000066C  4E90       310                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000066E  4CDF 7FFF  311                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000672  4E73       312                   rte
00000674  48E7 FFFE  313   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000678  2079 0800  314                   move.l    VLine1111emul,a0        get ram based address into a0
0000067C  0038      
0000067E  4E90       315                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000680  4CDF 7FFF  316                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000684  4E73       317                   rte
                     318   
                     319   ; at the moment all these exceptions cause the processor to stop (or at least loop) with no further application processing
                     320   E_Unnas1
                     321   E_Unnas2
                     322   E_Unnas3
                     323   E_UnitI
                     324   E_Unnas4
                     325   E_Unnas5
                     326   E_Unnas6
                     327   E_Unnas7
                     328   E_Unnas8
                     329   E_Unnas9
                     330   E_Unnas10
                     331   E_Unnas11
                     332   E_Spuri
00000686  60FE       333   _stop            bra _stop             ; stop
                     334   
                     335   __exit:                                ; exit() and _exit()functions
                     336   
00000688  6000 FD76  337              bra         startup         ; restart program if exit() called
                     338   
                     339   ; I don't think these two time related functions are relevant anymore and neither is Trap 15 handler
                     340   ; but they are left in for the moment until I am certain they can be removed
                     341   __time:
0000068C  4E4F       342              trap        #15             ; IDE68K system call 40 -> GETTIME
0000068E  0028       343              dc.w        40              ; D0 = seconds since Jan 1, 1970, 00:00:00 hr UTC
00000690  4E75       344              rts
                     345   
                     346   __localoffset:
00000692  4E4F       347              trap        #15             ; IDE68K system call 41 -> LOCALOFFSET
00000694  0029       348              dc.w        41              ; D0 = offset in seconds between UTC and local time
00000696  4E75       349              rts
                     350   
                     351   **********************************************************************************************************
                     352   * CSTART.ASM  -  C startup-code
                     353   *
                     354   *          Initialises the system prior to running the users main() program
                     355   *
                     356   *          1) Sets up the user program stack pointer
                     357   *          2) Switches to User mode in the 68000
                     358   *          3) Enables All Interrupts 1-7 on 68000
                     359   *          4) Copies all initialised C program variables from Rom to Ram prior to running main()
                     360   *
                     361   **********************************************************************************************************
00000698             362                   align
                     363   
                     364   
                     365   **********************************************************************************************************
                     366   * The Following ORG Statement marks the address of the start of the this CStart Program
                     367   *
                     368   * The debug Monitor and Flash Load and Program routines assume your program lives here
                     369   **********************************************************************************************************
08000000             370                   org       $08000000
08000000  46FC 2000  371   start:          move.w    #$2000,SR             clear interrupts to enable all, move to supervisor mode
                     372   
                     373   ******************************************************************************************
                     374   * Set unitialised global variables to 0 at startup
                     375   ******************************************************************************************
08000004  207C 0800  376   mainloop        movea.l   #BssStart,a0          point a0 to the start of the initialised data section held in ROM
08000008  00E0      
0800000A  203C 0000  377                   move.l    #BssLength,d0         figure out how many bytes of C program variables data to copy
0800000E  101A      
08000010  6700 0024  378                   beq       go_main               if no data to copy go straight to program
08000014  10FC 0000  379   Zeroinit        move.b    #0,(a0)+              copy the C program initialise variables from rom to ram
08000018  5380       380                   subq.l    #1,d0
0800001A  66F8       381                   bne       Zeroinit
                     382   
                     383   *******************************************************************************************
                     384   * last minute initialisation before calling main
                     385   *******************************************************************************************
                     386   
0800001C  23FC FFFF  387                   move.l    #-1,__ungetbuf         required for use of scanf() etc in C programs
08000020  FFFF 0800 
08000024  0000      
08000026  42B9 0800  388                   clr.l     __allocp               used by malloc() in C
0800002A  0004      
0800002C  23FC 0800  389                   move.l    #heap,__heap           pointer to free memory
08000030  10FA 0800 
08000034  0008      
                     390   go_main         jsr       _main
********  **** ****  Error: Undefined or illegal symbol
0800003C  60C2       391                   bra       start
                     392   
                     393   ;********************************************************************************************************
                     394   ;                                               uC/OS-II
                     395   ;                                         The Real-Time Kernel
                     396   ;
                     397   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                     398   ;                                          All Rights Reserved
                     399   ;
                     400   ;
                     401   ;                                     68000 Specific assembly code
                     402   ;                                               IDE68K
                     403   ;
                     404   ; File         : OS_CPU_A.ASM
                     405   ; By           : Jean J. Labrosse, Peter J. Fondse
                     406   ;********************************************************************************************************
                     407   
                     408   
                     409   ;********************************************************************************************************
                     410   ;                                            REVISION HISTORY
                     411   ;
                     412   ; $Log$
                     413   ;
                     414   ;********************************************************************************************************
                     415   
                     416   
                     417   ;********************************************************************************************************
                     418   ;                                          PUBLIC DECLARATIONS
                     419   ;********************************************************************************************************
                     420   
                     421   
                     422   ;********************************************************************************************************
                     423   ;                                         EXTERNAL DECLARATIONS
                     424   ;********************************************************************************************************
                     425   
                     426   
                     427   ;********************************************************************************************************
                     428   ;                               START HIGHEST PRIORITY TASK READY-TO-RUN
                     429   ;
                     430   ; Description : This function is called by OSStart() to start the highest priority task that was created
                     431   ;               by your application before calling OSStart().
                     432   ;
                     433   ; Arguments   : none
                     434   ;
                     435   ; Note(s)     : 1) The stack frame is assumed to look as follows:
                     436   ;
                     437   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)        Low Memory
                     438   ;                                            +  2         D0    (L)
                     439   ;                                            +  4         D1    (H)
                     440   ;                                            +  6         D1    (L)
                     441   ;                                            +  8         D2    (H)
                     442   ;                                            + 10         D2    (L)
                     443   ;                                            + 12         D3    (H)
                     444   ;                                            + 14         D3    (L)
                     445   ;                                            + 16         D4    (H)
                     446   ;                                            + 18         D4    (L)
                     447   ;                                            + 20         D5    (H)
                     448   ;                                            + 22         D5    (L)
                     449   ;                                            + 24         D6    (H)
                     450   ;                                            + 26         D6    (L)
                     451   ;                                            + 28         D7    (H)
                     452   ;                                            + 30         D7    (L)
                     453   ;                                            + 32         A0    (H)
                     454   ;                                            + 34         A0    (L)
                     455   ;                                            + 36         A1    (H)
                     456   ;                                            + 38         A1    (L)
                     457   ;                                            + 40         A2    (H)
                     458   ;                                            + 42         A2    (L)
                     459   ;                                            + 44         A3    (H)
                     460   ;                                            + 46         A3    (L)
                     461   ;                                            + 48         A4    (H)
                     462   ;                                            + 50         A4    (L)
                     463   ;                                            + 52         A5    (H)
                     464   ;                                            + 54         A5    (L)
                     465   ;                                            + 56         A6    (H)
                     466   ;                                            + 58         A6    (L)
                     467   ;                                            + 60         OS_INITIAL_SR
                     468   ;                                            + 62         task  (H)
                     469   ;                                            + 64         task  (L)
                     470   ;                                            + 66         task  (H)
                     471   ;                                            + 68         task  (L)
                     472   ;                                            + 70         pdata (H)
                     473   ;                                            + 72         pdata (L)        High Memory
                     474   ;
                     475   ;               2) OSStartHighRdy() MUST:
                     476   ;                      a) Call OSTaskSwHook() then,
                     477   ;                      b) Set OSRunning to TRUE,
                     478   ;                      c) Switch to the highest priority task.
                     479   ;********************************************************************************************************
                     480   
                     481   ; Pseudocode for OSStartHighRdy:
                     482   ;          Call OSTaskSwHook();
                     483   ;          Set OSRunning to 1;
                     484   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     485   ;          POP all the processor registers from the stack;
                     486   ;          Execute a Return from Interrupt instruction;
                     487   
                     488   
                     489   _OSStartHighRdy:
0800003E  4EB9 0800  490           jsr       _OSTaskSwHook            ; Invoke user defined context switch hook
08000042  0274      
08000044  5239 0800  491           addq.b    #1,_OSRunning            ; Indicate that we are multitasking
08000048  0324      
0800004A  2079 0800  492           move.l    _OSTCBHighRdy,A0         ; Point to TCB of highest priority task ready to run
0800004E  0434      
08000050  2E50       493           move.l    (A0),A7                  ; Get the stack pointer of the task to resume
08000052  4CDF 7FFF  494           movem.l   (A7)+,A0-A6/D0-D7        ; Restore the CPU registers
08000056  4E73       495           rte                                ; Run task
                     496   
                     497   ;********************************************************************************************************
                     498   ;                                       TASK LEVEL CONTEXT SWITCH
                     499   ;
                     500   ; Description : This function is called when a task makes a higher priority task ready-to-run.
                     501   ;               Called with TRAP #0 instruction (see vector table entry at address 0x0080 in boot.asm)
                     502   ;
                     503   ; Arguments   : none
                     504   ;
                     505   ; Note(s)     : 1) Upon entry,
                     506   ;                  OSTCBCur     points to the OS_TCB of the task to suspend
                     507   ;                  OSTCBHighRdy points to the OS_TCB of the task to resume
                     508   ;
                     509   ;               2) The stack frame of the task to suspend looks as follows (the registers for
                     510   ;                  task to suspend need to be saved):
                     511   ;
                     512   ;                                         SP +  0  ---->  SR                   Low Memory
                     513   ;                                            +  2         PC of task  (H)
                     514   ;                                            +  4         PC of task  (L)      High Memory
                     515   ;
                     516   ;               3) The stack frame of the task to resume looks as follows:
                     517   ;
                     518   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)           Low Memory
                     519   ;                                            +  2         D0    (L)
                     520   ;                                            +  4         D1    (H)
                     521   ;                                            +  6         D1    (L)
                     522   ;                                            +  8         D2    (H)
                     523   ;                                            + 10         D2    (L)
                     524   ;                                            + 12         D3    (H)
                     525   ;                                            + 14         D3    (L)
                     526   ;                                            + 16         D4    (H)
                     527   ;                                            + 18         D4    (L)
                     528   ;                                            + 20         D5    (H)
                     529   ;                                            + 22         D5    (L)
                     530   ;                                            + 24         D6    (H)
                     531   ;                                            + 26         D6    (L)
                     532   ;                                            + 28         D7    (H)
                     533   ;                                            + 30         D7    (L)
                     534   ;                                            + 32         A0    (H)
                     535   ;                                            + 34         A0    (L)
                     536   ;                                            + 36         A1    (H)
                     537   ;                                            + 38         A1    (L)
                     538   ;                                            + 40         A2    (H)
                     539   ;                                            + 42         A2    (L)
                     540   ;                                            + 44         A3    (H)
                     541   ;                                            + 46         A3    (L)
                     542   ;                                            + 48         A4    (H)
                     543   ;                                            + 50         A4    (L)
                     544   ;                                            + 52         A5    (H)
                     545   ;                                            + 54         A5    (L)
                     546   ;                                            + 56         A6    (H)
                     547   ;                                            + 58         A6    (L)
                     548   ;                                            + 60         OS_INITIAL_SR       (See OS_CPU.H)
                     549   ;                                            + 62         PC of task  (H)
                     550   ;                                            + 64         PC of task  (L)     High Memory
                     551   ;********************************************************************************************************
                     552   
                     553   ; Pseudocode for OSCtxSw:
                     554   ; OSCtxSw:
                     555   ; PUSH processor registers onto the current task’s stack;
                     556   ; Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     557   ; Call OSTaskSwHook(); (1)
                     558   ; OSTCBCur = OSTCBHighRdy;
                     559   ; OSPrioCur = OSPrioHighRdy; (2)
                     560   ; Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     561   ; POP all the processor registers from the stack;
                     562   ; Execute a Return from Interrupt instruction;
                     563   
                     564   _OSCtxSw:
08000058  48E7 FFFE  565           movem.l   A0-A6/D0-D7,-(A7)              ; Save the registers of the current task
0800005C  2079 0800  566           move.l    _OSTCBCur,A0                   ; Save the stack pointer in the suspended task TCB
08000060  042C      
08000062  208F       567           move.l    A7,(A0)
08000064  4EB9 0800  568           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
08000068  0274      
0800006A  13F9 0800  569           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
0800006E  0318 0800 
08000072  0316      
08000074  2079 0800  570           move.l    _OSTCBHighRdy,A0               ; OSTCBCur  = OSTCBHighRdy
08000078  0434      
0800007A  23C8 0800  571           move.l    A0,_OSTCBCur
0800007E  042C      
08000080  2E50       572           move.l    (A0),A7                        ; Get the stack pointer of the task to resume
08000082  4CDF 7FFF  573           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
08000086  4E73       574           rte                                      ; Run task
                     575   
                     576   ;********************************************************************************************************
                     577   ;                                      INTERRUPT LEVEL CONTEXT SWITCH
                     578   ;
                     579   ; Description : This function is called from OSIntExit() in OS_CORE.C
                     580   ;               Provided for backward compatibility.
                     581   ;               The ISR MUST NOT call OSIntExit(), but should jump to OSIntExit68K().
                     582   ;********************************************************************************************************
                     583   
                     584   ; Pseudocode for OSIntCtxSw
                     585   ; OSIntCtxSw
                     586   ;          Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     587   ;          Call OSTaskSwHook(); (1)
                     588   ;          OSTCBCur = OSTCBHighRdy;
                     589   ;          OSPrioCur = OSPrioHighRdy; (2)
                     590   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     591   ;          POP all the processor registers from the stack;
                     592   ;          Execute a Return from Interrupt instruction;
                     593   
                     594   _OSIntCtxSw:
08000088  DFFC 0000  595           adda.l    #10,A7                         ; Adjust the stack (note this code is called as a subroutine by OS so extra copy of PC stored on stack - along with PC and SR - so adjust by 10 bytes to point to A6)
0800008C  000A      
0800008E  2279 0800  596           move.l    _OSTCBCur,A1                   ; Save the stack pointer in the suspended task TCB
08000092  042C      
08000094  228F       597           move.l    A7,(A1)
                     598   ;
08000096  4EB9 0800  599           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
0800009A  0274      
                     600   ;
0800009C  2279 0800  601           move.l    _OSTCBHighRdy,A1               ; OSTCBCur  = OSTCBHighRdy
080000A0  0434      
080000A2  23C9 0800  602           move.l    A1,_OSTCBCur
080000A6  042C      
080000A8  2E51       603           move.l    (A1),A7                        ; Get the stack pointer of the task to resume
                     604   ;
080000AA  13F9 0800  605           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
080000AE  0318 0800 
080000B2  0316      
080000B4  4CDF 7FFF  606           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
080000B8  4E73       607           rte                                      ; Run task
                     608   
                     609   ;********************************************************************************************************
                     610   ;                           INTERRUPT EXIT FUNCTION (IDE68K specific)
                     611   ;
                     612   ; Description : ISR's (written in Assembly) must directly JUMP to OSIntExit68K
                     613   ;
                     614   ; Notes       : You must NOT call OSIntExit() to exit an ISR with IDE68K, but JUMP to OSIntExit68K().
                     615   ;
                     616   ; Stack frame upon entry:
                     617   ;
                     618   ;                  SP +  0  ---->  D0    (H)
                     619   ;                     +  2         D0    (L)
                     620   ;                     +  4         D1    (H)
                     621   ;                     +  6         D1    (L)
                     622   ;                     +  8         D2    (H)
                     623   ;                     + 10         D2    (L)
                     624   ;                     + 12         D3    (H)
                     625   ;                     + 14         D3    (L)
                     626   ;                     + 16         D4    (H)
                     627   ;                     + 18         D4    (L)
                     628   ;                     + 20         D5    (H)
                     629   ;                     + 22         D5    (L)
                     630   ;                     + 24         D6    (H)
                     631   ;                     + 26         D6    (L)
                     632   ;                     + 28         D7    (H)
                     633   ;                     + 30         D7    (L)
                     634   ;                     + 32         A0    (H)
                     635   ;                     + 34         A0    (L)
                     636   ;                     + 36         A1    (H)
                     637   ;                     + 38         A1    (L)
                     638   ;                     + 40         A2    (H)
                     639   ;                     + 42         A2    (L)
                     640   ;                     + 44         A3    (H)
                     641   ;                     + 46         A3    (L)
                     642   ;                     + 48         A4    (H)
                     643   ;                     + 50         A4    (L)
                     644   ;                     + 52         A5    (H)
                     645   ;                     + 54         A5    (L)
                     646   ;                     + 56         A6    (H)
                     647   ;                     + 58         A6    (L)
                     648   ;                     + 60         Task or ISR's SR
                     649   ;                     + 62         PC of task  (H)
                     650   ;                     + 64         PC of task  (L)                   High Memory
                     651   ;********************************************************************************************************
                     652   
                     653   ; C Code for OSInterrupt exit taken from test book on OS example program 3.16 page 96/305
                     654   
                     655   ; void OSIntExit (void)
                     656   ; {
                     657   ;           OS_ENTER_CRITICAL();
                     658   ;           if ((--OSIntNesting | OSLockNesting) == 0) {
                     659   ;                       OSIntExitY = OSUnMapTbl[OSRdyGrp];
                     660   ;                       OSPrioHighRdy = (INT8U)((OSIntExitY << 3) + OSUnMapTbl[OSRdyTbl[OSIntExitY]]);
                     661   ;                       if (OSPrioHighRdy != OSPrioCur) {
                     662   ;                                       OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
                     663   ;                                       OSCtxSwCtr++;
                     664   ;                                       OSIntCtxSw();
                     665   ;                       }
                     666   ;           }
                     667   ;           OS_EXIT_CRITICAL();
                     668   ; }
                     669   
                     670   OSIntExit68K:
080000BA  5339 0800  671           subq.b    #1,_OSIntNesting              ; if (--OSIntNesting == 0)
080000BE  0312      
080000C0  6600 009C  672           bne       OSIntExit68K_1
080000C4  4A39 0800  673           tst.b     _OSLockNesting                ; if (OSLockNesting == 0)
080000C8  0314      
080000CA  6600 0092  674           bne       OSIntExit68K_1
                     675   
                     676   ;       re-enabling interrupts
080000CE  302F 003C  677           move.w    (60,A7),D0                    ; must be LAST nested ISR
080000D2  C07C 0700  678           and.w     #$0700,D0                     ; do we want to change S bit in SR
                     679   ;
080000D6  6600 0086  680           bne       OSIntExit68K_1
080000DA  41F9 0800  681           lea       _OSUnMapTbl,A0                ;  y = OSUnMapTbl[OSRdyGrp];
080000DE  5850      
080000E0  4280       682           clr.l     D0
080000E2  1039 0800  683           move.b    _OSRdyGrp,D0
080000E6  031A      
080000E8  1230 0800  684           move.b    0(A0,D0.L),D1                 ;  y in D1
                     685   ;
080000EC  41F9 0800  686           lea       _OSRdyTbl,A0                  ;  OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
080000F0  031C      
080000F2  4280       687           clr.l     D0
080000F4  1001       688           move.b    D1,D0
080000F6  41F0 0800  689           lea       0(A0,D0.L),A0
080000FA  4280       690           clr.l     D0
080000FC  1010       691           move.b    (A0),D0                       ;  OSRdyTbl[y] in D0
080000FE  41F9 0800  692           lea       _OSUnMapTbl,A0
08000102  5850      
08000104  41F0 0800  693           lea       0(A0,D0.L),A0                 ;  &OSUnMapTbl[OSRdyTbl[y]] in A0
08000108  1001       694           move.b    D1,D0
0800010A  E708       695           lsl.b     #3,D0                         ;  (y << 3) in D0
0800010C  D010       696           add.b     (A0),D0
0800010E  13C0 0800  697           move.b    D0,_OSPrioHighRdy
08000112  0318      
                     698   ;
08000114  B039 0800  699           cmp.b     _OSPrioCur,D0                 ;  if (OSPrioCur != OSPrioHighRdy) {
08000118  0316      
0800011A  6742       700           beq.s     OSIntExit68K_1
                     701   ;
0800011C  41F9 0800  702           lea       _OSTCBPrioTbl,A0              ;    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
08000120  043C      
08000122  4281       703           clr.l     D1
08000124  1200       704           move.b    D0,D1
08000126  E589       705           lsl.l     #2,D1
08000128  41F0 1800  706           lea       0(A0,D1.L),A0
0800012C  23D0 0800  707           move.l    (A0),_OSTCBHighRdy
08000130  0434      
                     708   ;
08000132  52B9 0800  709           addq.l    #1,_OSCtxSwCtr                ;    OSCtxSwCtr++;
08000136  00E2      
                     710   ;
08000138  2079 0800  711           move.l    _OSTCBCur,A0                  ;    Save the stack pointer in the suspended task TCB
0800013C  042C      
0800013E  208F       712           move.l    A7,(A0)
08000140  4EB9 0800  713           jsr       _OSTaskSwHook                 ;    Invoke user defined context switch hook
08000144  0274      
08000146  2079 0800  714           move.l    _OSTCBHighRdy,A0              ;    OSTCBCur  = OSTCBHighRdy
0800014A  0434      
0800014C  23C8 0800  715           move.l    A0,_OSTCBCur
08000150  042C      
08000152  13F9 0800  716           move.b    _OSPrioHighRdy,_OSPrioCur     ;    OSPrioCur = OSPrioHighRdy
08000156  0318 0800 
0800015A  0316      
0800015C  2E50       717           move.l    (A0),A7                       ;    Get the stack pointer of the task to resume
                     718   OSIntExit68K_1:
0800015E  4CDF 7FFF  719           movem.l   (A7)+,A0-A6/D0-D7             ;  Restore the CPU registers
08000162  4E73       720           rte                                     ;  Return to task or nested ISR
                     721   
                     722   ;********************************************************************************************************
                     723   ;                                           SYSTEM TICK ISR
                     724   ;
                     725   ; Description : This function is the ISR used to notify uC/OS-II that a system tick has occurred.
                     726   ;
                     727   ; Arguments   : none
                     728   ;
                     729   ; Notes       : 1) You MUST increment 'OSIntNesting' and NOT call OSIntEnter()
                     730   ;               2) You MUST save ALL the CPU registers as shown below
                     731   ;               3) You MUST JUMP to OSIntExit68K() instead of call the function.
                     732   ;********************************************************************************************************
                     733   
                     734   ; C Code for OSInterrupt exit taken from text book on OS example program
                     735   
                     736   ; void OSTickISR(void)
                     737   ; {
                     738   ;          Save processor registers;
                     739   ;          Call OSIntEnter() or increment OSIntNesting;
                     740   ;          Call OSTimeTick();
                     741   ;          Call OSIntExit();
                     742   ;          Restore processor registers;
                     743   ;          Execute a return from interrupt instruction;
                     744   ; }
                     745   
                     746   
                     747   _OSTickISR:
08000164  007C 0700  748           or.w      #$0700,SR                     ; Disable ALL interrupts
08000168  5239 0800  749           addq.b    #1,_OSIntNesting              ; OSIntNesting++;
0800016C  0312      
0800016E  48E7 FFFE  750           movem.l   A0-A6/D0-D7,-(A7)             ; Save the registers of the current task
                     751           ; call your ISR here to clear the tick interrupt
08000172  4EB9 0800  752           jsr       _Timer_ISR
08000176  5658      
                     753           ;
08000178  4EB9 0800  754           jsr       _OSTimeTick                   ; Call uC/OS-II's tick updating function
0800017C  08DA      
0800017E  6000 FF3A  755           bra       OSIntExit68K                  ; Exit ISR
                     756   ; C:\IDE68K\UCOSII\OS_CPU_C.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     757   ; /*
                     758   ; *********************************************************************************************************
                     759   ; *                                               uC/OS-II
                     760   ; *                                         The Real-Time Kernel
                     761   ; *
                     762   ; *                            (c) Copyright 2000, Jean J. Labrosse, Weston, FL
                     763   ; *                                          All Rights Reserved
                     764   ; *
                     765   ; *
                     766   ; *                                         68000 Specific C code
                     767   ; *                                                IDE68K
                     768   ; *
                     769   ; * File         : OS_CPU_C.C
                     770   ; * By           : Jean J. Labrosse
                     771   ; *********************************************************************************************************
                     772   ; */
                     773   ; #ifndef  OS_MASTER_FILE
                     774   ; #include <ucos_ii.h>
                     775   ; #endif
                     776   ; #include <Bios.h>
                     777   ; /*
                     778   ; *********************************************************************************************************
                     779   ; *                                           REVISION HISTORY
                     780   ; *
                     781   ; * $Log$
                     782   ; *
                     783   ; *********************************************************************************************************
                     784   ; */
                     785   ; #if OS_TMR_EN > 0
                     786   ; INT8U OSTmrTickCtr;
                     787   ; #endif
                     788   ; /*$PAGE*/
                     789   ; /*
                     790   ; *********************************************************************************************************
                     791   ; *                                        INITIALIZE A TASK'S STACK
                     792   ; *
                     793   ; * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
                     794   ; *              stack frame of the task being created.  This function is highly processor specific.
                     795   ; *
                     796   ; * Arguments  : task          is a pointer to the task code
                     797   ; *
                     798   ; *              pdata         is a pointer to a user supplied data area that will be passed to the task
                     799   ; *                            when the task first executes.
                     800   ; *
                     801   ; *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
                     802   ; *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
                     803   ; *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
                     804   ; *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
                     805   ; *                            of the stack.
                     806   ; *
                     807   ; *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
                     808   ; *                            (see uCOS_II.H for OS_TASK_OPT_???).
                     809   ; *
                     810   ; * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
                     811   ; *              been placed on the stack in the proper order.
                     812   ; *
                     813   ; * Note(s)    : 1) The initial value of the Status Register (SR) is OS_INITIAL_SR sets the 68xxx processor
                     814   ; *                 to run in SUPERVISOR mode.  It is assumed that all uC/OS-II tasks run in supervisor
                     815   ; *                 mode.
                     816   ; *              2) You can pass the above options in the 'opt' argument.  You MUST only use the upper
                     817   ; *                 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make changes
                     818   ; *                 to the code below, you will need to ensure that it doesn't affect the behaviour of
                     819   ; *                 OSTaskIdle() and OSTaskStat().
                     820   ; *              3) Registers are initialized to make them easy to differentiate with a debugger.
                     821   ; *********************************************************************************************************
                     822   ; */
                     823   ; OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *ptos, INT16U opt)
                     824   ; {
                     825   _OSTaskStkInit:
08000182  4E56 0000  826          link      A6,#0
08000186  48E7 3000  827          movem.l   D2/D3,-(A7)
                     828   ; INT32U  *pstk32;
                     829   ; INT16U  *pstk16;
                     830   ; opt       = opt;                                  /* 'opt' is not used, prevent warning            */
                     831   ; /* Load stack pointer and align on 32-bit bound  */
                     832   ; pstk32    = (INT32U *)((INT32U)ptos & 0xFFFFFFFCL);
0800018A  202E 0010  833          move.l    16(A6),D0
0800018E  C0BC 7FFF  834          and.l     #2147483647,D0
08000192  FFFF      
08000194  2400       835          move.l    D0,D2
                     836   ; /* -- SIMULATE CALL TO FUNCTION WITH ARGUMENT -- */
                     837   ; *--pstk32 = (INT32U)pdata;                        /*    pdata                                      */
08000196  5982       838          subq.l    #4,D2
08000198  2042       839          move.l    D2,A0
0800019A  20AE 000C  840          move.l    12(A6),(A0)
                     841   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
0800019E  5982       842          subq.l    #4,D2
080001A0  2042       843          move.l    D2,A0
080001A2  20AE 0008  844          move.l    8(A6),(A0)
                     845   ; /* ------ SIMULATE INTERRUPT STACK FRAME ------- */
                     846   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
080001A6  5982       847          subq.l    #4,D2
080001A8  2042       848          move.l    D2,A0
080001AA  20AE 0008  849          move.l    8(A6),(A0)
                     850   ; pstk16    = (INT16U *)pstk32;                     /* Switch to 16-bit wide stack                   */
080001AE  2602       851          move.l    D2,D3
                     852   ; *--pstk16 = (INT16U)OS_INITIAL_SR;                /*    Initial Status Register value for the task */
080001B0  5583       853          subq.l    #2,D3
080001B2  2043       854          move.l    D3,A0
080001B4  30BC 2000  855          move.w    #8192,(A0)
                     856   ; pstk32    = (INT32U *)pstk16;                     /* Switch to 32-bit wide stack                   */
080001B8  2403       857          move.l    D3,D2
                     858   ; /* ------- SAVE ALL PROCESSOR REGISTERS -------- */
                     859   ; *--pstk32 = (INT32U)0x00A600A6L;                  /* Register A6                                   */
080001BA  5982       860          subq.l    #4,D2
080001BC  2042       861          move.l    D2,A0
080001BE  20BC 00A6  862          move.l    #10879142,(A0)
080001C2  00A6      
                     863   ; *--pstk32 = (INT32U)0x00A500A5L;                  /* Register A5                                   */
080001C4  5982       864          subq.l    #4,D2
080001C6  2042       865          move.l    D2,A0
080001C8  20BC 00A5  866          move.l    #10813605,(A0)
080001CC  00A5      
                     867   ; *--pstk32 = (INT32U)0x00A400A4L;                  /* Register A4                                   */
080001CE  5982       868          subq.l    #4,D2
080001D0  2042       869          move.l    D2,A0
080001D2  20BC 00A4  870          move.l    #10748068,(A0)
080001D6  00A4      
                     871   ; *--pstk32 = (INT32U)0x00A300A3L;                  /* Register A3                                   */
080001D8  5982       872          subq.l    #4,D2
080001DA  2042       873          move.l    D2,A0
080001DC  20BC 00A3  874          move.l    #10682531,(A0)
080001E0  00A3      
                     875   ; *--pstk32 = (INT32U)0x00A200A2L;                  /* Register A2                                   */
080001E2  5982       876          subq.l    #4,D2
080001E4  2042       877          move.l    D2,A0
080001E6  20BC 00A2  878          move.l    #10616994,(A0)
080001EA  00A2      
                     879   ; *--pstk32 = (INT32U)0x00A100A1L;                  /* Register A1                                   */
080001EC  5982       880          subq.l    #4,D2
080001EE  2042       881          move.l    D2,A0
080001F0  20BC 00A1  882          move.l    #10551457,(A0)
080001F4  00A1      
                     883   ; *--pstk32 = (INT32U)0x00A000A0L;                  /* Register A0                                   */
080001F6  5982       884          subq.l    #4,D2
080001F8  2042       885          move.l    D2,A0
080001FA  20BC 00A0  886          move.l    #10485920,(A0)
080001FE  00A0      
                     887   ; *--pstk32 = (INT32U)0x00D700D7L;                  /* Register D7                                   */
08000200  5982       888          subq.l    #4,D2
08000202  2042       889          move.l    D2,A0
08000204  20BC 00D7  890          move.l    #14090455,(A0)
08000208  00D7      
                     891   ; *--pstk32 = (INT32U)0x00D600D6L;                  /* Register D6                                   */
0800020A  5982       892          subq.l    #4,D2
0800020C  2042       893          move.l    D2,A0
0800020E  20BC 00D6  894          move.l    #14024918,(A0)
08000212  00D6      
                     895   ; *--pstk32 = (INT32U)0x00D500D5L;                  /* Register D5                                   */
08000214  5982       896          subq.l    #4,D2
08000216  2042       897          move.l    D2,A0
08000218  20BC 00D5  898          move.l    #13959381,(A0)
0800021C  00D5      
                     899   ; *--pstk32 = (INT32U)0x00D400D4L;                  /* Register D4                                   */
0800021E  5982       900          subq.l    #4,D2
08000220  2042       901          move.l    D2,A0
08000222  20BC 00D4  902          move.l    #13893844,(A0)
08000226  00D4      
                     903   ; *--pstk32 = (INT32U)0x00D300D3L;                  /* Register D3                                   */
08000228  5982       904          subq.l    #4,D2
0800022A  2042       905          move.l    D2,A0
0800022C  20BC 00D3  906          move.l    #13828307,(A0)
08000230  00D3      
                     907   ; *--pstk32 = (INT32U)0x00D200D2L;                  /* Register D2                                   */
08000232  5982       908          subq.l    #4,D2
08000234  2042       909          move.l    D2,A0
08000236  20BC 00D2  910          move.l    #13762770,(A0)
0800023A  00D2      
                     911   ; *--pstk32 = (INT32U)0x00D100D1L;                  /* Register D1                                   */
0800023C  5982       912          subq.l    #4,D2
0800023E  2042       913          move.l    D2,A0
08000240  20BC 00D1  914          move.l    #13697233,(A0)
08000244  00D1      
                     915   ; *--pstk32 = (INT32U)0x00D000D0L;                  /* Register D0                                   */
08000246  5982       916          subq.l    #4,D2
08000248  2042       917          move.l    D2,A0
0800024A  20BC 00D0  918          move.l    #13631696,(A0)
0800024E  00D0      
                     919   ; return ((OS_STK *)pstk32);                        /* Return pointer to new top-of-stack            */
08000250  2002       920          move.l    D2,D0
08000252  4CDF 000C  921          movem.l   (A7)+,D2/D3
08000256  4E5E       922          unlk      A6
08000258  4E75       923          rts
                     924   ; }
                     925   ; /*$PAGE*/
                     926   ; /*
                     927   ; *********************************************************************************************************
                     928   ; *                                             GET ISR VECTOR
                     929   ; *
                     930   ; * Description: This function is called to get the address of the exception handler specified by 'vect'.
                     931   ; *              It is assumed that the VBR (Vector Base Register) is set to 0x00000000 (Not an issue with 68000 as VBR is always fixed at 0, but other 68k derivaties allowed VBR to be relocated - e.g. 68020).
                     932   ; *
                     933   ; * Arguments  : vect     is the vector number
                     934   ; *
                     935   ; * Note(s)    : 1) Interrupts are disabled during this call
                     936   ; *              2) It is assumed that the VBR (Vector Base Register) is set to 0x00000000.
                     937   ; *********************************************************************************************************
                     938   ; */
                     939   ; /*$PAGE*/
                     940   ; #if OS_CPU_HOOKS_EN
                     941   ; /*
                     942   ; *********************************************************************************************************
                     943   ; *                                       OS INITIALIZATION HOOK
                     944   ; *                                            (BEGINNING)
                     945   ; *
                     946   ; * Description: This function is called by OSInit() at the beginning of OSInit(). Uou can use it to initialise
                     947   ; *              Your board hardware (it could be done somewhere else too, but this is a convenient place)
                     948   ; *
                     949   ; * Arguments  : none
                     950   ; *
                     951   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                     952   ; *********************************************************************************************************
                     953   ; */
                     954   ; void OSInitHookBegin(void)
                     955   ; {
                     956   _OSInitHookBegin:
0800025A  4E75       957          rts
                     958   ; }
                     959   ; /*
                     960   ; *********************************************************************************************************
                     961   ; *                                       OS INITIALIZATION HOOK
                     962   ; *                                               (END)
                     963   ; *
                     964   ; * Description: This function is called by OSInit() at the end of OSInit().
                     965   ; *
                     966   ; * Arguments  : none
                     967   ; *
                     968   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                     969   ; *********************************************************************************************************
                     970   ; */
                     971   ; void OSInitHookEnd(void)
                     972   ; {
                     973   _OSInitHookEnd:
                     974   ; #if OS_TMR_EN > 0
                     975   ; OSTmrTickCtr = 0;
0800025C  4239 0800  976          clr.b     _OSTmrTickCtr.L
08000260  00E0      
08000262  4E75       977          rts
                     978   ; #endif
                     979   ; }
                     980   ; /*
                     981   ; *********************************************************************************************************
                     982   ; *                                          TASK CREATION HOOK
                     983   ; *
                     984   ; * Description: This function is called when a task is created.
                     985   ; *
                     986   ; * Arguments  : ptcb   is a pointer to the task control block of the task being created.
                     987   ; *
                     988   ; * Note(s)    : 1) Interrupts are disabled during this call.
                     989   ; *********************************************************************************************************
                     990   ; */
                     991   ; void OSTaskCreateHook(OS_TCB *ptcb)
                     992   ; {
                     993   _OSTaskCreateHook:
08000264  4E56 0000  994          link      A6,#0
08000268  4E5E       995          unlk      A6
0800026A  4E75       996          rts
                     997   ; }
                     998   ; /*
                     999   ; *********************************************************************************************************
                    1000   ; *                                           TASK DELETION HOOK
                    1001   ; *
                    1002   ; * Description: This function is called when a task is deleted.
                    1003   ; *
                    1004   ; * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
                    1005   ; *
                    1006   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1007   ; *********************************************************************************************************
                    1008   ; */
                    1009   ; void OSTaskDelHook(OS_TCB *ptcb)
                    1010   ; {
                    1011   _OSTaskDelHook:
0800026C  4E56 0000 1012          link      A6,#0
08000270  4E5E      1013          unlk      A6
08000272  4E75      1014          rts
                    1015   ; }
                    1016   ; /*
                    1017   ; *********************************************************************************************************
                    1018   ; *                                           TASK SWITCH HOOK
                    1019   ; *
                    1020   ; * Description: This function is called when a task switch is performed.  This allows you to perform other
                    1021   ; *              operations during a context switch.
                    1022   ; *
                    1023   ; * Arguments  : none
                    1024   ; *
                    1025   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1026   ; *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
                    1027   ; *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
                    1028   ; *                 task being switched out (i.e. the preempted task).
                    1029   ; *********************************************************************************************************
                    1030   ; */
                    1031   ; void OSTaskSwHook(void)
                    1032   ; {
                    1033   _OSTaskSwHook:
08000274  4E75      1034          rts
                    1035   ; }
                    1036   ; /*
                    1037   ; *********************************************************************************************************
                    1038   ; *                                           TASK IDLE HOOK
                    1039   ; *
                    1040   ; * Description: This function is called when a idle task is performed.  This allows you to perform other
                    1041   ; *              operations during the idle task.
                    1042   ; *
                    1043   ; * Arguments  : none
                    1044   ; *
                    1045   ; * Note(s)    : none
                    1046   ; *********************************************************************************************************
                    1047   ; */
                    1048   ; void OSTaskIdleHook(void)
                    1049   ; {
                    1050   _OSTaskIdleHook:
08000276  4E75      1051          rts
                    1052   ; }
                    1053   ; /*
                    1054   ; *********************************************************************************************************
                    1055   ; *                                           TASK RETURN HOOK
                    1056   ; *
                    1057   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    1058   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    1059   ; *
                    1060   ; * Arguments  : Pointer to currently running TCB
                    1061   ; *
                    1062   ; * Note(s)    : none
                    1063   ; *********************************************************************************************************
                    1064   ; */
                    1065   ; void OSTaskReturnHook(OS_TCB *ptcb)
                    1066   ; {
                    1067   _OSTaskReturnHook:
08000278  4E56 0000 1068          link      A6,#0
0800027C  4E5E      1069          unlk      A6
0800027E  4E75      1070          rts
                    1071   ; }
                    1072   ; /*
                    1073   ; *********************************************************************************************************
                    1074   ; *                                           STATISTIC TASK HOOK
                    1075   ; *
                    1076   ; * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
                    1077   ; *              application to add functionality to the statistics task.
                    1078   ; *
                    1079   ; * Arguments  : none
                    1080   ; *********************************************************************************************************
                    1081   ; */
                    1082   ; void OSTaskStatHook(void)
                    1083   ; {
                    1084   _OSTaskStatHook:
08000280  4E75      1085          rts
                    1086   ; }
                    1087   ; /*
                    1088   ; *********************************************************************************************************
                    1089   ; *                                               TICK HOOK
                    1090   ; *
                    1091   ; * Description: This function is called every tick.
                    1092   ; *
                    1093   ; * Arguments  : none
                    1094   ; *
                    1095   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1096   ; *********************************************************************************************************
                    1097   ; */
                    1098   ; void OSTimeTickHook(void)
                    1099   ; {
                    1100   _OSTimeTickHook:
                    1101   ; #if OS_TMR_EN > 0
                    1102   ; if (OSTmrUsed > 0 && ++OSTmrTickCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
08000282  3039 0800 1103          move.w    _OSTmrUsed.L,D0
08000286  0D88      
08000288  0C40 0000 1104          cmp.w     #0,D0
0800028C  631E      1105          bls.s     OSTimeTickHook_1
0800028E  5239 0800 1106          addq.b    #1,_OSTmrTickCtr.L
08000292  00E0      
08000294  1039 0800 1107          move.b    _OSTmrTickCtr.L,D0
08000298  00E0      
0800029A  0C00 000A 1108          cmp.b     #10,D0
0800029E  650C      1109          blo.s     OSTimeTickHook_1
                    1110   ; OSTmrTickCtr = 0;
080002A0  4239 0800 1111          clr.b     _OSTmrTickCtr.L
080002A4  00E0      
                    1112   ; OSTmrSignal();
080002A6  4EB9 0800 1113          jsr       _OSTmrSignal
080002AA  501E      
                    1114   OSTimeTickHook_1:
080002AC  4E75      1115          rts
                    1116   ; }
                    1117   ; #endif
                    1118   ; }
                    1119   ; /*
                    1120   ; *********************************************************************************************************
                    1121   ; *                                           OSTCBInit() HOOK
                    1122   ; *
                    1123   ; * Description: This function is called by OSTCBInit() after setting up most of the TCB.
                    1124   ; *
                    1125   ; * Arguments  : ptcb    is a pointer to the TCB of the task being created.
                    1126   ; *
                    1127   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1128   ; *********************************************************************************************************
                    1129   ; */
                    1130   ; #if OS_VERSION > 203
                    1131   ; void OSTCBInitHook (OS_TCB *ptcb)
                    1132   ; {
                    1133   _OSTCBInitHook:
080002AE  4E56 0000 1134          link      A6,#0
080002B2  4E5E      1135          unlk      A6
080002B4  4E75      1136          rts
                    1137   ; }
                    1138   ; #endif
                    1139   ; #endif // OS_CPU_HOOKS_EN
                    1140   ; C:\IDE68K\UCOSII\UCOS_II.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1141   ; /*
                    1142   ; *********************************************************************************************************
                    1143   ; *                                                uC/OS-II
                    1144   ; *                                          The Real-Time Kernel
                    1145   ; *                                             CORE FUNCTIONS
                    1146   ; *
                    1147   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    1148   ; *                                           All Rights Reserved
                    1149   ; *
                    1150   ; * File    : OS_CORE.C
                    1151   ; * By      : Jean J. Labrosse
                    1152   ; * Version : V2.92.07
                    1153   ; *
                    1154   ; * LICENSING TERMS:
                    1155   ; * ---------------
                    1156   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    1157   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    1158   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    1159   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    1160   ; * licensing fee.
                    1161   ; *********************************************************************************************************
                    1162   ; */
                    1163   ; #define  MICRIUM_SOURCE
                    1164   ; #ifndef  OS_MASTER_FILE
                    1165   ; #define  OS_GLOBALS
                    1166   ; #include <ucos_ii.h>
                    1167   ; #endif
                    1168   ; /*
                    1169   ; *********************************************************************************************************
                    1170   ; *                                      PRIORITY RESOLUTION TABLE
                    1171   ; *
                    1172   ; * Note: Index into table is bit pattern to resolve highest priority
                    1173   ; *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
                    1174   ; *********************************************************************************************************
                    1175   ; */
                    1176   ; INT8U  const  OSUnMapTbl[256] = {
                    1177   ; 0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
                    1178   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
                    1179   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
                    1180   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
                    1181   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
                    1182   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
                    1183   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
                    1184   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
                    1185   ; 7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
                    1186   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
                    1187   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
                    1188   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
                    1189   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
                    1190   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
                    1191   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
                    1192   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
                    1193   ; };
                    1194   ; /*$PAGE*/
                    1195   ; /*
                    1196   ; *********************************************************************************************************
                    1197   ; *                                         FUNCTION PROTOTYPES
                    1198   ; *********************************************************************************************************
                    1199   ; */
                    1200   ; static  void  OS_InitEventList(void);
                    1201   ; static  void  OS_InitMisc(void);
                    1202   ; static  void  OS_InitRdyList(void);
                    1203   ; static  void  OS_InitTaskIdle(void);
                    1204   ; #if OS_TASK_STAT_EN > 0u
                    1205   ; static  void  OS_InitTaskStat(void);
                    1206   ; #endif
                    1207   ; static  void  OS_InitTCBList(void);
                    1208   ; static  void  OS_SchedNew(void);
                    1209   ; /*$PAGE*/
                    1210   ; /*
                    1211   ; *********************************************************************************************************
                    1212   ; *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1213   ; *
                    1214   ; * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
                    1215   ; *
                    1216   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1217   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
                    1218   ; *                        type is irrelevant.
                    1219   ; *
                    1220   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
                    1221   ; *                        mutex, mailbox or queue.
                    1222   ; *
                    1223   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1224   ; *
                    1225   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    1226   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1227   ; *                                                   control block type.
                    1228   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1229   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1230   ; *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
                    1231   ; *
                    1232   ; * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
                    1233   ; *********************************************************************************************************
                    1234   ; */
                    1235   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1236   ; INT8U  OSEventNameGet (OS_EVENT   *pevent,
                    1237   ; INT8U     **pname,
                    1238   ; INT8U      *perr)
                    1239   ; {
                    1240   _OSEventNameGet:
080002B6  4E56 FFFC 1241          link      A6,#-4
080002BA  2F02      1242          move.l    D2,-(A7)
080002BC  242E 0010 1243          move.l    16(A6),D2
                    1244   ; INT8U      len;
                    1245   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1246   ; OS_CPU_SR  cpu_sr = 0u;
                    1247   ; #endif
                    1248   ; #ifdef OS_SAFETY_CRITICAL
                    1249   ; if (perr == (INT8U *)0) {
                    1250   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1251   ; return (0u);
                    1252   ; }
                    1253   ; #endif
                    1254   ; #if OS_ARG_CHK_EN > 0u
                    1255   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1256   ; *perr = OS_ERR_PEVENT_NULL;
                    1257   ; return (0u);
                    1258   ; }
                    1259   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1260   ; *perr = OS_ERR_PNAME_NULL;
                    1261   ; return (0u);
                    1262   ; }
                    1263   ; #endif
                    1264   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
080002C0  1039 0800 1265          move.b    _OSIntNesting.L,D0
080002C4  0312      
080002C6  0C00 0000 1266          cmp.b     #0,D0
080002CA  630C      1267          bls.s     OSEventNameGet_1
                    1268   ; *perr  = OS_ERR_NAME_GET_ISR;
080002CC  2042      1269          move.l    D2,A0
080002CE  10BC 0011 1270          move.b    #17,(A0)
                    1271   ; return (0u);
080002D2  4200      1272          clr.b     D0
080002D4  6000 0066 1273          bra       OSEventNameGet_3
                    1274   OSEventNameGet_1:
                    1275   ; }
                    1276   ; switch (pevent->OSEventType) {
080002D8  206E 0008 1277          move.l    8(A6),A0
080002DC  1010      1278          move.b    (A0),D0
080002DE  C0BC 0000 1279          and.l     #255,D0
080002E2  00FF      
080002E4  5380      1280          subq.l    #1,D0
080002E6  651C      1281          blo.s     OSEventNameGet_4
080002E8  0C80 0000 1282          cmp.l     #4,D0
080002EC  0004      
080002EE  6414      1283          bhs.s     OSEventNameGet_4
080002F0  E380      1284          asl.l     #1,D0
080002F2  303B 0806 1285          move.w    OSEventNameGet_6(PC,D0.L),D0
080002F6  4EFB 0002 1286          jmp       OSEventNameGet_6(PC,D0.W)
                    1287   OSEventNameGet_6:
080002FA  0008      1288          dc.w      OSEventNameGet_7-OSEventNameGet_6
080002FC  0008      1289          dc.w      OSEventNameGet_7-OSEventNameGet_6
080002FE  0008      1290          dc.w      OSEventNameGet_7-OSEventNameGet_6
08000300  0008      1291          dc.w      OSEventNameGet_7-OSEventNameGet_6
                    1292   OSEventNameGet_7:
                    1293   ; case OS_EVENT_TYPE_SEM:
                    1294   ; case OS_EVENT_TYPE_MUTEX:
                    1295   ; case OS_EVENT_TYPE_MBOX:
                    1296   ; case OS_EVENT_TYPE_Q:
                    1297   ; break;
08000302  600A      1298          bra.s     OSEventNameGet_5
                    1299   OSEventNameGet_4:
                    1300   ; default:
                    1301   ; *perr = OS_ERR_EVENT_TYPE;
08000304  2042      1302          move.l    D2,A0
08000306  10BC 0001 1303          move.b    #1,(A0)
                    1304   ; return (0u);
0800030A  4200      1305          clr.b     D0
0800030C  602E      1306          bra.s     OSEventNameGet_3
                    1307   OSEventNameGet_5:
                    1308   ; }
                    1309   ; OS_ENTER_CRITICAL();
0800030E  40E7      1310          dc.w      16615
08000310  007C      1311          dc.w      124
08000312  0700      1312          dc.w      1792
                    1313   ; *pname = pevent->OSEventName;
08000314  206E 0008 1314          move.l    8(A6),A0
08000318  226E 000C 1315          move.l    12(A6),A1
0800031C  22A8 0012 1316          move.l    18(A0),(A1)
                    1317   ; len    = OS_StrLen(*pname);
08000320  206E 000C 1318          move.l    12(A6),A0
08000324  2F10      1319          move.l    (A0),-(A7)
08000326  4EB9 0800 1320          jsr       _OS_StrLen
0800032A  1034      
0800032C  584F      1321          addq.w    #4,A7
0800032E  1D40 FFFF 1322          move.b    D0,-1(A6)
                    1323   ; OS_EXIT_CRITICAL();
08000332  46DF      1324          dc.w      18143
                    1325   ; *perr  = OS_ERR_NONE;
08000334  2042      1326          move.l    D2,A0
08000336  4210      1327          clr.b     (A0)
                    1328   ; return (len);
08000338  102E FFFF 1329          move.b    -1(A6),D0
                    1330   OSEventNameGet_3:
0800033C  241F      1331          move.l    (A7)+,D2
0800033E  4E5E      1332          unlk      A6
08000340  4E75      1333          rts
                    1334   ; }
                    1335   ; #endif
                    1336   ; /*$PAGE*/
                    1337   ; /*
                    1338   ; *********************************************************************************************************
                    1339   ; *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1340   ; *
                    1341   ; * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
                    1342   ; *
                    1343   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1344   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
                    1345   ; *                        matter the actual type.
                    1346   ; *
                    1347   ; *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
                    1348   ; *                        mutex, mailbox or queue.
                    1349   ; *
                    1350   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1351   ; *
                    1352   ; *                        OS_ERR_NONE                if the requested task is resumed
                    1353   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1354   ; *                                                   control block type.
                    1355   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1356   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1357   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    1358   ; *
                    1359   ; * Returns    : None
                    1360   ; *********************************************************************************************************
                    1361   ; */
                    1362   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1363   ; void  OSEventNameSet (OS_EVENT  *pevent,
                    1364   ; INT8U     *pname,
                    1365   ; INT8U     *perr)
                    1366   ; {
                    1367   _OSEventNameSet:
08000342  4E56 0000 1368          link      A6,#0
08000346  2F02      1369          move.l    D2,-(A7)
08000348  242E 0010 1370          move.l    16(A6),D2
                    1371   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1372   ; OS_CPU_SR  cpu_sr = 0u;
                    1373   ; #endif
                    1374   ; #ifdef OS_SAFETY_CRITICAL
                    1375   ; if (perr == (INT8U *)0) {
                    1376   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1377   ; return;
                    1378   ; }
                    1379   ; #endif
                    1380   ; #if OS_ARG_CHK_EN > 0u
                    1381   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1382   ; *perr = OS_ERR_PEVENT_NULL;
                    1383   ; return;
                    1384   ; }
                    1385   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1386   ; *perr = OS_ERR_PNAME_NULL;
                    1387   ; return;
                    1388   ; }
                    1389   ; #endif
                    1390   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
0800034C  1039 0800 1391          move.b    _OSIntNesting.L,D0
08000350  0312      
08000352  0C00 0000 1392          cmp.b     #0,D0
08000356  630A      1393          bls.s     OSEventNameSet_1
                    1394   ; *perr = OS_ERR_NAME_SET_ISR;
08000358  2042      1395          move.l    D2,A0
0800035A  10BC 0012 1396          move.b    #18,(A0)
                    1397   ; return;
0800035E  6000 004C 1398          bra       OSEventNameSet_3
                    1399   OSEventNameSet_1:
                    1400   ; }
                    1401   ; switch (pevent->OSEventType) {
08000362  206E 0008 1402          move.l    8(A6),A0
08000366  1010      1403          move.b    (A0),D0
08000368  C0BC 0000 1404          and.l     #255,D0
0800036C  00FF      
0800036E  5380      1405          subq.l    #1,D0
08000370  651C      1406          blo.s     OSEventNameSet_4
08000372  0C80 0000 1407          cmp.l     #4,D0
08000376  0004      
08000378  6414      1408          bhs.s     OSEventNameSet_4
0800037A  E380      1409          asl.l     #1,D0
0800037C  303B 0806 1410          move.w    OSEventNameSet_6(PC,D0.L),D0
08000380  4EFB 0002 1411          jmp       OSEventNameSet_6(PC,D0.W)
                    1412   OSEventNameSet_6:
08000384  0008      1413          dc.w      OSEventNameSet_7-OSEventNameSet_6
08000386  0008      1414          dc.w      OSEventNameSet_7-OSEventNameSet_6
08000388  0008      1415          dc.w      OSEventNameSet_7-OSEventNameSet_6
0800038A  0008      1416          dc.w      OSEventNameSet_7-OSEventNameSet_6
                    1417   OSEventNameSet_7:
                    1418   ; case OS_EVENT_TYPE_SEM:
                    1419   ; case OS_EVENT_TYPE_MUTEX:
                    1420   ; case OS_EVENT_TYPE_MBOX:
                    1421   ; case OS_EVENT_TYPE_Q:
                    1422   ; break;
0800038C  6008      1423          bra.s     OSEventNameSet_5
                    1424   OSEventNameSet_4:
                    1425   ; default:
                    1426   ; *perr = OS_ERR_EVENT_TYPE;
0800038E  2042      1427          move.l    D2,A0
08000390  10BC 0001 1428          move.b    #1,(A0)
                    1429   ; return;
08000394  6016      1430          bra.s     OSEventNameSet_3
                    1431   OSEventNameSet_5:
                    1432   ; }
                    1433   ; OS_ENTER_CRITICAL();
08000396  40E7      1434          dc.w      16615
08000398  007C      1435          dc.w      124
0800039A  0700      1436          dc.w      1792
                    1437   ; pevent->OSEventName = pname;
0800039C  206E 0008 1438          move.l    8(A6),A0
080003A0  216E 000C 1439          move.l    12(A6),18(A0)
080003A4  0012      
                    1440   ; OS_EXIT_CRITICAL();
080003A6  46DF      1441          dc.w      18143
                    1442   ; *perr = OS_ERR_NONE;
080003A8  2042      1443          move.l    D2,A0
080003AA  4210      1444          clr.b     (A0)
                    1445   OSEventNameSet_3:
080003AC  241F      1446          move.l    (A7)+,D2
080003AE  4E5E      1447          unlk      A6
080003B0  4E75      1448          rts
                    1449   ; }
                    1450   ; #endif
                    1451   ; /*$PAGE*/
                    1452   ; /*
                    1453   ; *********************************************************************************************************
                    1454   ; *                                       PEND ON MULTIPLE EVENTS
                    1455   ; *
                    1456   ; * Description: This function waits for multiple events.  If multiple events are ready at the start of the
                    1457   ; *              pend call, then all available events are returned as ready.  If the task must pend on the
                    1458   ; *              multiple events, then only the first posted or aborted event is returned as ready.
                    1459   ; *
                    1460   ; * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
                    1461   ; *
                    1462   ; *              pevents_rdy   is a pointer to an array to return which event control blocks are available
                    1463   ; *                            or ready.  The size of the array MUST be greater than or equal to the size
                    1464   ; *                            of the 'pevents_pend' array, including terminating NULL.
                    1465   ; *
                    1466   ; *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
                    1467   ; *                            events.  The size of the array MUST be greater than or equal to the size of
                    1468   ; *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
                    1469   ; *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
                    1470   ; *                            every available message-type event returns its messages in the 'pmsgs_rdy'
                    1471   ; *                            array at the same index as the event is returned in the 'pevents_rdy' array.
                    1472   ; *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
                    1473   ; *
                    1474   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    1475   ; *                            wait for the resources up to the amount of time specified by this argument.
                    1476   ; *                            If you specify 0, however, your task will wait forever for the specified
                    1477   ; *                            events or, until the resources becomes available (or the events occur).
                    1478   ; *
                    1479   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    1480   ; *                            messages are:
                    1481   ; *
                    1482   ; *                            OS_ERR_NONE         The call was successful and your task owns the resources
                    1483   ; *                                                or, the events you are waiting for occurred; check the
                    1484   ; *                                                'pevents_rdy' array for which events are available.
                    1485   ; *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
                    1486   ; *                                                'pevents_rdy' array for which events were aborted.
                    1487   ; *                            OS_ERR_TIMEOUT      The events were not received within the specified
                    1488   ; *                                                'timeout'.
                    1489   ; *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
                    1490   ; *                                                NULL pointer.
                    1491   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
                    1492   ; *                                                mailboxes, and/or queues.
                    1493   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    1494   ; *                                                would lead to a suspension.
                    1495   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
                    1496   ; *
                    1497   ; * Returns    : >  0          the number of events returned as ready or aborted.
                    1498   ; *              == 0          if no events are returned as ready because of timeout or upon error.
                    1499   ; *
                    1500   ; * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
                    1501   ; *
                    1502   ; *                        semaphores, mailboxes, queues
                    1503   ; *
                    1504   ; *                 b. Return ALL available events and messages, if any
                    1505   ; *
                    1506   ; *                 c. Add    current task priority as pending to   each events's wait list
                    1507   ; *                      Performed in OS_EventTaskWaitMulti()
                    1508   ; *
                    1509   ; *                 d. Wait on any of multiple events
                    1510   ; *
                    1511   ; *                 e. Remove current task priority as pending from each events's wait list
                    1512   ; *                      Performed in OS_EventTaskRdy(), if events posted or aborted
                    1513   ; *
                    1514   ; *                 f. Return any event posted or aborted, if any
                    1515   ; *                      else
                    1516   ; *                    Return timeout
                    1517   ; *
                    1518   ; *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
                    1519   ; *                 case of any error(s).
                    1520   ; *********************************************************************************************************
                    1521   ; */
                    1522   ; /*$PAGE*/
                    1523   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    1524   ; INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                    1525   ; OS_EVENT  **pevents_rdy,
                    1526   ; void      **pmsgs_rdy,
                    1527   ; INT32U      timeout,
                    1528   ; INT8U      *perr)
                    1529   ; {
                    1530   _OSEventPendMulti:
080003B2  4E56 FFFC 1531          link      A6,#-4
080003B6  48E7 3F38 1532          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
080003BA  45F9 0800 1533          lea       _OSTCBCur.L,A2
080003BE  042C      
080003C0  282E 0018 1534          move.l    24(A6),D4
080003C4  2A2E 000C 1535          move.l    12(A6),D5
080003C8  266E 0010 1536          move.l    16(A6),A3
080003CC  286E 0008 1537          move.l    8(A6),A4
                    1538   ; OS_EVENT  **pevents;
                    1539   ; OS_EVENT   *pevent;
                    1540   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1541   ; OS_Q       *pq;
                    1542   ; #endif
                    1543   ; BOOLEAN     events_rdy;
                    1544   ; INT16U      events_rdy_nbr;
                    1545   ; INT8U       events_stat;
                    1546   ; #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
                    1547   ; OS_CPU_SR   cpu_sr = 0u;
                    1548   ; #endif
                    1549   ; #ifdef OS_SAFETY_CRITICAL
                    1550   ; if (perr == (INT8U *)0) {
                    1551   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1552   ; return (0u);
                    1553   ; }
                    1554   ; #endif
                    1555   ; #if (OS_ARG_CHK_EN > 0u)
                    1556   ; if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
                    1557   ; *perr =  OS_ERR_PEVENT_NULL;
                    1558   ; return (0u);
                    1559   ; }
                    1560   ; if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
                    1561   ; *perr =  OS_ERR_PEVENT_NULL;
                    1562   ; return (0u);
                    1563   ; }
                    1564   ; if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
                    1565   ; *perr =  OS_ERR_PEVENT_NULL;
                    1566   ; return (0u);
                    1567   ; }
                    1568   ; if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
                    1569   ; *perr =  OS_ERR_PEVENT_NULL;
                    1570   ; return (0u);
                    1571   ; }
                    1572   ; #endif
                    1573   ; *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
080003D0  2045      1574          move.l    D5,A0
080003D2  4290      1575          clr.l     (A0)
                    1576   ; pevents     =  pevents_pend;
080003D4  2E0C      1577          move.l    A4,D7
                    1578   ; pevent      = *pevents;
080003D6  2047      1579          move.l    D7,A0
080003D8  2410      1580          move.l    (A0),D2
                    1581   ; while  (pevent != (OS_EVENT *)0) {
                    1582   OSEventPendMulti_1:
080003DA  4A82      1583          tst.l     D2
080003DC  6700 0046 1584          beq       OSEventPendMulti_3
                    1585   ; switch (pevent->OSEventType) {                  /* Validate event block types                  */
080003E0  2042      1586          move.l    D2,A0
080003E2  1010      1587          move.b    (A0),D0
080003E4  C0BC 0000 1588          and.l     #255,D0
080003E8  00FF      
080003EA  5380      1589          subq.l    #1,D0
080003EC  6522      1590          blo.s     OSEventPendMulti_10
080003EE  0C80 0000 1591          cmp.l     #5,D0
080003F2  0005      
080003F4  641A      1592          bhs.s     OSEventPendMulti_10
080003F6  E380      1593          asl.l     #1,D0
080003F8  303B 0806 1594          move.w    OSEventPendMulti_6(PC,D0.L),D0
080003FC  4EFB 0002 1595          jmp       OSEventPendMulti_6(PC,D0.W)
                    1596   OSEventPendMulti_6:
08000400  000C      1597          dc.w      OSEventPendMulti_8-OSEventPendMulti_6
08000402  000E      1598          dc.w      OSEventPendMulti_9-OSEventPendMulti_6
08000404  000A      1599          dc.w      OSEventPendMulti_7-OSEventPendMulti_6
08000406  0010      1600          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
08000408  0010      1601          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
                    1602   OSEventPendMulti_7:
                    1603   ; #if (OS_SEM_EN  > 0u)
                    1604   ; case OS_EVENT_TYPE_SEM:
                    1605   ; break;
0800040A  6010      1606          bra.s     OSEventPendMulti_5
                    1607   OSEventPendMulti_8:
                    1608   ; #endif
                    1609   ; #if (OS_MBOX_EN > 0u)
                    1610   ; case OS_EVENT_TYPE_MBOX:
                    1611   ; break;
0800040C  600E      1612          bra.s     OSEventPendMulti_5
                    1613   OSEventPendMulti_9:
                    1614   ; #endif
                    1615   ; #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
                    1616   ; case OS_EVENT_TYPE_Q:
                    1617   ; break;
0800040E  600C      1618          bra.s     OSEventPendMulti_5
                    1619   OSEventPendMulti_10:
                    1620   ; #endif
                    1621   ; case OS_EVENT_TYPE_MUTEX:
                    1622   ; case OS_EVENT_TYPE_FLAG:
                    1623   ; default:
                    1624   ; *perr = OS_ERR_EVENT_TYPE;
08000410  2044      1625          move.l    D4,A0
08000412  10BC 0001 1626          move.b    #1,(A0)
                    1627   ; return (0u);
08000416  4240      1628          clr.w     D0
08000418  6000 02C2 1629          bra       OSEventPendMulti_13
                    1630   OSEventPendMulti_5:
                    1631   ; }
                    1632   ; pevents++;
0800041C  5887      1633          addq.l    #4,D7
                    1634   ; pevent = *pevents;
0800041E  2047      1635          move.l    D7,A0
08000420  2410      1636          move.l    (A0),D2
08000422  60B6      1637          bra       OSEventPendMulti_1
                    1638   OSEventPendMulti_3:
                    1639   ; }
                    1640   ; if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
08000424  1039 0800 1641          move.b    _OSIntNesting.L,D0
08000428  0312      
0800042A  0C00 0000 1642          cmp.b     #0,D0
0800042E  630C      1643          bls.s     OSEventPendMulti_14
                    1644   ; *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
08000430  2044      1645          move.l    D4,A0
08000432  10BC 0002 1646          move.b    #2,(A0)
                    1647   ; return (0u);
08000436  4240      1648          clr.w     D0
08000438  6000 02A2 1649          bra       OSEventPendMulti_13
                    1650   OSEventPendMulti_14:
                    1651   ; }
                    1652   ; if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
0800043C  1039 0800 1653          move.b    _OSLockNesting.L,D0
08000440  0314      
08000442  0C00 0000 1654          cmp.b     #0,D0
08000446  630C      1655          bls.s     OSEventPendMulti_16
                    1656   ; *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
08000448  2044      1657          move.l    D4,A0
0800044A  10BC 000D 1658          move.b    #13,(A0)
                    1659   ; return (0u);
0800044E  4240      1660          clr.w     D0
08000450  6000 028A 1661          bra       OSEventPendMulti_13
                    1662   OSEventPendMulti_16:
                    1663   ; }
                    1664   ; /*$PAGE*/
                    1665   ; events_rdy     =  OS_FALSE;
08000454  422E FFFE 1666          clr.b     -2(A6)
                    1667   ; events_rdy_nbr =  0u;
08000458  4243      1668          clr.w     D3
                    1669   ; events_stat    =  OS_STAT_RDY;
0800045A  422E FFFF 1670          clr.b     -1(A6)
                    1671   ; pevents        =  pevents_pend;
0800045E  2E0C      1672          move.l    A4,D7
                    1673   ; pevent         = *pevents;
08000460  2047      1674          move.l    D7,A0
08000462  2410      1675          move.l    (A0),D2
                    1676   ; OS_ENTER_CRITICAL();
08000464  40E7      1677          dc.w      16615
08000466  007C      1678          dc.w      124
08000468  0700      1679          dc.w      1792
                    1680   ; while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
                    1681   OSEventPendMulti_18:
0800046A  4A82      1682          tst.l     D2
0800046C  6700 010A 1683          beq       OSEventPendMulti_20
                    1684   ; switch (pevent->OSEventType) {
08000470  2042      1685          move.l    D2,A0
08000472  1010      1686          move.b    (A0),D0
08000474  C0BC 0000 1687          and.l     #255,D0
08000478  00FF      
0800047A  5380      1688          subq.l    #1,D0
0800047C  6500 00DE 1689          blo       OSEventPendMulti_27
08000480  0C80 0000 1690          cmp.l     #5,D0
08000484  0005      
08000486  6400 00D4 1691          bhs       OSEventPendMulti_27
0800048A  E380      1692          asl.l     #1,D0
0800048C  303B 0806 1693          move.w    OSEventPendMulti_23(PC,D0.L),D0
08000490  4EFB 0002 1694          jmp       OSEventPendMulti_23(PC,D0.W)
                    1695   OSEventPendMulti_23:
08000494  003A      1696          dc.w      OSEventPendMulti_25-OSEventPendMulti_23
08000496  0068      1697          dc.w      OSEventPendMulti_26-OSEventPendMulti_23
08000498  000A      1698          dc.w      OSEventPendMulti_24-OSEventPendMulti_23
0800049A  00C8      1699          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
0800049C  00C8      1700          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
                    1701   OSEventPendMulti_24:
                    1702   ; #if (OS_SEM_EN > 0u)
                    1703   ; case OS_EVENT_TYPE_SEM:
                    1704   ; if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
0800049E  2042      1705          move.l    D2,A0
080004A0  3028 0006 1706          move.w    6(A0),D0
080004A4  0C40 0000 1707          cmp.w     #0,D0
080004A8  631A      1708          bls.s     OSEventPendMulti_30
                    1709   ; pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
080004AA  2002      1710          move.l    D2,D0
080004AC  5C80      1711          addq.l    #6,D0
080004AE  2040      1712          move.l    D0,A0
080004B0  5350      1713          subq.w    #1,(A0)
                    1714   ; *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
080004B2  2045      1715          move.l    D5,A0
080004B4  5885      1716          addq.l    #4,D5
080004B6  2082      1717          move.l    D2,(A0)
                    1718   ; events_rdy   =  OS_TRUE;
080004B8  1D7C 0001 1719          move.b    #1,-2(A6)
080004BC  FFFE      
                    1720   ; *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
080004BE  429B      1721          clr.l     (A3)+
                    1722   ; events_rdy_nbr++;
080004C0  5243      1723          addq.w    #1,D3
080004C2  6006      1724          bra.s     OSEventPendMulti_31
                    1725   OSEventPendMulti_30:
                    1726   ; } else {
                    1727   ; events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
080004C4  002E 0001 1728          or.b      #1,-1(A6)
080004C8  FFFF      
                    1729   OSEventPendMulti_31:
                    1730   ; }
                    1731   ; break;
080004CA  6000 00A2 1732          bra       OSEventPendMulti_22
                    1733   OSEventPendMulti_25:
                    1734   ; #endif
                    1735   ; #if (OS_MBOX_EN > 0u)
                    1736   ; case OS_EVENT_TYPE_MBOX:
                    1737   ; if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
080004CE  2042      1738          move.l    D2,A0
080004D0  2028 0002 1739          move.l    2(A0),D0
080004D4  671C      1740          beq.s     OSEventPendMulti_32
                    1741   ; /* ... return available message,           ... */
                    1742   ; *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
080004D6  2042      1743          move.l    D2,A0
080004D8  26E8 0002 1744          move.l    2(A0),(A3)+
                    1745   ; pevent->OSEventPtr  = (void *)0;
080004DC  2042      1746          move.l    D2,A0
080004DE  42A8 0002 1747          clr.l     2(A0)
                    1748   ; *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
080004E2  2045      1749          move.l    D5,A0
080004E4  5885      1750          addq.l    #4,D5
080004E6  2082      1751          move.l    D2,(A0)
                    1752   ; events_rdy         =  OS_TRUE;
080004E8  1D7C 0001 1753          move.b    #1,-2(A6)
080004EC  FFFE      
                    1754   ; events_rdy_nbr++;
080004EE  5243      1755          addq.w    #1,D3
080004F0  6006      1756          bra.s     OSEventPendMulti_33
                    1757   OSEventPendMulti_32:
                    1758   ; } else {
                    1759   ; events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
080004F2  002E 0002 1760          or.b      #2,-1(A6)
080004F6  FFFF      
                    1761   OSEventPendMulti_33:
                    1762   ; }
                    1763   ; break;
080004F8  6000 0074 1764          bra       OSEventPendMulti_22
                    1765   OSEventPendMulti_26:
                    1766   ; #endif
                    1767   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1768   ; case OS_EVENT_TYPE_Q:
                    1769   ; pq = (OS_Q *)pevent->OSEventPtr;
080004FC  2042      1770          move.l    D2,A0
080004FE  2C28 0002 1771          move.l    2(A0),D6
                    1772   ; if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
08000502  2046      1773          move.l    D6,A0
08000504  3028 0016 1774          move.w    22(A0),D0
08000508  0C40 0000 1775          cmp.w     #0,D0
0800050C  6300 0046 1776          bls       OSEventPendMulti_34
                    1777   ; /* ... return available message,           ... */
                    1778   ; *pmsgs_rdy++ = (void *)*pq->OSQOut++;
08000510  2006      1779          move.l    D6,D0
08000512  0680 0000 1780          add.l     #16,D0
08000516  0010      
08000518  2040      1781          move.l    D0,A0
0800051A  2250      1782          move.l    (A0),A1
0800051C  5890      1783          addq.l    #4,(A0)
0800051E  26D1      1784          move.l    (A1),(A3)+
                    1785   ; if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
08000520  2046      1786          move.l    D6,A0
08000522  2246      1787          move.l    D6,A1
08000524  2028 0010 1788          move.l    16(A0),D0
08000528  B0A9 0008 1789          cmp.l     8(A1),D0
0800052C  660A      1790          bne.s     OSEventPendMulti_36
                    1791   ; pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
0800052E  2046      1792          move.l    D6,A0
08000530  2246      1793          move.l    D6,A1
08000532  2368 0004 1794          move.l    4(A0),16(A1)
08000536  0010      
                    1795   OSEventPendMulti_36:
                    1796   ; }
                    1797   ; pq->OSQEntries--;                  /* Update number of queue entries              */
08000538  2006      1798          move.l    D6,D0
0800053A  0680 0000 1799          add.l     #22,D0
0800053E  0016      
08000540  2040      1800          move.l    D0,A0
08000542  5350      1801          subq.w    #1,(A0)
                    1802   ; *pevents_rdy++ = pevent;            /* ... and return available queue event        */
08000544  2045      1803          move.l    D5,A0
08000546  5885      1804          addq.l    #4,D5
08000548  2082      1805          move.l    D2,(A0)
                    1806   ; events_rdy   = OS_TRUE;
0800054A  1D7C 0001 1807          move.b    #1,-2(A6)
0800054E  FFFE      
                    1808   ; events_rdy_nbr++;
08000550  5243      1809          addq.w    #1,D3
08000552  6006      1810          bra.s     OSEventPendMulti_35
                    1811   OSEventPendMulti_34:
                    1812   ; } else {
                    1813   ; events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
08000554  002E 0004 1814          or.b      #4,-1(A6)
08000558  FFFF      
                    1815   OSEventPendMulti_35:
                    1816   ; }
                    1817   ; break;
0800055A  6012      1818          bra.s     OSEventPendMulti_22
                    1819   OSEventPendMulti_27:
                    1820   ; #endif
                    1821   ; case OS_EVENT_TYPE_MUTEX:
                    1822   ; case OS_EVENT_TYPE_FLAG:
                    1823   ; default:
                    1824   ; OS_EXIT_CRITICAL();
0800055C  46DF      1825          dc.w      18143
                    1826   ; *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
0800055E  2045      1827          move.l    D5,A0
08000560  4290      1828          clr.l     (A0)
                    1829   ; *perr        =  OS_ERR_EVENT_TYPE;
08000562  2044      1830          move.l    D4,A0
08000564  10BC 0001 1831          move.b    #1,(A0)
                    1832   ; return (events_rdy_nbr);
08000568  3003      1833          move.w    D3,D0
0800056A  6000 0170 1834          bra       OSEventPendMulti_13
                    1835   OSEventPendMulti_22:
                    1836   ; }
                    1837   ; pevents++;
0800056E  5887      1838          addq.l    #4,D7
                    1839   ; pevent = *pevents;
08000570  2047      1840          move.l    D7,A0
08000572  2410      1841          move.l    (A0),D2
08000574  6000 FEF4 1842          bra       OSEventPendMulti_18
                    1843   OSEventPendMulti_20:
                    1844   ; }
                    1845   ; if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
08000578  102E FFFE 1846          move.b    -2(A6),D0
0800057C  0C00 0001 1847          cmp.b     #1,D0
08000580  6610      1848          bne.s     OSEventPendMulti_38
                    1849   ; *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
08000582  2045      1850          move.l    D5,A0
08000584  4290      1851          clr.l     (A0)
                    1852   ; OS_EXIT_CRITICAL();
08000586  46DF      1853          dc.w      18143
                    1854   ; *perr        =  OS_ERR_NONE;
08000588  2044      1855          move.l    D4,A0
0800058A  4210      1856          clr.b     (A0)
                    1857   ; return (events_rdy_nbr);
0800058C  3003      1858          move.w    D3,D0
0800058E  6000 014C 1859          bra       OSEventPendMulti_13
                    1860   OSEventPendMulti_38:
                    1861   ; }
                    1862   ; /*$PAGE*/
                    1863   ; /* Otherwise, must wait until any event occurs */
                    1864   ; OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
08000592  2052      1865          move.l    (A2),A0
08000594  102E FFFF 1866          move.b    -1(A6),D0
08000598  803C 0080 1867          or.b      #128,D0
0800059C  8128 0032 1868          or.b      D0,50(A0)
                    1869   ; OS_STAT_MULTI;           /* ... pend on multiple events                 */
                    1870   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
080005A0  2052      1871          move.l    (A2),A0
080005A2  4228 0033 1872          clr.b     51(A0)
                    1873   ; OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
080005A6  2052      1874          move.l    (A2),A0
080005A8  216E 0014 1875          move.l    20(A6),46(A0)
080005AC  002E      
                    1876   ; OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
080005AE  2F0C      1877          move.l    A4,-(A7)
080005B0  4EB9 0800 1878          jsr       _OS_EventTaskWaitMulti
080005B4  0B12      
080005B6  584F      1879          addq.w    #4,A7
                    1880   ; OS_EXIT_CRITICAL();
080005B8  46DF      1881          dc.w      18143
                    1882   ; OS_Sched();                                         /* Find next highest priority task ready       */
080005BA  4EB9 0800 1883          jsr       _OS_Sched
080005BE  0F8A      
                    1884   ; OS_ENTER_CRITICAL();
080005C0  40E7      1885          dc.w      16615
080005C2  007C      1886          dc.w      124
080005C4  0700      1887          dc.w      1792
                    1888   ; switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
080005C6  2052      1889          move.l    (A2),A0
080005C8  1028 0033 1890          move.b    51(A0),D0
080005CC  C0BC 0000 1891          and.l     #255,D0
080005D0  00FF      
080005D2  0C80 0000 1892          cmp.l     #1,D0
080005D6  0001      
080005D8  6700 0046 1893          beq       OSEventPendMulti_44
080005DC  6208      1894          bhi.s     OSEventPendMulti_46
080005DE  4A80      1895          tst.l     D0
080005E0  6710      1896          beq.s     OSEventPendMulti_42
080005E2  6000 003C 1897          bra       OSEventPendMulti_44
                    1898   OSEventPendMulti_46:
080005E6  0C80 0000 1899          cmp.l     #2,D0
080005EA  0002      
080005EC  6704      1900          beq.s     OSEventPendMulti_42
080005EE  6000 0030 1901          bra       OSEventPendMulti_44
                    1902   OSEventPendMulti_42:
                    1903   ; case OS_STAT_PEND_OK:
                    1904   ; case OS_STAT_PEND_ABORT:
                    1905   ; pevent = OSTCBCur->OSTCBEventPtr;
080005F2  2052      1906          move.l    (A2),A0
080005F4  2428 001C 1907          move.l    28(A0),D2
                    1908   ; if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
080005F8  4A82      1909          tst.l     D2
080005FA  670E      1910          beq.s     OSEventPendMulti_47
                    1911   ; *pevents_rdy++   =  pevent;             /* ... return available event ...              */
080005FC  2045      1912          move.l    D5,A0
080005FE  5885      1913          addq.l    #4,D5
08000600  2082      1914          move.l    D2,(A0)
                    1915   ; *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
08000602  2045      1916          move.l    D5,A0
08000604  4290      1917          clr.l     (A0)
                    1918   ; events_rdy_nbr =  1;
08000606  7601      1919          moveq     #1,D3
08000608  6014      1920          bra.s     OSEventPendMulti_48
                    1921   OSEventPendMulti_47:
                    1922   ; } else {                                   /* Else NO event available, handle as timeout  */
                    1923   ; OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
0800060A  2052      1924          move.l    (A2),A0
0800060C  117C 0001 1925          move.b    #1,51(A0)
08000610  0033      
                    1926   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
08000612  2F0C      1927          move.l    A4,-(A7)
08000614  2F12      1928          move.l    (A2),-(A7)
08000616  4EB9 0800 1929          jsr       _OS_EventTaskRemoveMulti
0800061A  0C02      
0800061C  504F      1930          addq.w    #8,A7
                    1931   OSEventPendMulti_48:
                    1932   ; }
                    1933   ; break;
0800061E  600C      1934          bra.s     OSEventPendMulti_41
                    1935   OSEventPendMulti_44:
                    1936   ; case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
                    1937   ; default:                                        /* ... remove task from events' wait lists     */
                    1938   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
08000620  2F0C      1939          move.l    A4,-(A7)
08000622  2F12      1940          move.l    (A2),-(A7)
08000624  4EB9 0800 1941          jsr       _OS_EventTaskRemoveMulti
08000628  0C02      
0800062A  504F      1942          addq.w    #8,A7
                    1943   ; break;
                    1944   OSEventPendMulti_41:
                    1945   ; }
                    1946   ; switch (OSTCBCur->OSTCBStatPend) {
0800062C  2052      1947          move.l    (A2),A0
0800062E  1028 0033 1948          move.b    51(A0),D0
08000632  C0BC 0000 1949          and.l     #255,D0
08000636  00FF      
08000638  0C80 0000 1950          cmp.l     #1,D0
0800063C  0001      
0800063E  6700 0072 1951          beq       OSEventPendMulti_53
08000642  6208      1952          bhi.s     OSEventPendMulti_55
08000644  4A80      1953          tst.l     D0
08000646  6712      1954          beq.s     OSEventPendMulti_51
08000648  6000 0068 1955          bra       OSEventPendMulti_53
                    1956   OSEventPendMulti_55:
0800064C  0C80 0000 1957          cmp.l     #2,D0
08000650  0002      
08000652  6700 0054 1958          beq       OSEventPendMulti_52
08000656  6000 005A 1959          bra       OSEventPendMulti_53
                    1960   OSEventPendMulti_51:
                    1961   ; case OS_STAT_PEND_OK:
                    1962   ; switch (pevent->OSEventType) {             /* Return event's message                      */
0800065A  2042      1963          move.l    D2,A0
0800065C  1010      1964          move.b    (A0),D0
0800065E  C0BC 0000 1965          and.l     #255,D0
08000662  00FF      
08000664  5380      1966          subq.l    #1,D0
08000666  6528      1967          blo.s     OSEventPendMulti_62
08000668  0C80 0000 1968          cmp.l     #5,D0
0800066C  0005      
0800066E  6420      1969          bhs.s     OSEventPendMulti_62
08000670  E380      1970          asl.l     #1,D0
08000672  303B 0806 1971          move.w    OSEventPendMulti_58(PC,D0.L),D0
08000676  4EFB 0002 1972          jmp       OSEventPendMulti_58(PC,D0.W)
                    1973   OSEventPendMulti_58:
0800067A  000E      1974          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
0800067C  000E      1975          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
0800067E  000A      1976          dc.w      OSEventPendMulti_59-OSEventPendMulti_58
08000680  0016      1977          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
08000682  0016      1978          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
                    1979   OSEventPendMulti_59:
                    1980   ; #if (OS_SEM_EN > 0u)
                    1981   ; case OS_EVENT_TYPE_SEM:
                    1982   ; *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
08000684  429B      1983          clr.l     (A3)+
                    1984   ; break;
08000686  601A      1985          bra.s     OSEventPendMulti_57
                    1986   OSEventPendMulti_60:
                    1987   ; #endif
                    1988   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    1989   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    1990   ; case OS_EVENT_TYPE_MBOX:
                    1991   ; case OS_EVENT_TYPE_Q:
                    1992   ; *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
08000688  2052      1993          move.l    (A2),A0
0800068A  26E8 0024 1994          move.l    36(A0),(A3)+
                    1995   ; break;
0800068E  6012      1996          bra.s     OSEventPendMulti_57
                    1997   OSEventPendMulti_62:
                    1998   ; #endif
                    1999   ; case OS_EVENT_TYPE_MUTEX:
                    2000   ; case OS_EVENT_TYPE_FLAG:
                    2001   ; default:
                    2002   ; OS_EXIT_CRITICAL();
08000690  46DF      2003          dc.w      18143
                    2004   ; *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
08000692  2045      2005          move.l    D5,A0
08000694  4290      2006          clr.l     (A0)
                    2007   ; *perr        =  OS_ERR_EVENT_TYPE;
08000696  2044      2008          move.l    D4,A0
08000698  10BC 0001 2009          move.b    #1,(A0)
                    2010   ; return (events_rdy_nbr);
0800069C  3003      2011          move.w    D3,D0
0800069E  6000 003C 2012          bra       OSEventPendMulti_13
                    2013   OSEventPendMulti_57:
                    2014   ; }
                    2015   ; *perr = OS_ERR_NONE;
080006A2  2044      2016          move.l    D4,A0
080006A4  4210      2017          clr.b     (A0)
                    2018   ; break;
080006A6  6012      2019          bra.s     OSEventPendMulti_50
                    2020   OSEventPendMulti_52:
                    2021   ; case OS_STAT_PEND_ABORT:
                    2022   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
080006A8  429B      2023          clr.l     (A3)+
                    2024   ; *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
080006AA  2044      2025          move.l    D4,A0
080006AC  10BC 000E 2026          move.b    #14,(A0)
                    2027   ; break;
080006B0  6008      2028          bra.s     OSEventPendMulti_50
                    2029   OSEventPendMulti_53:
                    2030   ; case OS_STAT_PEND_TO:
                    2031   ; default:
                    2032   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
080006B2  429B      2033          clr.l     (A3)+
                    2034   ; *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
080006B4  2044      2035          move.l    D4,A0
080006B6  10BC 000A 2036          move.b    #10,(A0)
                    2037   ; break;
                    2038   OSEventPendMulti_50:
                    2039   ; }
                    2040   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
080006BA  2052      2041          move.l    (A2),A0
080006BC  4228 0032 2042          clr.b     50(A0)
                    2043   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
080006C0  2052      2044          move.l    (A2),A0
080006C2  4228 0033 2045          clr.b     51(A0)
                    2046   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
080006C6  2052      2047          move.l    (A2),A0
080006C8  42A8 001C 2048          clr.l     28(A0)
                    2049   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
080006CC  2052      2050          move.l    (A2),A0
080006CE  42A8 0020 2051          clr.l     32(A0)
                    2052   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2053   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2054   ; OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
080006D2  2052      2055          move.l    (A2),A0
080006D4  42A8 0024 2056          clr.l     36(A0)
                    2057   ; #endif
                    2058   ; OS_EXIT_CRITICAL();
080006D8  46DF      2059          dc.w      18143
                    2060   ; return (events_rdy_nbr);
080006DA  3003      2061          move.w    D3,D0
                    2062   OSEventPendMulti_13:
080006DC  4CDF 1CFC 2063          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
080006E0  4E5E      2064          unlk      A6
080006E2  4E75      2065          rts
                    2066   ; }
                    2067   ; #endif
                    2068   ; /*$PAGE*/
                    2069   ; /*
                    2070   ; *********************************************************************************************************
                    2071   ; *                                           INITIALIZATION
                    2072   ; *
                    2073   ; * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
                    2074   ; *              creating any uC/OS-II object and, prior to calling OSStart().
                    2075   ; *
                    2076   ; * Arguments  : none
                    2077   ; *
                    2078   ; * Returns    : none
                    2079   ; *********************************************************************************************************
                    2080   ; */
                    2081   ; void  OSInit (void)
                    2082   ; {
                    2083   _OSInit:
                    2084   ; OSInitHookBegin();                                           /* Call port specific initialization code   */
080006E4  4EB9 0800 2085          jsr       _OSInitHookBegin
080006E8  025A      
                    2086   ; OS_InitMisc();                                               /* Initialize miscellaneous variables       */
080006EA  4EB9 0800 2087          jsr       @ucos_ii_OS_InitMisc
080006EE  0D4A      
                    2088   ; OS_InitRdyList();                                            /* Initialize the Ready List                */
080006F0  4EB9 0800 2089          jsr       @ucos_ii_OS_InitRdyList
080006F4  0D8E      
                    2090   ; OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
080006F6  4EB9 0800 2091          jsr       @ucos_ii_OS_InitTCBList
080006FA  0E86      
                    2092   ; OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
080006FC  4EB9 0800 2093          jsr       @ucos_ii_OS_InitEventList
08000700  0CA2      
                    2094   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    2095   ; OS_FlagInit();                                               /* Initialize the event flag structures     */
08000702  4EB9 0800 2096          jsr       _OS_FlagInit
08000706  1CA8      
                    2097   ; #endif
                    2098   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    2099   ; OS_MemInit();                                                /* Initialize the memory manager            */
08000708  4EB9 0800 2100          jsr       _OS_MemInit
0800070C  2586      
                    2101   ; #endif
                    2102   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    2103   ; OS_QInit();                                                  /* Initialize the message queue structures  */
0800070E  4EB9 0800 2104          jsr       _OS_QInit
08000712  3720      
                    2105   ; #endif
                    2106   ; OS_InitTaskIdle();                                           /* Create the Idle Task                     */
08000714  4EB9 0800 2107          jsr       @ucos_ii_OS_InitTaskIdle
08000718  0DCE      
                    2108   ; #if OS_TASK_STAT_EN > 0u
                    2109   ; OS_InitTaskStat();                                           /* Create the Statistic Task                */
0800071A  4EB9 0800 2110          jsr       @ucos_ii_OS_InitTaskStat
0800071E  0E2A      
                    2111   ; #endif
                    2112   ; #if OS_TMR_EN > 0u
                    2113   ; OSTmr_Init();                                                /* Initialize the Timer Manager             */
08000720  4EB9 0800 2114          jsr       _OSTmr_Init
08000724  50D8      
                    2115   ; #endif
                    2116   ; OSInitHookEnd();                                             /* Call port specific init. code            */
08000726  4EB9 0800 2117          jsr       _OSInitHookEnd
0800072A  025C      
0800072C  4E75      2118          rts
                    2119   ; #if OS_DEBUG_EN > 0u
                    2120   ; OSDebugInit();
                    2121   ; #endif
                    2122   ; }
                    2123   ; /*$PAGE*/
                    2124   ; /*
                    2125   ; *********************************************************************************************************
                    2126   ; *                                              ENTER ISR
                    2127   ; *
                    2128   ; * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
                    2129   ; *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
                    2130   ; *              only perform rescheduling at the last nested ISR.
                    2131   ; *
                    2132   ; * Arguments  : none
                    2133   ; *
                    2134   ; * Returns    : none
                    2135   ; *
                    2136   ; * Notes      : 1) This function should be called with interrupts already disabled
                    2137   ; *              2) Your ISR can directly increment OSIntNesting without calling this function because
                    2138   ; *                 OSIntNesting has been declared 'global'.
                    2139   ; *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
                    2140   ; *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2141   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2142   ; *                 end of the ISR.
                    2143   ; *              5) You are allowed to nest interrupts up to 255 levels deep.
                    2144   ; *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
                    2145   ; *                 OSIntEnter() is always called with interrupts disabled.
                    2146   ; *********************************************************************************************************
                    2147   ; */
                    2148   ; void  OSIntEnter (void)
                    2149   ; {
                    2150   _OSIntEnter:
                    2151   ; if (OSRunning == OS_TRUE) {
0800072E  1039 0800 2152          move.b    _OSRunning.L,D0
08000732  0324      
08000734  0C00 0001 2153          cmp.b     #1,D0
08000738  6612      2154          bne.s     OSIntEnter_3
                    2155   ; if (OSIntNesting < 255u) {
0800073A  1039 0800 2156          move.b    _OSIntNesting.L,D0
0800073E  0312      
08000740  0C00 00FF 2157          cmp.b     #255,D0
08000744  6406      2158          bhs.s     OSIntEnter_3
                    2159   ; OSIntNesting++;                      /* Increment ISR nesting level                        */
08000746  5239 0800 2160          addq.b    #1,_OSIntNesting.L
0800074A  0312      
                    2161   OSIntEnter_3:
0800074C  4E75      2162          rts
                    2163   ; }
                    2164   ; }
                    2165   ; }
                    2166   ; /*$PAGE*/
                    2167   ; /*
                    2168   ; *********************************************************************************************************
                    2169   ; *                                              EXIT ISR
                    2170   ; *
                    2171   ; * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
                    2172   ; *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
                    2173   ; *              a new, high-priority task, is ready to run.
                    2174   ; *
                    2175   ; * Arguments  : none
                    2176   ; *
                    2177   ; * Returns    : none
                    2178   ; *
                    2179   ; * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2180   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2181   ; *                 end of the ISR.
                    2182   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    2183   ; *********************************************************************************************************
                    2184   ; */
                    2185   ; void  OSIntExit (void)
                    2186   ; {
                    2187   _OSIntExit:
                    2188   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2189   ; OS_CPU_SR  cpu_sr = 0u;
                    2190   ; #endif
                    2191   ; if (OSRunning == OS_TRUE) {
0800074E  1039 0800 2192          move.b    _OSRunning.L,D0
08000752  0324      
08000754  0C00 0001 2193          cmp.b     #1,D0
08000758  6600 007A 2194          bne       OSIntExit_1
                    2195   ; OS_ENTER_CRITICAL();
0800075C  40E7      2196          dc.w      16615
0800075E  007C      2197          dc.w      124
08000760  0700      2198          dc.w      1792
                    2199   ; if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
08000762  1039 0800 2200          move.b    _OSIntNesting.L,D0
08000766  0312      
08000768  0C00 0000 2201          cmp.b     #0,D0
0800076C  6306      2202          bls.s     OSIntExit_3
                    2203   ; OSIntNesting--;
0800076E  5339 0800 2204          subq.b    #1,_OSIntNesting.L
08000772  0312      
                    2205   OSIntExit_3:
                    2206   ; }
                    2207   ; if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
08000774  1039 0800 2208          move.b    _OSIntNesting.L,D0
08000778  0312      
0800077A  6600 0056 2209          bne       OSIntExit_9
                    2210   ; if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
0800077E  1039 0800 2211          move.b    _OSLockNesting.L,D0
08000782  0314      
08000784  664C      2212          bne.s     OSIntExit_9
                    2213   ; OS_SchedNew();
08000786  4EB9 0800 2214          jsr       @ucos_ii_OS_SchedNew
0800078A  0FEE      
                    2215   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
0800078C  1039 0800 2216          move.b    _OSPrioHighRdy.L,D0
08000790  0318      
08000792  C0BC 0000 2217          and.l     #255,D0
08000796  00FF      
08000798  E588      2218          lsl.l     #2,D0
0800079A  41F9 0800 2219          lea       _OSTCBPrioTbl.L,A0
0800079E  043C      
080007A0  23F0 0800 2220          move.l    0(A0,D0.L),_OSTCBHighRdy.L
080007A4  0800 0434 
                    2221   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
080007A8  1039 0800 2222          move.b    _OSPrioHighRdy.L,D0
080007AC  0318      
080007AE  B039 0800 2223          cmp.b     _OSPrioCur.L,D0
080007B2  0316      
080007B4  671C      2224          beq.s     OSIntExit_9
                    2225   ; #if OS_TASK_PROFILE_EN > 0u
                    2226   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
080007B6  2039 0800 2227          move.l    _OSTCBHighRdy.L,D0
080007BA  0434      
080007BC  0680 0000 2228          add.l     #58,D0
080007C0  003A      
080007C2  2040      2229          move.l    D0,A0
080007C4  5290      2230          addq.l    #1,(A0)
                    2231   ; #endif
                    2232   ; OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
080007C6  52B9 0800 2233          addq.l    #1,_OSCtxSwCtr.L
080007CA  00E2      
                    2234   ; OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
080007CC  4EB9 0800 2235          jsr       _OSIntCtxSw
080007D0  0088      
                    2236   OSIntExit_9:
                    2237   ; }
                    2238   ; }
                    2239   ; }
                    2240   ; OS_EXIT_CRITICAL();
080007D2  46DF      2241          dc.w      18143
                    2242   OSIntExit_1:
080007D4  4E75      2243          rts
                    2244   ; }
                    2245   ; }
                    2246   ; /*$PAGE*/
                    2247   ; /*
                    2248   ; *********************************************************************************************************
                    2249   ; *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
                    2250   ; *
                    2251   ; * Description: This function is called by the application code to indicate that all initialization has
                    2252   ; *              been completed and that kernel objects are no longer allowed to be created.
                    2253   ; *
                    2254   ; * Arguments  : none
                    2255   ; *
                    2256   ; * Returns    : none
                    2257   ; *
                    2258   ; * Note(s)    : 1) You should call this function when you no longer want to allow application code to
                    2259   ; *                 create kernel objects.
                    2260   ; *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
                    2261   ; *********************************************************************************************************
                    2262   ; */
                    2263   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    2264   ; void  OSSafetyCriticalStart (void)
                    2265   ; {
                    2266   ; OSSafetyCriticalStartFlag = OS_TRUE;
                    2267   ; }
                    2268   ; #endif
                    2269   ; /*$PAGE*/
                    2270   ; /*
                    2271   ; *********************************************************************************************************
                    2272   ; *                                         PREVENT SCHEDULING
                    2273   ; *
                    2274   ; * Description: This function is used to prevent rescheduling to take place.  This allows your application
                    2275   ; *              to prevent context switches until you are ready to permit context switching.
                    2276   ; *
                    2277   ; * Arguments  : none
                    2278   ; *
                    2279   ; * Returns    : none
                    2280   ; *
                    2281   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2282   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2283   ; *********************************************************************************************************
                    2284   ; */
                    2285   ; #if OS_SCHED_LOCK_EN > 0u
                    2286   ; void  OSSchedLock (void)
                    2287   ; {
                    2288   _OSSchedLock:
                    2289   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2290   ; OS_CPU_SR  cpu_sr = 0u;
                    2291   ; #endif
                    2292   ; if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
080007D6  1039 0800 2293          move.b    _OSRunning.L,D0
080007DA  0324      
080007DC  0C00 0001 2294          cmp.b     #1,D0
080007E0  6622      2295          bne.s     OSSchedLock_1
                    2296   ; OS_ENTER_CRITICAL();
080007E2  40E7      2297          dc.w      16615
080007E4  007C      2298          dc.w      124
080007E6  0700      2299          dc.w      1792
                    2300   ; if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
080007E8  1039 0800 2301          move.b    _OSIntNesting.L,D0
080007EC  0312      
080007EE  6612      2302          bne.s     OSSchedLock_5
                    2303   ; if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
080007F0  1039 0800 2304          move.b    _OSLockNesting.L,D0
080007F4  0314      
080007F6  0C00 00FF 2305          cmp.b     #255,D0
080007FA  6406      2306          bhs.s     OSSchedLock_5
                    2307   ; OSLockNesting++;                 /* Increment lock nesting level                       */
080007FC  5239 0800 2308          addq.b    #1,_OSLockNesting.L
08000800  0314      
                    2309   OSSchedLock_5:
                    2310   ; }
                    2311   ; }
                    2312   ; OS_EXIT_CRITICAL();
08000802  46DF      2313          dc.w      18143
                    2314   OSSchedLock_1:
08000804  4E75      2315          rts
                    2316   ; }
                    2317   ; }
                    2318   ; #endif
                    2319   ; /*$PAGE*/
                    2320   ; /*
                    2321   ; *********************************************************************************************************
                    2322   ; *                                          ENABLE SCHEDULING
                    2323   ; *
                    2324   ; * Description: This function is used to re-allow rescheduling.
                    2325   ; *
                    2326   ; * Arguments  : none
                    2327   ; *
                    2328   ; * Returns    : none
                    2329   ; *
                    2330   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2331   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2332   ; *********************************************************************************************************
                    2333   ; */
                    2334   ; #if OS_SCHED_LOCK_EN > 0u
                    2335   ; void  OSSchedUnlock (void)
                    2336   ; {
                    2337   _OSSchedUnlock:
                    2338   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2339   ; OS_CPU_SR  cpu_sr = 0u;
                    2340   ; #endif
                    2341   ; if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
08000806  1039 0800 2342          move.b    _OSRunning.L,D0
0800080A  0324      
0800080C  0C00 0001 2343          cmp.b     #1,D0
08000810  6600 003E 2344          bne       OSSchedUnlock_4
                    2345   ; OS_ENTER_CRITICAL();
08000814  40E7      2346          dc.w      16615
08000816  007C      2347          dc.w      124
08000818  0700      2348          dc.w      1792
                    2349   ; if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
0800081A  1039 0800 2350          move.b    _OSIntNesting.L,D0
0800081E  0312      
08000820  662C      2351          bne.s     OSSchedUnlock_3
                    2352   ; if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
08000822  1039 0800 2353          move.b    _OSLockNesting.L,D0
08000826  0314      
08000828  0C00 0000 2354          cmp.b     #0,D0
0800082C  631C      2355          bls.s     OSSchedUnlock_5
                    2356   ; OSLockNesting--;                           /* Decrement lock nesting level             */
0800082E  5339 0800 2357          subq.b    #1,_OSLockNesting.L
08000832  0314      
                    2358   ; if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
08000834  1039 0800 2359          move.b    _OSLockNesting.L,D0
08000838  0314      
0800083A  660A      2360          bne.s     OSSchedUnlock_7
                    2361   ; OS_EXIT_CRITICAL();
0800083C  46DF      2362          dc.w      18143
                    2363   ; OS_Sched();                            /* See if a HPT is ready                    */
0800083E  4EB9 0800 2364          jsr       _OS_Sched
08000842  0F8A      
08000844  6002      2365          bra.s     OSSchedUnlock_8
                    2366   OSSchedUnlock_7:
                    2367   ; } else {
                    2368   ; OS_EXIT_CRITICAL();
08000846  46DF      2369          dc.w      18143
                    2370   OSSchedUnlock_8:
08000848  6002      2371          bra.s     OSSchedUnlock_6
                    2372   OSSchedUnlock_5:
                    2373   ; }
                    2374   ; } else {
                    2375   ; OS_EXIT_CRITICAL();
0800084A  46DF      2376          dc.w      18143
                    2377   OSSchedUnlock_6:
0800084C  6002      2378          bra.s     OSSchedUnlock_4
                    2379   OSSchedUnlock_3:
                    2380   ; }
                    2381   ; } else {
                    2382   ; OS_EXIT_CRITICAL();
0800084E  46DF      2383          dc.w      18143
                    2384   OSSchedUnlock_4:
08000850  4E75      2385          rts
                    2386   ; }
                    2387   ; }
                    2388   ; }
                    2389   ; #endif
                    2390   ; /*$PAGE*/
                    2391   ; /*
                    2392   ; *********************************************************************************************************
                    2393   ; *                                         START MULTITASKING
                    2394   ; *
                    2395   ; * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
                    2396   ; *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
                    2397   ; *              and you MUST have created at least one task.
                    2398   ; *
                    2399   ; * Arguments  : none
                    2400   ; *
                    2401   ; * Returns    : none
                    2402   ; *
                    2403   ; * Note       : OSStartHighRdy() MUST:
                    2404   ; *                 a) Call OSTaskSwHook() then,
                    2405   ; *                 b) Set OSRunning to OS_TRUE.
                    2406   ; *                 c) Load the context of the task pointed to by OSTCBHighRdy.
                    2407   ; *                 d_ Execute the task.
                    2408   ; *********************************************************************************************************
                    2409   ; */
                    2410   ; void  OSStart (void)
                    2411   ; {
                    2412   _OSStart:
                    2413   ; if (OSRunning == OS_FALSE) {
08000852  1039 0800 2414          move.b    _OSRunning.L,D0
08000856  0324      
08000858  663C      2415          bne.s     OSStart_1
                    2416   ; OS_SchedNew();                               /* Find highest priority's task priority number   */
0800085A  4EB9 0800 2417          jsr       @ucos_ii_OS_SchedNew
0800085E  0FEE      
                    2418   ; OSPrioCur     = OSPrioHighRdy;
08000860  13F9 0800 2419          move.b    _OSPrioHighRdy.L,_OSPrioCur.L
08000864  0318 0800 
08000868  0316      
                    2420   ; OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
0800086A  1039 0800 2421          move.b    _OSPrioHighRdy.L,D0
0800086E  0318      
08000870  C0BC 0000 2422          and.l     #255,D0
08000874  00FF      
08000876  E588      2423          lsl.l     #2,D0
08000878  41F9 0800 2424          lea       _OSTCBPrioTbl.L,A0
0800087C  043C      
0800087E  23F0 0800 2425          move.l    0(A0,D0.L),_OSTCBHighRdy.L
08000882  0800 0434 
                    2426   ; OSTCBCur      = OSTCBHighRdy;
08000886  23F9 0800 2427          move.l    _OSTCBHighRdy.L,_OSTCBCur.L
0800088A  0434 0800 
0800088E  042C      
                    2428   ; OSStartHighRdy();                            /* Execute target specific code to start task     */
08000890  4EB9 0800 2429          jsr       _OSStartHighRdy
08000894  003E      
                    2430   OSStart_1:
08000896  4E75      2431          rts
                    2432   ; }
                    2433   ; }
                    2434   ; /*$PAGE*/
                    2435   ; /*
                    2436   ; *********************************************************************************************************
                    2437   ; *                                      STATISTICS INITIALIZATION
                    2438   ; *
                    2439   ; * Description: This function is called by your application to establish CPU usage by first determining
                    2440   ; *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
                    2441   ; *              during that time.  CPU usage is then determined by a low priority task which keeps track
                    2442   ; *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
                    2443   ; *              determined by:
                    2444   ; *
                    2445   ; *                                             OSIdleCtr
                    2446   ; *                 CPU Usage (%) = 100 * (1 - ------------)
                    2447   ; *                                            OSIdleCtrMax
                    2448   ; *
                    2449   ; * Arguments  : none
                    2450   ; *
                    2451   ; * Returns    : none
                    2452   ; *********************************************************************************************************
                    2453   ; */
                    2454   ; #if OS_TASK_STAT_EN > 0u
                    2455   ; void  OSStatInit (void)
                    2456   ; {
                    2457   _OSStatInit:
                    2458   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2459   ; OS_CPU_SR  cpu_sr = 0u;
                    2460   ; #endif
                    2461   ; OSTimeDly(2u);                               /* Synchronize with clock tick                        */
08000898  4878 0002 2462          pea       2
0800089C  4EB9 0800 2463          jsr       _OSTimeDly
080008A0  4828      
080008A2  584F      2464          addq.w    #4,A7
                    2465   ; OS_ENTER_CRITICAL();
080008A4  40E7      2466          dc.w      16615
080008A6  007C      2467          dc.w      124
080008A8  0700      2468          dc.w      1792
                    2469   ; OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
080008AA  42B9 0800 2470          clr.l     _OSIdleCtr.L
080008AE  0328      
                    2471   ; OS_EXIT_CRITICAL();
080008B0  46DF      2472          dc.w      18143
                    2473   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
080008B2  4878 000A 2474          pea       10
080008B6  4EB9 0800 2475          jsr       _OSTimeDly
080008BA  4828      
080008BC  584F      2476          addq.w    #4,A7
                    2477   ; OS_ENTER_CRITICAL();
080008BE  40E7      2478          dc.w      16615
080008C0  007C      2479          dc.w      124
080008C2  0700      2480          dc.w      1792
                    2481   ; OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
080008C4  23F9 0800 2482          move.l    _OSIdleCtr.L,_OSIdleCtrMax.L
080008C8  0328 0800 
080008CC  0208      
                    2483   ; OSStatRdy    = OS_TRUE;
080008CE  13FC 0001 2484          move.b    #1,_OSStatRdy.L
080008D2  0800 0210 
                    2485   ; OS_EXIT_CRITICAL();
080008D6  46DF      2486          dc.w      18143
080008D8  4E75      2487          rts
                    2488   ; }
                    2489   ; #endif
                    2490   ; /*$PAGE*/
                    2491   ; /*
                    2492   ; *********************************************************************************************************
                    2493   ; *                                         PROCESS SYSTEM TICK
                    2494   ; *
                    2495   ; * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
                    2496   ; *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
                    2497   ; *              called by a high priority task.
                    2498   ; *
                    2499   ; * Arguments  : none
                    2500   ; *
                    2501   ; * Returns    : none
                    2502   ; *********************************************************************************************************
                    2503   ; */
                    2504   ; void  OSTimeTick (void)
                    2505   ; {
                    2506   _OSTimeTick:
080008DA  2F02      2507          move.l    D2,-(A7)
                    2508   ; OS_TCB    *ptcb;
                    2509   ; #if OS_TICK_STEP_EN > 0u
                    2510   ; BOOLEAN    step;
                    2511   ; #endif
                    2512   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
                    2513   ; OS_CPU_SR  cpu_sr = 0u;
                    2514   ; #endif
                    2515   ; #if OS_TIME_TICK_HOOK_EN > 0u
                    2516   ; OSTimeTickHook();                                      /* Call user definable hook                     */
080008DC  4EB9 0800 2517          jsr       _OSTimeTickHook
080008E0  0282      
                    2518   ; #endif
                    2519   ; #if OS_TIME_GET_SET_EN > 0u
                    2520   ; OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
080008E2  40E7      2521          dc.w      16615
080008E4  007C      2522          dc.w      124
080008E6  0700      2523          dc.w      1792
                    2524   ; OSTime++;
080008E8  52B9 0800 2525          addq.l    #1,_OSTime.L
080008EC  0D82      
                    2526   ; OS_EXIT_CRITICAL();
080008EE  46DF      2527          dc.w      18143
                    2528   ; #endif
                    2529   ; if (OSRunning == OS_TRUE) {
080008F0  1039 0800 2530          move.b    _OSRunning.L,D0
080008F4  0324      
080008F6  0C00 0001 2531          cmp.b     #1,D0
080008FA  6600 00A2 2532          bne       OSTimeTick_5
                    2533   ; #if OS_TICK_STEP_EN > 0u
                    2534   ; switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
                    2535   ; case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                    2536   ; step = OS_TRUE;
                    2537   ; break;
                    2538   ; case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                    2539   ; step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
                    2540   ; break;
                    2541   ; case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                    2542   ; step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
                    2543   ; OSTickStepState = OS_TICK_STEP_WAIT;
                    2544   ; break;
                    2545   ; default:                                       /* Invalid case, correct situation              */
                    2546   ; step            = OS_TRUE;
                    2547   ; OSTickStepState = OS_TICK_STEP_DIS;
                    2548   ; break;
                    2549   ; }
                    2550   ; if (step == OS_FALSE) {                            /* Return if waiting for step command           */
                    2551   ; return;
                    2552   ; }
                    2553   ; #endif
                    2554   ; ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
080008FE  2439 0800 2555          move.l    _OSTCBList.L,D2
08000902  0438      
                    2556   ; while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
                    2557   OSTimeTick_3:
08000904  2042      2558          move.l    D2,A0
08000906  1028 0034 2559          move.b    52(A0),D0
0800090A  0C00 003F 2560          cmp.b     #63,D0
0800090E  6700 008E 2561          beq       OSTimeTick_5
                    2562   ; OS_ENTER_CRITICAL();
08000912  40E7      2563          dc.w      16615
08000914  007C      2564          dc.w      124
08000916  0700      2565          dc.w      1792
                    2566   ; if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
08000918  2042      2567          move.l    D2,A0
0800091A  2028 002E 2568          move.l    46(A0),D0
0800091E  6700 0072 2569          beq       OSTimeTick_12
                    2570   ; ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
08000922  2002      2571          move.l    D2,D0
08000924  0680 0000 2572          add.l     #46,D0
08000928  002E      
0800092A  2040      2573          move.l    D0,A0
0800092C  5390      2574          subq.l    #1,(A0)
                    2575   ; if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
0800092E  2042      2576          move.l    D2,A0
08000930  2028 002E 2577          move.l    46(A0),D0
08000934  6600 005C 2578          bne       OSTimeTick_12
                    2579   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
08000938  2042      2580          move.l    D2,A0
0800093A  1028 0032 2581          move.b    50(A0),D0
0800093E  C03C 0037 2582          and.b     #55,D0
08000942  6714      2583          beq.s     OSTimeTick_10
                    2584   ; ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
08000944  2042      2585          move.l    D2,A0
08000946  7037      2586          moveq     #55,D0
08000948  4600      2587          not.b     D0
0800094A  C128 0032 2588          and.b     D0,50(A0)
                    2589   ; ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
0800094E  2042      2590          move.l    D2,A0
08000950  117C 0001 2591          move.b    #1,51(A0)
08000954  0033      
08000956  6006      2592          bra.s     OSTimeTick_11
                    2593   OSTimeTick_10:
                    2594   ; } else {
                    2595   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
08000958  2042      2596          move.l    D2,A0
0800095A  4228 0033 2597          clr.b     51(A0)
                    2598   OSTimeTick_11:
                    2599   ; }
                    2600   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
0800095E  2042      2601          move.l    D2,A0
08000960  1028 0032 2602          move.b    50(A0),D0
08000964  C03C 0008 2603          and.b     #8,D0
08000968  6628      2604          bne.s     OSTimeTick_12
                    2605   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
0800096A  2042      2606          move.l    D2,A0
0800096C  1028 0038 2607          move.b    56(A0),D0
08000970  8139 0800 2608          or.b      D0,_OSRdyGrp.L
08000974  031A      
                    2609   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
08000976  2042      2610          move.l    D2,A0
08000978  1028 0036 2611          move.b    54(A0),D0
0800097C  C0BC 0000 2612          and.l     #255,D0
08000980  00FF      
08000982  41F9 0800 2613          lea       _OSRdyTbl.L,A0
08000986  031C      
08000988  2242      2614          move.l    D2,A1
0800098A  1229 0037 2615          move.b    55(A1),D1
0800098E  8330 0800 2616          or.b      D1,0(A0,D0.L)
                    2617   OSTimeTick_12:
                    2618   ; }
                    2619   ; }
                    2620   ; }
                    2621   ; ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
08000992  2042      2622          move.l    D2,A0
08000994  2428 0014 2623          move.l    20(A0),D2
                    2624   ; OS_EXIT_CRITICAL();
08000998  46DF      2625          dc.w      18143
0800099A  6000 FF68 2626          bra       OSTimeTick_3
                    2627   OSTimeTick_5:
0800099E  241F      2628          move.l    (A7)+,D2
080009A0  4E75      2629          rts
                    2630   ; }
                    2631   ; }
                    2632   ; }
                    2633   ; /*$PAGE*/
                    2634   ; /*
                    2635   ; *********************************************************************************************************
                    2636   ; *                                             GET VERSION
                    2637   ; *
                    2638   ; * Description: This function is used to return the version number of uC/OS-II.  The returned value 
                    2639   ; *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
                    2640   ; *              2.01.00 would be returned as 20100.
                    2641   ; *
                    2642   ; * Arguments  : none
                    2643   ; *
                    2644   ; * Returns    : The version number of uC/OS-II multiplied by 10000.
                    2645   ; *********************************************************************************************************
                    2646   ; */
                    2647   ; INT16U  OSVersion (void)
                    2648   ; {
                    2649   _OSVersion:
                    2650   ; return (OS_VERSION);
080009A2  303C 7217 2651          move.w    #29207,D0
080009A6  4E75      2652          rts
                    2653   ; }
                    2654   ; /*$PAGE*/
                    2655   ; /*
                    2656   ; *********************************************************************************************************
                    2657   ; *                                           DUMMY FUNCTION
                    2658   ; *
                    2659   ; * Description: This function doesn't do anything.  It is called by OSTaskDel().
                    2660   ; *
                    2661   ; * Arguments  : none
                    2662   ; *
                    2663   ; * Returns    : none
                    2664   ; *********************************************************************************************************
                    2665   ; */
                    2666   ; #if OS_TASK_DEL_EN > 0u
                    2667   ; void  OS_Dummy (void)
                    2668   ; {
                    2669   _OS_Dummy:
080009A8  4E75      2670          rts
                    2671   ; }
                    2672   ; #endif
                    2673   ; /*$PAGE*/
                    2674   ; /*
                    2675   ; *********************************************************************************************************
                    2676   ; *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
                    2677   ; *
                    2678   ; * Description: This function is called by other uC/OS-II services and is used to ready a task that was
                    2679   ; *              waiting for an event to occur.
                    2680   ; *
                    2681   ; * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
                    2682   ; *
                    2683   ; *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
                    2684   ; *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
                    2685   ; *                          service functions.
                    2686   ; *
                    2687   ; *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
                    2688   ; *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
                    2689   ; *
                    2690   ; *              pend_stat   is used to indicate the readied task's pending status:
                    2691   ; *
                    2692   ; *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
                    2693   ; *                                               an abort.
                    2694   ; *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
                    2695   ; *
                    2696   ; * Returns    : none
                    2697   ; *
                    2698   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2699   ; *********************************************************************************************************
                    2700   ; */
                    2701   ; #if (OS_EVENT_EN)
                    2702   ; INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                    2703   ; void      *pmsg,
                    2704   ; INT8U      msk,
                    2705   ; INT8U      pend_stat)
                    2706   ; {
                    2707   _OS_EventTaskRdy:
080009AA  4E56 FFFC 2708          link      A6,#-4
080009AE  48E7 3C00 2709          movem.l   D2/D3/D4/D5,-(A7)
080009B2  262E 0008 2710          move.l    8(A6),D3
                    2711   ; OS_TCB   *ptcb;
                    2712   ; INT8U     y;
                    2713   ; INT8U     x;
                    2714   ; INT8U     prio;
                    2715   ; #if OS_LOWEST_PRIO > 63u
                    2716   ; OS_PRIO  *ptbl;
                    2717   ; #endif
                    2718   ; #if OS_LOWEST_PRIO <= 63u
                    2719   ; y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
080009B6  2043      2720          move.l    D3,A0
080009B8  1028 0008 2721          move.b    8(A0),D0
080009BC  C0BC 0000 2722          and.l     #255,D0
080009C0  00FF      
080009C2  41F9 0800 2723          lea       _OSUnMapTbl.L,A0
080009C6  5850      
080009C8  1830 0800 2724          move.b    0(A0,D0.L),D4
                    2725   ; x    = OSUnMapTbl[pevent->OSEventTbl[y]];
080009CC  2043      2726          move.l    D3,A0
080009CE  C8BC 0000 2727          and.l     #255,D4
080009D2  00FF      
080009D4  D1C4      2728          add.l     D4,A0
080009D6  1028 000A 2729          move.b    10(A0),D0
080009DA  C0BC 0000 2730          and.l     #255,D0
080009DE  00FF      
080009E0  41F9 0800 2731          lea       _OSUnMapTbl.L,A0
080009E4  5850      
080009E6  1D70 0800 2732          move.b    0(A0,D0.L),-1(A6)
080009EA  FFFF      
                    2733   ; prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
080009EC  1004      2734          move.b    D4,D0
080009EE  E708      2735          lsl.b     #3,D0
080009F0  D02E FFFF 2736          add.b     -1(A6),D0
080009F4  1A00      2737          move.b    D0,D5
                    2738   ; #else
                    2739   ; if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
                    2740   ; y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
                    2741   ; } else {
                    2742   ; y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
                    2743   ; }
                    2744   ; ptbl = &pevent->OSEventTbl[y];
                    2745   ; if ((*ptbl & 0xFFu) != 0u) {
                    2746   ; x = OSUnMapTbl[*ptbl & 0xFFu];
                    2747   ; } else {
                    2748   ; x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
                    2749   ; }
                    2750   ; prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
                    2751   ; #endif
                    2752   ; ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
080009F6  CABC 0000 2753          and.l     #255,D5
080009FA  00FF      
080009FC  2005      2754          move.l    D5,D0
080009FE  E588      2755          lsl.l     #2,D0
08000A00  41F9 0800 2756          lea       _OSTCBPrioTbl.L,A0
08000A04  043C      
08000A06  2430 0800 2757          move.l    0(A0,D0.L),D2
                    2758   ; ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
08000A0A  2042      2759          move.l    D2,A0
08000A0C  42A8 002E 2760          clr.l     46(A0)
                    2761   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
                    2762   ; ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
08000A10  2042      2763          move.l    D2,A0
08000A12  216E 000C 2764          move.l    12(A6),36(A0)
08000A16  0024      
                    2765   ; #else
                    2766   ; pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
                    2767   ; #endif
                    2768   ; ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
08000A18  2042      2769          move.l    D2,A0
08000A1A  102E 0013 2770          move.b    19(A6),D0
08000A1E  4600      2771          not.b     D0
08000A20  C128 0032 2772          and.b     D0,50(A0)
                    2773   ; ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
08000A24  2042      2774          move.l    D2,A0
08000A26  116E 0017 2775          move.b    23(A6),51(A0)
08000A2A  0033      
                    2776   ; /* See if task is ready (could be susp'd)      */
                    2777   ; if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
08000A2C  2042      2778          move.l    D2,A0
08000A2E  1028 0032 2779          move.b    50(A0),D0
08000A32  C03C 0008 2780          and.b     #8,D0
08000A36  6622      2781          bne.s     OS_EventTaskRdy_1
                    2782   ; OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
08000A38  2042      2783          move.l    D2,A0
08000A3A  1028 0038 2784          move.b    56(A0),D0
08000A3E  8139 0800 2785          or.b      D0,_OSRdyGrp.L
08000A42  031A      
                    2786   ; OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
08000A44  C8BC 0000 2787          and.l     #255,D4
08000A48  00FF      
08000A4A  41F9 0800 2788          lea       _OSRdyTbl.L,A0
08000A4E  031C      
08000A50  2242      2789          move.l    D2,A1
08000A52  1029 0037 2790          move.b    55(A1),D0
08000A56  8130 4800 2791          or.b      D0,0(A0,D4.L)
                    2792   OS_EventTaskRdy_1:
                    2793   ; }
                    2794   ; OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
08000A5A  2F03      2795          move.l    D3,-(A7)
08000A5C  2F02      2796          move.l    D2,-(A7)
08000A5E  4EB9 0800 2797          jsr       _OS_EventTaskRemove
08000A62  0BB0      
08000A64  504F      2798          addq.w    #8,A7
                    2799   ; #if (OS_EVENT_MULTI_EN > 0u)
                    2800   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
08000A66  2042      2801          move.l    D2,A0
08000A68  2028 0020 2802          move.l    32(A0),D0
08000A6C  6716      2803          beq.s     OS_EventTaskRdy_3
                    2804   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
08000A6E  2042      2805          move.l    D2,A0
08000A70  2F28 0020 2806          move.l    32(A0),-(A7)
08000A74  2F02      2807          move.l    D2,-(A7)
08000A76  4EB9 0800 2808          jsr       _OS_EventTaskRemoveMulti
08000A7A  0C02      
08000A7C  504F      2809          addq.w    #8,A7
                    2810   ; ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
08000A7E  2042      2811          move.l    D2,A0
08000A80  2143 001C 2812          move.l    D3,28(A0)
                    2813   OS_EventTaskRdy_3:
                    2814   ; }
                    2815   ; #endif
                    2816   ; return (prio);
08000A84  1005      2817          move.b    D5,D0
08000A86  4CDF 003C 2818          movem.l   (A7)+,D2/D3/D4/D5
08000A8A  4E5E      2819          unlk      A6
08000A8C  4E75      2820          rts
                    2821   ; }
                    2822   ; #endif
                    2823   ; /*$PAGE*/
                    2824   ; /*
                    2825   ; *********************************************************************************************************
                    2826   ; *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
                    2827   ; *
                    2828   ; * Description: This function is called by other uC/OS-II services to suspend a task because an event has
                    2829   ; *              not occurred.
                    2830   ; *
                    2831   ; * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
                    2832   ; *
                    2833   ; * Returns    : none
                    2834   ; *
                    2835   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2836   ; *********************************************************************************************************
                    2837   ; */
                    2838   ; #if (OS_EVENT_EN)
                    2839   ; void  OS_EventTaskWait (OS_EVENT *pevent)
                    2840   ; {
                    2841   _OS_EventTaskWait:
08000A8E  4E56 0000 2842          link      A6,#0
08000A92  48E7 3020 2843          movem.l   D2/D3/A2,-(A7)
08000A96  45F9 0800 2844          lea       _OSTCBCur.L,A2
08000A9A  042C      
08000A9C  262E 0008 2845          move.l    8(A6),D3
                    2846   ; INT8U  y;
                    2847   ; OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
08000AA0  2052      2848          move.l    (A2),A0
08000AA2  2143 001C 2849          move.l    D3,28(A0)
                    2850   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
08000AA6  2043      2851          move.l    D3,A0
08000AA8  2252      2852          move.l    (A2),A1
08000AAA  1029 0036 2853          move.b    54(A1),D0
08000AAE  C0BC 0000 2854          and.l     #255,D0
08000AB2  00FF      
08000AB4  D1C0      2855          add.l     D0,A0
08000AB6  2252      2856          move.l    (A2),A1
08000AB8  1029 0037 2857          move.b    55(A1),D0
08000ABC  8128 000A 2858          or.b      D0,10(A0)
                    2859   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
08000AC0  2043      2860          move.l    D3,A0
08000AC2  2252      2861          move.l    (A2),A1
08000AC4  1029 0038 2862          move.b    56(A1),D0
08000AC8  8128 0008 2863          or.b      D0,8(A0)
                    2864   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
08000ACC  2052      2865          move.l    (A2),A0
08000ACE  1428 0036 2866          move.b    54(A0),D2
                    2867   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
08000AD2  C4BC 0000 2868          and.l     #255,D2
08000AD6  00FF      
08000AD8  41F9 0800 2869          lea       _OSRdyTbl.L,A0
08000ADC  031C      
08000ADE  2252      2870          move.l    (A2),A1
08000AE0  1029 0037 2871          move.b    55(A1),D0
08000AE4  4600      2872          not.b     D0
08000AE6  C130 2800 2873          and.b     D0,0(A0,D2.L)
                    2874   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
08000AEA  C4BC 0000 2875          and.l     #255,D2
08000AEE  00FF      
08000AF0  41F9 0800 2876          lea       _OSRdyTbl.L,A0
08000AF4  031C      
08000AF6  1030 2800 2877          move.b    0(A0,D2.L),D0
08000AFA  660E      2878          bne.s     OS_EventTaskWait_1
                    2879   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
08000AFC  2052      2880          move.l    (A2),A0
08000AFE  1028 0038 2881          move.b    56(A0),D0
08000B02  4600      2882          not.b     D0
08000B04  C139 0800 2883          and.b     D0,_OSRdyGrp.L
08000B08  031A      
                    2884   OS_EventTaskWait_1:
08000B0A  4CDF 040C 2885          movem.l   (A7)+,D2/D3/A2
08000B0E  4E5E      2886          unlk      A6
08000B10  4E75      2887          rts
                    2888   ; }
                    2889   ; }
                    2890   ; #endif
                    2891   ; /*$PAGE*/
                    2892   ; /*
                    2893   ; *********************************************************************************************************
                    2894   ; *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
                    2895   ; *
                    2896   ; * Description: This function is called by other uC/OS-II services to suspend a task because any one of
                    2897   ; *              multiple events has not occurred.
                    2898   ; *
                    2899   ; * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
                    2900   ; *                               which the task will be waiting for.
                    2901   ; *
                    2902   ; * Returns    : none.
                    2903   ; *
                    2904   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2905   ; *********************************************************************************************************
                    2906   ; */
                    2907   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    2908   ; void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
                    2909   ; {
                    2910   _OS_EventTaskWaitMulti:
08000B12  4E56 0000 2911          link      A6,#0
08000B16  48E7 3820 2912          movem.l   D2/D3/D4/A2,-(A7)
08000B1A  45F9 0800 2913          lea       _OSTCBCur.L,A2
08000B1E  042C      
                    2914   ; OS_EVENT **pevents;
                    2915   ; OS_EVENT  *pevent;
                    2916   ; INT8U      y;
                    2917   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
08000B20  2052      2918          move.l    (A2),A0
08000B22  42A8 001C 2919          clr.l     28(A0)
                    2920   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
08000B26  2052      2921          move.l    (A2),A0
08000B28  216E 0008 2922          move.l    8(A6),32(A0)
08000B2C  0020      
                    2923   ; pevents =  pevents_wait;
08000B2E  262E 0008 2924          move.l    8(A6),D3
                    2925   ; pevent  = *pevents;
08000B32  2043      2926          move.l    D3,A0
08000B34  2410      2927          move.l    (A0),D2
                    2928   ; while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
                    2929   OS_EventTaskWaitMulti_1:
08000B36  4A82      2930          tst.l     D2
08000B38  6700 0030 2931          beq       OS_EventTaskWaitMulti_3
                    2932   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
08000B3C  2042      2933          move.l    D2,A0
08000B3E  2252      2934          move.l    (A2),A1
08000B40  1029 0036 2935          move.b    54(A1),D0
08000B44  C0BC 0000 2936          and.l     #255,D0
08000B48  00FF      
08000B4A  D1C0      2937          add.l     D0,A0
08000B4C  2252      2938          move.l    (A2),A1
08000B4E  1029 0037 2939          move.b    55(A1),D0
08000B52  8128 000A 2940          or.b      D0,10(A0)
                    2941   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
08000B56  2042      2942          move.l    D2,A0
08000B58  2252      2943          move.l    (A2),A1
08000B5A  1029 0038 2944          move.b    56(A1),D0
08000B5E  8128 0008 2945          or.b      D0,8(A0)
                    2946   ; pevents++;
08000B62  5883      2947          addq.l    #4,D3
                    2948   ; pevent = *pevents;
08000B64  2043      2949          move.l    D3,A0
08000B66  2410      2950          move.l    (A0),D2
08000B68  60CC      2951          bra       OS_EventTaskWaitMulti_1
                    2952   OS_EventTaskWaitMulti_3:
                    2953   ; }
                    2954   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
08000B6A  2052      2955          move.l    (A2),A0
08000B6C  1828 0036 2956          move.b    54(A0),D4
                    2957   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
08000B70  C8BC 0000 2958          and.l     #255,D4
08000B74  00FF      
08000B76  41F9 0800 2959          lea       _OSRdyTbl.L,A0
08000B7A  031C      
08000B7C  2252      2960          move.l    (A2),A1
08000B7E  1029 0037 2961          move.b    55(A1),D0
08000B82  4600      2962          not.b     D0
08000B84  C130 4800 2963          and.b     D0,0(A0,D4.L)
                    2964   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
08000B88  C8BC 0000 2965          and.l     #255,D4
08000B8C  00FF      
08000B8E  41F9 0800 2966          lea       _OSRdyTbl.L,A0
08000B92  031C      
08000B94  1030 4800 2967          move.b    0(A0,D4.L),D0
08000B98  660E      2968          bne.s     OS_EventTaskWaitMulti_4
                    2969   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
08000B9A  2052      2970          move.l    (A2),A0
08000B9C  1028 0038 2971          move.b    56(A0),D0
08000BA0  4600      2972          not.b     D0
08000BA2  C139 0800 2973          and.b     D0,_OSRdyGrp.L
08000BA6  031A      
                    2974   OS_EventTaskWaitMulti_4:
08000BA8  4CDF 041C 2975          movem.l   (A7)+,D2/D3/D4/A2
08000BAC  4E5E      2976          unlk      A6
08000BAE  4E75      2977          rts
                    2978   ; }
                    2979   ; }
                    2980   ; #endif
                    2981   ; /*$PAGE*/
                    2982   ; /*
                    2983   ; *********************************************************************************************************
                    2984   ; *                                  REMOVE TASK FROM EVENT WAIT LIST
                    2985   ; *
                    2986   ; * Description: Remove a task from an event's wait list.
                    2987   ; *
                    2988   ; * Arguments  : ptcb     is a pointer to the task to remove.
                    2989   ; *
                    2990   ; *              pevent   is a pointer to the event control block.
                    2991   ; *
                    2992   ; * Returns    : none
                    2993   ; *
                    2994   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2995   ; *********************************************************************************************************
                    2996   ; */
                    2997   ; #if (OS_EVENT_EN)
                    2998   ; void  OS_EventTaskRemove (OS_TCB   *ptcb,
                    2999   ; OS_EVENT *pevent)
                    3000   ; {
                    3001   _OS_EventTaskRemove:
08000BB0  4E56 0000 3002          link      A6,#0
08000BB4  48E7 3800 3003          movem.l   D2/D3/D4,-(A7)
08000BB8  242E 000C 3004          move.l    12(A6),D2
08000BBC  262E 0008 3005          move.l    8(A6),D3
                    3006   ; INT8U  y;
                    3007   ; y                       =  ptcb->OSTCBY;
08000BC0  2043      3008          move.l    D3,A0
08000BC2  1828 0036 3009          move.b    54(A0),D4
                    3010   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
08000BC6  2042      3011          move.l    D2,A0
08000BC8  C8BC 0000 3012          and.l     #255,D4
08000BCC  00FF      
08000BCE  D1C4      3013          add.l     D4,A0
08000BD0  2243      3014          move.l    D3,A1
08000BD2  1029 0037 3015          move.b    55(A1),D0
08000BD6  4600      3016          not.b     D0
08000BD8  C128 000A 3017          and.b     D0,10(A0)
                    3018   ; if (pevent->OSEventTbl[y] == 0u) {
08000BDC  2042      3019          move.l    D2,A0
08000BDE  C8BC 0000 3020          and.l     #255,D4
08000BE2  00FF      
08000BE4  D1C4      3021          add.l     D4,A0
08000BE6  1028 000A 3022          move.b    10(A0),D0
08000BEA  660E      3023          bne.s     OS_EventTaskRemove_1
                    3024   ; pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
08000BEC  2042      3025          move.l    D2,A0
08000BEE  2243      3026          move.l    D3,A1
08000BF0  1029 0038 3027          move.b    56(A1),D0
08000BF4  4600      3028          not.b     D0
08000BF6  C128 0008 3029          and.b     D0,8(A0)
                    3030   OS_EventTaskRemove_1:
08000BFA  4CDF 001C 3031          movem.l   (A7)+,D2/D3/D4
08000BFE  4E5E      3032          unlk      A6
08000C00  4E75      3033          rts
                    3034   ; }
                    3035   ; }
                    3036   ; #endif
                    3037   ; /*$PAGE*/
                    3038   ; /*
                    3039   ; *********************************************************************************************************
                    3040   ; *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
                    3041   ; *
                    3042   ; * Description: Remove a task from multiple events' wait lists.
                    3043   ; *
                    3044   ; * Arguments  : ptcb             is a pointer to the task to remove.
                    3045   ; *
                    3046   ; *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
                    3047   ; *
                    3048   ; * Returns    : none
                    3049   ; *
                    3050   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3051   ; *********************************************************************************************************
                    3052   ; */
                    3053   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3054   ; void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                    3055   ; OS_EVENT **pevents_multi)
                    3056   ; {
                    3057   _OS_EventTaskRemoveMulti:
08000C02  4E56 FFFC 3058          link      A6,#-4
08000C06  48E7 3C00 3059          movem.l   D2/D3/D4/D5,-(A7)
08000C0A  282E 0008 3060          move.l    8(A6),D4
                    3061   ; OS_EVENT **pevents;
                    3062   ; OS_EVENT  *pevent;
                    3063   ; INT8U      y;
                    3064   ; OS_PRIO    bity;
                    3065   ; OS_PRIO    bitx;
                    3066   ; y       =  ptcb->OSTCBY;
08000C0E  2044      3067          move.l    D4,A0
08000C10  1A28 0036 3068          move.b    54(A0),D5
                    3069   ; bity    =  ptcb->OSTCBBitY;
08000C14  2044      3070          move.l    D4,A0
08000C16  1D68 0038 3071          move.b    56(A0),-2(A6)
08000C1A  FFFE      
                    3072   ; bitx    =  ptcb->OSTCBBitX;
08000C1C  2044      3073          move.l    D4,A0
08000C1E  1D68 0037 3074          move.b    55(A0),-1(A6)
08000C22  FFFF      
                    3075   ; pevents =  pevents_multi;
08000C24  262E 000C 3076          move.l    12(A6),D3
                    3077   ; pevent  = *pevents;
08000C28  2043      3078          move.l    D3,A0
08000C2A  2410      3079          move.l    (A0),D2
                    3080   ; while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
                    3081   OS_EventTaskRemoveMulti_1:
08000C2C  4A82      3082          tst.l     D2
08000C2E  6700 003A 3083          beq       OS_EventTaskRemoveMulti_3
                    3084   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
08000C32  2042      3085          move.l    D2,A0
08000C34  CABC 0000 3086          and.l     #255,D5
08000C38  00FF      
08000C3A  D1C5      3087          add.l     D5,A0
08000C3C  102E FFFF 3088          move.b    -1(A6),D0
08000C40  4600      3089          not.b     D0
08000C42  C128 000A 3090          and.b     D0,10(A0)
                    3091   ; if (pevent->OSEventTbl[y] == 0u) {
08000C46  2042      3092          move.l    D2,A0
08000C48  CABC 0000 3093          and.l     #255,D5
08000C4C  00FF      
08000C4E  D1C5      3094          add.l     D5,A0
08000C50  1028 000A 3095          move.b    10(A0),D0
08000C54  660C      3096          bne.s     OS_EventTaskRemoveMulti_4
                    3097   ; pevent->OSEventGrp &= (OS_PRIO)~bity;
08000C56  2042      3098          move.l    D2,A0
08000C58  102E FFFE 3099          move.b    -2(A6),D0
08000C5C  4600      3100          not.b     D0
08000C5E  C128 0008 3101          and.b     D0,8(A0)
                    3102   OS_EventTaskRemoveMulti_4:
                    3103   ; }
                    3104   ; pevents++;
08000C62  5883      3105          addq.l    #4,D3
                    3106   ; pevent = *pevents;
08000C64  2043      3107          move.l    D3,A0
08000C66  2410      3108          move.l    (A0),D2
08000C68  60C2      3109          bra       OS_EventTaskRemoveMulti_1
                    3110   OS_EventTaskRemoveMulti_3:
08000C6A  4CDF 003C 3111          movem.l   (A7)+,D2/D3/D4/D5
08000C6E  4E5E      3112          unlk      A6
08000C70  4E75      3113          rts
                    3114   ; }
                    3115   ; }
                    3116   ; #endif
                    3117   ; /*$PAGE*/
                    3118   ; /*
                    3119   ; *********************************************************************************************************
                    3120   ; *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
                    3121   ; *
                    3122   ; * Description: This function is called by other uC/OS-II services to initialize the event wait list.
                    3123   ; *
                    3124   ; * Arguments  : pevent    is a pointer to the event control block allocated to the event.
                    3125   ; *
                    3126   ; * Returns    : none
                    3127   ; *
                    3128   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3129   ; *********************************************************************************************************
                    3130   ; */
                    3131   ; #if (OS_EVENT_EN)
                    3132   ; void  OS_EventWaitListInit (OS_EVENT *pevent)
                    3133   ; {
                    3134   _OS_EventWaitListInit:
08000C72  4E56 0000 3135          link      A6,#0
08000C76  2F02      3136          move.l    D2,-(A7)
                    3137   ; INT8U  i;
                    3138   ; pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
08000C78  206E 0008 3139          move.l    8(A6),A0
08000C7C  4228 0008 3140          clr.b     8(A0)
                    3141   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
08000C80  4202      3142          clr.b     D2
                    3143   OS_EventWaitListInit_1:
08000C82  0C02 0008 3144          cmp.b     #8,D2
08000C86  6414      3145          bhs.s     OS_EventWaitListInit_3
                    3146   ; pevent->OSEventTbl[i] = 0u;
08000C88  206E 0008 3147          move.l    8(A6),A0
08000C8C  C4BC 0000 3148          and.l     #255,D2
08000C90  00FF      
08000C92  D1C2      3149          add.l     D2,A0
08000C94  4228 000A 3150          clr.b     10(A0)
08000C98  5202      3151          addq.b    #1,D2
08000C9A  60E6      3152          bra       OS_EventWaitListInit_1
                    3153   OS_EventWaitListInit_3:
08000C9C  241F      3154          move.l    (A7)+,D2
08000C9E  4E5E      3155          unlk      A6
08000CA0  4E75      3156          rts
                    3157   ; }
                    3158   ; }
                    3159   ; #endif
                    3160   ; /*$PAGE*/
                    3161   ; /*
                    3162   ; *********************************************************************************************************
                    3163   ; *                                             INITIALIZATION
                    3164   ; *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
                    3165   ; *
                    3166   ; * Description: This function is called by OSInit() to initialize the free list of event control blocks.
                    3167   ; *
                    3168   ; * Arguments  : none
                    3169   ; *
                    3170   ; * Returns    : none
                    3171   ; *********************************************************************************************************
                    3172   ; */
                    3173   ; static  void  OS_InitEventList (void)
                    3174   ; {
                    3175   @ucos_ii_OS_InitEventList:
08000CA2  4E56 FFF8 3176          link      A6,#-8
08000CA6  48E7 3020 3177          movem.l   D2/D3/A2,-(A7)
08000CAA  45F9 0800 3178          lea       _OSEventTbl.L,A2
08000CAE  00EA      
                    3179   ; #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
                    3180   ; #if (OS_MAX_EVENTS > 1u)
                    3181   ; INT16U     ix;
                    3182   ; INT16U     ix_next;
                    3183   ; OS_EVENT  *pevent1;
                    3184   ; OS_EVENT  *pevent2;
                    3185   ; OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
08000CB0  4878 00DC 3186          pea       220
08000CB4  2F0A      3187          move.l    A2,-(A7)
08000CB6  4EB9 0800 3188          jsr       _OS_MemClr
08000CBA  0F3E      
08000CBC  504F      3189          addq.w    #8,A7
                    3190   ; for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
08000CBE  4243      3191          clr.w     D3
                    3192   @ucos_ii_OS_InitEventList_1:
08000CC0  0C43 0009 3193          cmp.w     #9,D3
08000CC4  6400 004E 3194          bhs       @ucos_ii_OS_InitEventList_3
                    3195   ; ix_next = ix + 1u;
08000CC8  3003      3196          move.w    D3,D0
08000CCA  5240      3197          addq.w    #1,D0
08000CCC  3D40 FFFA 3198          move.w    D0,-6(A6)
                    3199   ; pevent1 = &OSEventTbl[ix];
08000CD0  200A      3200          move.l    A2,D0
08000CD2  C6BC 0000 3201          and.l     #65535,D3
08000CD6  FFFF      
08000CD8  2203      3202          move.l    D3,D1
08000CDA  C3FC 0016 3203          muls      #22,D1
08000CDE  D081      3204          add.l     D1,D0
08000CE0  2400      3205          move.l    D0,D2
                    3206   ; pevent2 = &OSEventTbl[ix_next];
08000CE2  200A      3207          move.l    A2,D0
08000CE4  322E FFFA 3208          move.w    -6(A6),D1
08000CE8  C2BC 0000 3209          and.l     #65535,D1
08000CEC  FFFF      
08000CEE  C3FC 0016 3210          muls      #22,D1
08000CF2  D081      3211          add.l     D1,D0
08000CF4  2D40 FFFC 3212          move.l    D0,-4(A6)
                    3213   ; pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
08000CF8  2042      3214          move.l    D2,A0
08000CFA  4210      3215          clr.b     (A0)
                    3216   ; pevent1->OSEventPtr     = pevent2;
08000CFC  2042      3217          move.l    D2,A0
08000CFE  216E FFFC 3218          move.l    -4(A6),2(A0)
08000D02  0002      
                    3219   ; #if OS_EVENT_NAME_EN > 0u
                    3220   ; pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
08000D04  41F9 0800 3221          lea       @ucos_ii_1.L,A0
08000D08  57FE      
08000D0A  2242      3222          move.l    D2,A1
08000D0C  2348 0012 3223          move.l    A0,18(A1)
08000D10  5243      3224          addq.w    #1,D3
08000D12  60AC      3225          bra       @ucos_ii_OS_InitEventList_1
                    3226   @ucos_ii_OS_InitEventList_3:
                    3227   ; #endif
                    3228   ; }
                    3229   ; pevent1                         = &OSEventTbl[ix];
08000D14  200A      3230          move.l    A2,D0
08000D16  C6BC 0000 3231          and.l     #65535,D3
08000D1A  FFFF      
08000D1C  2203      3232          move.l    D3,D1
08000D1E  C3FC 0016 3233          muls      #22,D1
08000D22  D081      3234          add.l     D1,D0
08000D24  2400      3235          move.l    D0,D2
                    3236   ; pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
08000D26  2042      3237          move.l    D2,A0
08000D28  4210      3238          clr.b     (A0)
                    3239   ; pevent1->OSEventPtr             = (OS_EVENT *)0;
08000D2A  2042      3240          move.l    D2,A0
08000D2C  42A8 0002 3241          clr.l     2(A0)
                    3242   ; #if OS_EVENT_NAME_EN > 0u
                    3243   ; pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
08000D30  41F9 0800 3244          lea       @ucos_ii_1.L,A0
08000D34  57FE      
08000D36  2242      3245          move.l    D2,A1
08000D38  2348 0012 3246          move.l    A0,18(A1)
                    3247   ; #endif
                    3248   ; OSEventFreeList                 = &OSEventTbl[0];
08000D3C  23CA 0800 3249          move.l    A2,_OSEventFreeList.L
08000D40  00E6      
08000D42  4CDF 040C 3250          movem.l   (A7)+,D2/D3/A2
08000D46  4E5E      3251          unlk      A6
08000D48  4E75      3252          rts
                    3253   ; #else
                    3254   ; OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
                    3255   ; OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
                    3256   ; OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
                    3257   ; #if OS_EVENT_NAME_EN > 0u
                    3258   ; OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
                    3259   ; #endif
                    3260   ; #endif
                    3261   ; #endif
                    3262   ; }
                    3263   ; /*$PAGE*/
                    3264   ; /*
                    3265   ; *********************************************************************************************************
                    3266   ; *                                             INITIALIZATION
                    3267   ; *                                    INITIALIZE MISCELLANEOUS VARIABLES
                    3268   ; *
                    3269   ; * Description: This function is called by OSInit() to initialize miscellaneous variables.
                    3270   ; *
                    3271   ; * Arguments  : none
                    3272   ; *
                    3273   ; * Returns    : none
                    3274   ; *********************************************************************************************************
                    3275   ; */
                    3276   ; static  void  OS_InitMisc (void)
                    3277   ; {
                    3278   @ucos_ii_OS_InitMisc:
                    3279   ; #if OS_TIME_GET_SET_EN > 0u
                    3280   ; OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
08000D4A  42B9 0800 3281          clr.l     _OSTime.L
08000D4E  0D82      
                    3282   ; #endif
                    3283   ; OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
08000D50  4239 0800 3284          clr.b     _OSIntNesting.L
08000D54  0312      
                    3285   ; OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
08000D56  4239 0800 3286          clr.b     _OSLockNesting.L
08000D5A  0314      
                    3287   ; OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
08000D5C  4239 0800 3288          clr.b     _OSTaskCtr.L
08000D60  0326      
                    3289   ; OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
08000D62  4239 0800 3290          clr.b     _OSRunning.L
08000D66  0324      
                    3291   ; OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
08000D68  42B9 0800 3292          clr.l     _OSCtxSwCtr.L
08000D6C  00E2      
                    3293   ; OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
08000D6E  42B9 0800 3294          clr.l     _OSIdleCtr.L
08000D72  0328      
                    3295   ; #if OS_TASK_STAT_EN > 0u
                    3296   ; OSIdleCtrRun              = 0uL;
08000D74  42B9 0800 3297          clr.l     _OSIdleCtrRun.L
08000D78  020C      
                    3298   ; OSIdleCtrMax              = 0uL;
08000D7A  42B9 0800 3299          clr.l     _OSIdleCtrMax.L
08000D7E  0208      
                    3300   ; OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
08000D80  4239 0800 3301          clr.b     _OSStatRdy.L
08000D84  0210      
                    3302   ; #endif
                    3303   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    3304   ; OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
                    3305   ; #endif
                    3306   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    3307   ; OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
08000D86  4239 0800 3308          clr.b     _OSTaskRegNextAvailID.L
08000D8A  0D80      
08000D8C  4E75      3309          rts
                    3310   ; #endif
                    3311   ; }
                    3312   ; /*$PAGE*/
                    3313   ; /*
                    3314   ; *********************************************************************************************************
                    3315   ; *                                             INITIALIZATION
                    3316   ; *                                       INITIALIZE THE READY LIST
                    3317   ; *
                    3318   ; * Description: This function is called by OSInit() to initialize the Ready List.
                    3319   ; *
                    3320   ; * Arguments  : none
                    3321   ; *
                    3322   ; * Returns    : none
                    3323   ; *********************************************************************************************************
                    3324   ; */
                    3325   ; static  void  OS_InitRdyList (void)
                    3326   ; {
                    3327   @ucos_ii_OS_InitRdyList:
08000D8E  2F02      3328          move.l    D2,-(A7)
                    3329   ; INT8U  i;
                    3330   ; OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
08000D90  4239 0800 3331          clr.b     _OSRdyGrp.L
08000D94  031A      
                    3332   ; for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
08000D96  4202      3333          clr.b     D2
                    3334   @ucos_ii_OS_InitRdyList_1:
08000D98  0C02 0008 3335          cmp.b     #8,D2
08000D9C  6414      3336          bhs.s     @ucos_ii_OS_InitRdyList_3
                    3337   ; OSRdyTbl[i] = 0u;
08000D9E  C4BC 0000 3338          and.l     #255,D2
08000DA2  00FF      
08000DA4  41F9 0800 3339          lea       _OSRdyTbl.L,A0
08000DA8  031C      
08000DAA  4230 2800 3340          clr.b     0(A0,D2.L)
08000DAE  5202      3341          addq.b    #1,D2
08000DB0  60E6      3342          bra       @ucos_ii_OS_InitRdyList_1
                    3343   @ucos_ii_OS_InitRdyList_3:
                    3344   ; }
                    3345   ; OSPrioCur     = 0u;
08000DB2  4239 0800 3346          clr.b     _OSPrioCur.L
08000DB6  0316      
                    3347   ; OSPrioHighRdy = 0u;
08000DB8  4239 0800 3348          clr.b     _OSPrioHighRdy.L
08000DBC  0318      
                    3349   ; OSTCBHighRdy  = (OS_TCB *)0;
08000DBE  42B9 0800 3350          clr.l     _OSTCBHighRdy.L
08000DC2  0434      
                    3351   ; OSTCBCur      = (OS_TCB *)0;
08000DC4  42B9 0800 3352          clr.l     _OSTCBCur.L
08000DC8  042C      
08000DCA  241F      3353          move.l    (A7)+,D2
08000DCC  4E75      3354          rts
                    3355   ; }
                    3356   ; /*$PAGE*/
                    3357   ; /*
                    3358   ; *********************************************************************************************************
                    3359   ; *                                             INITIALIZATION
                    3360   ; *                                         CREATING THE IDLE TASK
                    3361   ; *
                    3362   ; * Description: This function creates the Idle Task.
                    3363   ; *
                    3364   ; * Arguments  : none
                    3365   ; *
                    3366   ; * Returns    : none
                    3367   ; *********************************************************************************************************
                    3368   ; */
                    3369   ; static  void  OS_InitTaskIdle (void)
                    3370   ; {
                    3371   @ucos_ii_OS_InitTaskIdle:
08000DCE  4E56 FFFC 3372          link      A6,#-4
                    3373   ; #if OS_TASK_NAME_EN > 0u
                    3374   ; INT8U  err;
                    3375   ; #endif
                    3376   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3377   ; #if OS_STK_GROWTH == 1u
                    3378   ; (void)OSTaskCreateExt(OS_TaskIdle,
08000DD2  4878 0003 3379          pea       3
08000DD6  42A7      3380          clr.l     -(A7)
08000DD8  4878 0080 3381          pea       128
08000DDC  4879 0800 3382          pea       _OSTaskIdleStk.L
08000DE0  032C      
08000DE2  4878 FFFF 3383          pea       65535
08000DE6  4878 003F 3384          pea       63
08000DEA  41F9 0800 3385          lea       _OSTaskIdleStk.L,A0
08000DEE  032C      
08000DF0  D0FC 00FE 3386          add.w     #254,A0
08000DF4  2F08      3387          move.l    A0,-(A7)
08000DF6  42A7      3388          clr.l     -(A7)
08000DF8  4879 0800 3389          pea       _OS_TaskIdle.L
08000DFC  1054      
08000DFE  4EB9 0800 3390          jsr       _OSTaskCreateExt
08000E02  3F78      
08000E04  DEFC 0024 3391          add.w     #36,A7
08000E08  C0BC 0000 3392          and.l     #255,D0
08000E0C  00FF      
                    3393   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3394   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
                    3395   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3396   ; OS_TASK_IDLE_ID,
                    3397   ; &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
                    3398   ; OS_TASK_IDLE_STK_SIZE,
                    3399   ; (void *)0,                                 /* No TCB extension                     */
                    3400   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3401   ; #else
                    3402   ; (void)OSTaskCreateExt(OS_TaskIdle,
                    3403   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3404   ; &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
                    3405   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3406   ; OS_TASK_IDLE_ID,
                    3407   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
                    3408   ; OS_TASK_IDLE_STK_SIZE,
                    3409   ; (void *)0,                                 /* No TCB extension                     */
                    3410   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3411   ; #endif
                    3412   ; #else
                    3413   ; #if OS_STK_GROWTH == 1u
                    3414   ; (void)OSTaskCreate(OS_TaskIdle,
                    3415   ; (void *)0,
                    3416   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
                    3417   ; OS_TASK_IDLE_PRIO);
                    3418   ; #else
                    3419   ; (void)OSTaskCreate(OS_TaskIdle,
                    3420   ; (void *)0,
                    3421   ; &OSTaskIdleStk[0],
                    3422   ; OS_TASK_IDLE_PRIO);
                    3423   ; #endif
                    3424   ; #endif
                    3425   ; #if OS_TASK_NAME_EN > 0u
                    3426   ; OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
08000E0E  486E FFFF 3427          pea       -1(A6)
08000E12  4879 0800 3428          pea       @ucos_ii_2.L
08000E16  5800      
08000E18  4878 003F 3429          pea       63
08000E1C  4EB9 0800 3430          jsr       _OSTaskNameSet
08000E20  4398      
08000E22  DEFC 000C 3431          add.w     #12,A7
08000E26  4E5E      3432          unlk      A6
08000E28  4E75      3433          rts
                    3434   ; #endif
                    3435   ; }
                    3436   ; /*$PAGE*/
                    3437   ; /*
                    3438   ; *********************************************************************************************************
                    3439   ; *                                             INITIALIZATION
                    3440   ; *                                      CREATING THE STATISTIC TASK
                    3441   ; *
                    3442   ; * Description: This function creates the Statistic Task.
                    3443   ; *
                    3444   ; * Arguments  : none
                    3445   ; *
                    3446   ; * Returns    : none
                    3447   ; *********************************************************************************************************
                    3448   ; */
                    3449   ; #if OS_TASK_STAT_EN > 0u
                    3450   ; static  void  OS_InitTaskStat (void)
                    3451   ; {
                    3452   @ucos_ii_OS_InitTaskStat:
08000E2A  4E56 FFFC 3453          link      A6,#-4
                    3454   ; #if OS_TASK_NAME_EN > 0u
                    3455   ; INT8U  err;
                    3456   ; #endif
                    3457   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3458   ; #if OS_STK_GROWTH == 1u
                    3459   ; (void)OSTaskCreateExt(OS_TaskStat,
08000E2E  4878 0003 3460          pea       3
08000E32  42A7      3461          clr.l     -(A7)
08000E34  4878 0080 3462          pea       128
08000E38  4879 0800 3463          pea       _OSTaskStatStk.L
08000E3C  0212      
08000E3E  4878 FFFE 3464          pea       65534
08000E42  4878 003E 3465          pea       62
08000E46  41F9 0800 3466          lea       _OSTaskStatStk.L,A0
08000E4A  0212      
08000E4C  D0FC 00FE 3467          add.w     #254,A0
08000E50  2F08      3468          move.l    A0,-(A7)
08000E52  42A7      3469          clr.l     -(A7)
08000E54  4879 0800 3470          pea       _OS_TaskStat.L
08000E58  106E      
08000E5A  4EB9 0800 3471          jsr       _OSTaskCreateExt
08000E5E  3F78      
08000E60  DEFC 0024 3472          add.w     #36,A7
08000E64  C0BC 0000 3473          and.l     #255,D0
08000E68  00FF      
                    3474   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3475   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
                    3476   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3477   ; OS_TASK_STAT_ID,
                    3478   ; &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
                    3479   ; OS_TASK_STAT_STK_SIZE,
                    3480   ; (void *)0,                                   /* No TCB extension               */
                    3481   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3482   ; #else
                    3483   ; (void)OSTaskCreateExt(OS_TaskStat,
                    3484   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3485   ; &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
                    3486   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3487   ; OS_TASK_STAT_ID,
                    3488   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
                    3489   ; OS_TASK_STAT_STK_SIZE,
                    3490   ; (void *)0,                                   /* No TCB extension               */
                    3491   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3492   ; #endif
                    3493   ; #else
                    3494   ; #if OS_STK_GROWTH == 1u
                    3495   ; (void)OSTaskCreate(OS_TaskStat,
                    3496   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3497   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
                    3498   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3499   ; #else
                    3500   ; (void)OSTaskCreate(OS_TaskStat,
                    3501   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3502   ; &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
                    3503   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3504   ; #endif
                    3505   ; #endif
                    3506   ; #if OS_TASK_NAME_EN > 0u
                    3507   ; OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
08000E6A  486E FFFF 3508          pea       -1(A6)
08000E6E  4879 0800 3509          pea       @ucos_ii_3.L
08000E72  580E      
08000E74  4878 003E 3510          pea       62
08000E78  4EB9 0800 3511          jsr       _OSTaskNameSet
08000E7C  4398      
08000E7E  DEFC 000C 3512          add.w     #12,A7
08000E82  4E5E      3513          unlk      A6
08000E84  4E75      3514          rts
                    3515   ; #endif
                    3516   ; }
                    3517   ; #endif
                    3518   ; /*$PAGE*/
                    3519   ; /*
                    3520   ; *********************************************************************************************************
                    3521   ; *                                             INITIALIZATION
                    3522   ; *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
                    3523   ; *
                    3524   ; * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
                    3525   ; *
                    3526   ; * Arguments  : none
                    3527   ; *
                    3528   ; * Returns    : none
                    3529   ; *********************************************************************************************************
                    3530   ; */
                    3531   ; static  void  OS_InitTCBList (void)
                    3532   ; {
                    3533   @ucos_ii_OS_InitTCBList:
08000E86  4E56 FFF8 3534          link      A6,#-8
08000E8A  48E7 3020 3535          movem.l   D2/D3/A2,-(A7)
08000E8E  45F9 0800 3536          lea       _OSTCBTbl.L,A2
08000E92  053C      
                    3537   ; INT8U    ix;
                    3538   ; INT8U    ix_next;
                    3539   ; OS_TCB  *ptcb1;
                    3540   ; OS_TCB  *ptcb2;
                    3541   ; OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
08000E94  4878 0764 3542          pea       1892
08000E98  2F0A      3543          move.l    A2,-(A7)
08000E9A  4EB9 0800 3544          jsr       _OS_MemClr
08000E9E  0F3E      
08000EA0  504F      3545          addq.w    #8,A7
                    3546   ; OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
08000EA2  4878 0100 3547          pea       256
08000EA6  4879 0800 3548          pea       _OSTCBPrioTbl.L
08000EAA  043C      
08000EAC  4EB9 0800 3549          jsr       _OS_MemClr
08000EB0  0F3E      
08000EB2  504F      3550          addq.w    #8,A7
                    3551   ; for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
08000EB4  4203      3552          clr.b     D3
                    3553   @ucos_ii_OS_InitTCBList_1:
08000EB6  0C03 0015 3554          cmp.b     #21,D3
08000EBA  6400 004A 3555          bhs       @ucos_ii_OS_InitTCBList_3
                    3556   ; ix_next =  ix + 1u;
08000EBE  7001      3557          moveq     #1,D0
08000EC0  D003      3558          add.b     D3,D0
08000EC2  1D40 FFFB 3559          move.b    D0,-5(A6)
                    3560   ; ptcb1   = &OSTCBTbl[ix];
08000EC6  200A      3561          move.l    A2,D0
08000EC8  C6BC 0000 3562          and.l     #255,D3
08000ECC  00FF      
08000ECE  2203      3563          move.l    D3,D1
08000ED0  C3FC 0056 3564          muls      #86,D1
08000ED4  D081      3565          add.l     D1,D0
08000ED6  2400      3566          move.l    D0,D2
                    3567   ; ptcb2   = &OSTCBTbl[ix_next];
08000ED8  200A      3568          move.l    A2,D0
08000EDA  122E FFFB 3569          move.b    -5(A6),D1
08000EDE  C2BC 0000 3570          and.l     #255,D1
08000EE2  00FF      
08000EE4  C3FC 0056 3571          muls      #86,D1
08000EE8  D081      3572          add.l     D1,D0
08000EEA  2D40 FFFC 3573          move.l    D0,-4(A6)
                    3574   ; ptcb1->OSTCBNext = ptcb2;
08000EEE  2042      3575          move.l    D2,A0
08000EF0  216E FFFC 3576          move.l    -4(A6),20(A0)
08000EF4  0014      
                    3577   ; #if OS_TASK_NAME_EN > 0u
                    3578   ; ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
08000EF6  41F9 0800 3579          lea       @ucos_ii_1.L,A0
08000EFA  57FE      
08000EFC  2242      3580          move.l    D2,A1
08000EFE  2348 004E 3581          move.l    A0,78(A1)
08000F02  5203      3582          addq.b    #1,D3
08000F04  60B0      3583          bra       @ucos_ii_OS_InitTCBList_1
                    3584   @ucos_ii_OS_InitTCBList_3:
                    3585   ; #endif
                    3586   ; }
                    3587   ; ptcb1                   = &OSTCBTbl[ix];
08000F06  200A      3588          move.l    A2,D0
08000F08  C6BC 0000 3589          and.l     #255,D3
08000F0C  00FF      
08000F0E  2203      3590          move.l    D3,D1
08000F10  C3FC 0056 3591          muls      #86,D1
08000F14  D081      3592          add.l     D1,D0
08000F16  2400      3593          move.l    D0,D2
                    3594   ; ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
08000F18  2042      3595          move.l    D2,A0
08000F1A  42A8 0014 3596          clr.l     20(A0)
                    3597   ; #if OS_TASK_NAME_EN > 0u
                    3598   ; ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
08000F1E  41F9 0800 3599          lea       @ucos_ii_1.L,A0
08000F22  57FE      
08000F24  2242      3600          move.l    D2,A1
08000F26  2348 004E 3601          move.l    A0,78(A1)
                    3602   ; #endif
                    3603   ; OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
08000F2A  42B9 0800 3604          clr.l     _OSTCBList.L
08000F2E  0438      
                    3605   ; OSTCBFreeList           = &OSTCBTbl[0];
08000F30  23CA 0800 3606          move.l    A2,_OSTCBFreeList.L
08000F34  0430      
08000F36  4CDF 040C 3607          movem.l   (A7)+,D2/D3/A2
08000F3A  4E5E      3608          unlk      A6
08000F3C  4E75      3609          rts
                    3610   ; }
                    3611   ; /*$PAGE*/
                    3612   ; /*
                    3613   ; *********************************************************************************************************
                    3614   ; *                                      CLEAR A SECTION OF MEMORY
                    3615   ; *
                    3616   ; * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
                    3617   ; *
                    3618   ; * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
                    3619   ; *
                    3620   ; *              size     is the number of bytes to clear.
                    3621   ; *
                    3622   ; * Returns    : none
                    3623   ; *
                    3624   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3625   ; *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
                    3626   ; *                 of the uses of this function gets close to this limit.
                    3627   ; *              3) The clear is done one byte at a time since this will work on any processor irrespective
                    3628   ; *                 of the alignment of the destination.
                    3629   ; *********************************************************************************************************
                    3630   ; */
                    3631   ; void  OS_MemClr (INT8U  *pdest,
                    3632   ; INT16U  size)
                    3633   ; {
                    3634   _OS_MemClr:
08000F3E  4E56 0000 3635          link      A6,#0
                    3636   ; while (size > 0u) {
                    3637   OS_MemClr_1:
08000F42  302E 000E 3638          move.w    14(A6),D0
08000F46  0C40 0000 3639          cmp.w     #0,D0
08000F4A  6310      3640          bls.s     OS_MemClr_3
                    3641   ; *pdest++ = (INT8U)0;
08000F4C  206E 0008 3642          move.l    8(A6),A0
08000F50  52AE 0008 3643          addq.l    #1,8(A6)
08000F54  4210      3644          clr.b     (A0)
                    3645   ; size--;
08000F56  536E 000E 3646          subq.w    #1,14(A6)
08000F5A  60E6      3647          bra       OS_MemClr_1
                    3648   OS_MemClr_3:
08000F5C  4E5E      3649          unlk      A6
08000F5E  4E75      3650          rts
                    3651   ; }
                    3652   ; }
                    3653   ; /*$PAGE*/
                    3654   ; /*
                    3655   ; *********************************************************************************************************
                    3656   ; *                                       COPY A BLOCK OF MEMORY
                    3657   ; *
                    3658   ; * Description: This function is called by other uC/OS-II services to copy a block of memory from one
                    3659   ; *              location to another.
                    3660   ; *
                    3661   ; * Arguments  : pdest    is a pointer to the 'destination' memory block
                    3662   ; *
                    3663   ; *              psrc     is a pointer to the 'source'      memory block
                    3664   ; *
                    3665   ; *              size     is the number of bytes to copy.
                    3666   ; *
                    3667   ; * Returns    : none
                    3668   ; *
                    3669   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
                    3670   ; *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
                    3671   ; *                 is not a situation that will happen.
                    3672   ; *              2) Note that we can only copy up to 64K bytes of RAM
                    3673   ; *              3) The copy is done one byte at a time since this will work on any processor irrespective
                    3674   ; *                 of the alignment of the source and destination.
                    3675   ; *********************************************************************************************************
                    3676   ; */
                    3677   ; void  OS_MemCopy (INT8U  *pdest,
                    3678   ; INT8U  *psrc,
                    3679   ; INT16U  size)
                    3680   ; {
                    3681   _OS_MemCopy:
08000F60  4E56 0000 3682          link      A6,#0
                    3683   ; while (size > 0u) {
                    3684   OS_MemCopy_1:
08000F64  302E 0012 3685          move.w    18(A6),D0
08000F68  0C40 0000 3686          cmp.w     #0,D0
08000F6C  6318      3687          bls.s     OS_MemCopy_3
                    3688   ; *pdest++ = *psrc++;
08000F6E  206E 000C 3689          move.l    12(A6),A0
08000F72  52AE 000C 3690          addq.l    #1,12(A6)
08000F76  226E 0008 3691          move.l    8(A6),A1
08000F7A  52AE 0008 3692          addq.l    #1,8(A6)
08000F7E  1290      3693          move.b    (A0),(A1)
                    3694   ; size--;
08000F80  536E 0012 3695          subq.w    #1,18(A6)
08000F84  60DE      3696          bra       OS_MemCopy_1
                    3697   OS_MemCopy_3:
08000F86  4E5E      3698          unlk      A6
08000F88  4E75      3699          rts
                    3700   ; }
                    3701   ; }
                    3702   ; /*$PAGE*/
                    3703   ; /*
                    3704   ; *********************************************************************************************************
                    3705   ; *                                              SCHEDULER
                    3706   ; *
                    3707   ; * Description: This function is called by other uC/OS-II services to determine whether a new, high
                    3708   ; *              priority task has been made ready to run.  This function is invoked by TASK level code
                    3709   ; *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
                    3710   ; *
                    3711   ; * Arguments  : none
                    3712   ; *
                    3713   ; * Returns    : none
                    3714   ; *
                    3715   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3716   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    3717   ; *********************************************************************************************************
                    3718   ; */
                    3719   ; void  OS_Sched (void)
                    3720   ; {
                    3721   _OS_Sched:
                    3722   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    3723   ; OS_CPU_SR  cpu_sr = 0u;
                    3724   ; #endif
                    3725   ; OS_ENTER_CRITICAL();
08000F8A  40E7      3726          dc.w      16615
08000F8C  007C      3727          dc.w      124
08000F8E  0700      3728          dc.w      1792
                    3729   ; if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
08000F90  1039 0800 3730          move.b    _OSIntNesting.L,D0
08000F94  0312      
08000F96  6600 0052 3731          bne       OS_Sched_5
                    3732   ; if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
08000F9A  1039 0800 3733          move.b    _OSLockNesting.L,D0
08000F9E  0314      
08000FA0  6648      3734          bne.s     OS_Sched_5
                    3735   ; OS_SchedNew();
08000FA2  4EB9 0800 3736          jsr       @ucos_ii_OS_SchedNew
08000FA6  0FEE      
                    3737   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
08000FA8  1039 0800 3738          move.b    _OSPrioHighRdy.L,D0
08000FAC  0318      
08000FAE  C0BC 0000 3739          and.l     #255,D0
08000FB2  00FF      
08000FB4  E588      3740          lsl.l     #2,D0
08000FB6  41F9 0800 3741          lea       _OSTCBPrioTbl.L,A0
08000FBA  043C      
08000FBC  23F0 0800 3742          move.l    0(A0,D0.L),_OSTCBHighRdy.L
08000FC0  0800 0434 
                    3743   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
08000FC4  1039 0800 3744          move.b    _OSPrioHighRdy.L,D0
08000FC8  0318      
08000FCA  B039 0800 3745          cmp.b     _OSPrioCur.L,D0
08000FCE  0316      
08000FD0  6718      3746          beq.s     OS_Sched_5
                    3747   ; #if OS_TASK_PROFILE_EN > 0u
                    3748   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
08000FD2  2039 0800 3749          move.l    _OSTCBHighRdy.L,D0
08000FD6  0434      
08000FD8  0680 0000 3750          add.l     #58,D0
08000FDC  003A      
08000FDE  2040      3751          move.l    D0,A0
08000FE0  5290      3752          addq.l    #1,(A0)
                    3753   ; #endif
                    3754   ; OSCtxSwCtr++;                          /* Increment context switch counter             */
08000FE2  52B9 0800 3755          addq.l    #1,_OSCtxSwCtr.L
08000FE6  00E2      
                    3756   ; OS_TASK_SW();                          /* Perform a context switch                     */
08000FE8  4E40      3757          trap      #0
                    3758   OS_Sched_5:
                    3759   ; }
                    3760   ; }
                    3761   ; }
                    3762   ; OS_EXIT_CRITICAL();
08000FEA  46DF      3763          dc.w      18143
08000FEC  4E75      3764          rts
                    3765   ; }
                    3766   ; /*
                    3767   ; *********************************************************************************************************
                    3768   ; *                               FIND HIGHEST PRIORITY TASK READY TO RUN
                    3769   ; *
                    3770   ; * Description: This function is called by other uC/OS-II services to determine the highest priority task
                    3771   ; *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
                    3772   ; *
                    3773   ; * Arguments  : none
                    3774   ; *
                    3775   ; * Returns    : none
                    3776   ; *
                    3777   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3778   ; *              2) Interrupts are assumed to be disabled when this function is called.
                    3779   ; *********************************************************************************************************
                    3780   ; */
                    3781   ; static  void  OS_SchedNew (void)
                    3782   ; {
                    3783   @ucos_ii_OS_SchedNew:
08000FEE  2F02      3784          move.l    D2,-(A7)
                    3785   ; #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
                    3786   ; INT8U   y;
                    3787   ; y             = OSUnMapTbl[OSRdyGrp];
08000FF0  1039 0800 3788          move.b    _OSRdyGrp.L,D0
08000FF4  031A      
08000FF6  C0BC 0000 3789          and.l     #255,D0
08000FFA  00FF      
08000FFC  41F9 0800 3790          lea       _OSUnMapTbl.L,A0
08001000  5850      
08001002  1430 0800 3791          move.b    0(A0,D0.L),D2
                    3792   ; OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
08001006  1002      3793          move.b    D2,D0
08001008  E708      3794          lsl.b     #3,D0
0800100A  C4BC 0000 3795          and.l     #255,D2
0800100E  00FF      
08001010  41F9 0800 3796          lea       _OSRdyTbl.L,A0
08001014  031C      
08001016  1230 2800 3797          move.b    0(A0,D2.L),D1
0800101A  C2BC 0000 3798          and.l     #255,D1
0800101E  00FF      
08001020  41F9 0800 3799          lea       _OSUnMapTbl.L,A0
08001024  5850      
08001026  D030 1800 3800          add.b     0(A0,D1.L),D0
0800102A  13C0 0800 3801          move.b    D0,_OSPrioHighRdy.L
0800102E  0318      
08001030  241F      3802          move.l    (A7)+,D2
08001032  4E75      3803          rts
                    3804   ; #else                                            /* We support up to 256 tasks                         */
                    3805   ; INT8U     y;
                    3806   ; OS_PRIO  *ptbl;
                    3807   ; if ((OSRdyGrp & 0xFFu) != 0u) {
                    3808   ; y = OSUnMapTbl[OSRdyGrp & 0xFFu];
                    3809   ; } else {
                    3810   ; y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
                    3811   ; }
                    3812   ; ptbl = &OSRdyTbl[y];
                    3813   ; if ((*ptbl & 0xFFu) != 0u) {
                    3814   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
                    3815   ; } else {
                    3816   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
                    3817   ; }
                    3818   ; #endif
                    3819   ; }
                    3820   ; /*$PAGE*/
                    3821   ; /*
                    3822   ; *********************************************************************************************************
                    3823   ; *                               DETERMINE THE LENGTH OF AN ASCII STRING
                    3824   ; *
                    3825   ; * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
                    3826   ; *              (excluding the NUL character).
                    3827   ; *
                    3828   ; * Arguments  : psrc     is a pointer to the string for which we need to know the size.
                    3829   ; *
                    3830   ; * Returns    : The size of the string (excluding the NUL terminating character)
                    3831   ; *
                    3832   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3833   ; *              2) The string to check must be less than 255 characters long.
                    3834   ; *********************************************************************************************************
                    3835   ; */
                    3836   ; #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
                    3837   ; INT8U  OS_StrLen (INT8U *psrc)
                    3838   ; {
                    3839   _OS_StrLen:
08001034  4E56 0000 3840          link      A6,#0
08001038  2F02      3841          move.l    D2,-(A7)
                    3842   ; INT8U  len;
                    3843   ; #if OS_ARG_CHK_EN > 0u
                    3844   ; if (psrc == (INT8U *)0) {
                    3845   ; return (0u);
                    3846   ; }
                    3847   ; #endif
                    3848   ; len = 0u;
0800103A  4202      3849          clr.b     D2
                    3850   ; while (*psrc != OS_ASCII_NUL) {
                    3851   OS_StrLen_1:
0800103C  206E 0008 3852          move.l    8(A6),A0
08001040  1010      3853          move.b    (A0),D0
08001042  6708      3854          beq.s     OS_StrLen_3
                    3855   ; psrc++;
08001044  52AE 0008 3856          addq.l    #1,8(A6)
                    3857   ; len++;
08001048  5202      3858          addq.b    #1,D2
0800104A  60F0      3859          bra       OS_StrLen_1
                    3860   OS_StrLen_3:
                    3861   ; }
                    3862   ; return (len);
0800104C  1002      3863          move.b    D2,D0
0800104E  241F      3864          move.l    (A7)+,D2
08001050  4E5E      3865          unlk      A6
08001052  4E75      3866          rts
                    3867   ; }
                    3868   ; #endif
                    3869   ; /*$PAGE*/
                    3870   ; /*
                    3871   ; *********************************************************************************************************
                    3872   ; *                                              IDLE TASK
                    3873   ; *
                    3874   ; * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
                    3875   ; *              executes because they are ALL waiting for event(s) to occur.
                    3876   ; *
                    3877   ; * Arguments  : none
                    3878   ; *
                    3879   ; * Returns    : none
                    3880   ; *
                    3881   ; * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
                    3882   ; *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
                    3883   ; *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
                    3884   ; *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
                    3885   ; *                 interrupts.
                    3886   ; *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
                    3887   ; *                 power.
                    3888   ; *********************************************************************************************************
                    3889   ; */
                    3890   ; void  OS_TaskIdle (void *p_arg)
                    3891   ; {
                    3892   _OS_TaskIdle:
08001054  4E56 0000 3893          link      A6,#0
                    3894   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    3895   ; OS_CPU_SR  cpu_sr = 0u;
                    3896   ; #endif
                    3897   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    3898   ; for (;;) {
                    3899   OS_TaskIdle_1:
                    3900   ; OS_ENTER_CRITICAL();
08001058  40E7      3901          dc.w      16615
0800105A  007C      3902          dc.w      124
0800105C  0700      3903          dc.w      1792
                    3904   ; OSIdleCtr++;
0800105E  52B9 0800 3905          addq.l    #1,_OSIdleCtr.L
08001062  0328      
                    3906   ; OS_EXIT_CRITICAL();
08001064  46DF      3907          dc.w      18143
                    3908   ; OSTaskIdleHook();                        /* Call user definable HOOK                           */
08001066  4EB9 0800 3909          jsr       _OSTaskIdleHook
0800106A  0276      
0800106C  60EA      3910          bra       OS_TaskIdle_1
                    3911   ; }
                    3912   ; }
                    3913   ; /*$PAGE*/
                    3914   ; /*
                    3915   ; *********************************************************************************************************
                    3916   ; *                                           STATISTICS TASK
                    3917   ; *
                    3918   ; * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
                    3919   ; *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
                    3920   ; *              CPU usage is determined by:
                    3921   ; *
                    3922   ; *                                          OSIdleCtr
                    3923   ; *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
                    3924   ; *                                         OSIdleCtrMax
                    3925   ; *
                    3926   ; * Arguments  : parg     this pointer is not used at this time.
                    3927   ; *
                    3928   ; * Returns    : none
                    3929   ; *
                    3930   ; * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
                    3931   ; *                 next higher priority, OS_TASK_IDLE_PRIO-1.
                    3932   ; *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
                    3933   ; *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
                    3934   ; *                 maximum value for the idle counter.
                    3935   ; *********************************************************************************************************
                    3936   ; */
                    3937   ; #if OS_TASK_STAT_EN > 0u
                    3938   ; void  OS_TaskStat (void *p_arg)
                    3939   ; {
                    3940   _OS_TaskStat:
0800106E  4E56 0000 3941          link      A6,#0
08001072  2F0A      3942          move.l    A2,-(A7)
08001074  45F9 0800 3943          lea       _OSIdleCtrMax.L,A2
08001078  0208      
                    3944   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    3945   ; OS_CPU_SR  cpu_sr = 0u;
                    3946   ; #endif
                    3947   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    3948   ; while (OSStatRdy == OS_FALSE) {
                    3949   OS_TaskStat_1:
0800107A  1039 0800 3950          move.b    _OSStatRdy.L,D0
0800107E  0210      
08001080  660E      3951          bne.s     OS_TaskStat_3
                    3952   ; OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
08001082  4878 0014 3953          pea       20
08001086  4EB9 0800 3954          jsr       _OSTimeDly
0800108A  4828      
0800108C  584F      3955          addq.w    #4,A7
0800108E  60EA      3956          bra       OS_TaskStat_1
                    3957   OS_TaskStat_3:
                    3958   ; }
                    3959   ; OSIdleCtrMax /= 100uL;
08001090  2F12      3960          move.l    (A2),-(A7)
08001092  4878 0064 3961          pea       100
08001096  4EB9 0800 3962          jsr       ULDIV
0800109A  5720      
0800109C  2497      3963          move.l    (A7),(A2)
0800109E  504F      3964          addq.w    #8,A7
                    3965   ; if (OSIdleCtrMax == 0uL) {
080010A0  2012      3966          move.l    (A2),D0
080010A2  6618      3967          bne.s     OS_TaskStat_4
                    3968   ; OSCPUUsage = 0u;
080010A4  4239 0800 3969          clr.b     _OSCPUUsage.L
080010A8  0206      
                    3970   ; #if OS_TASK_SUSPEND_EN > 0u
                    3971   ; (void)OSTaskSuspend(OS_PRIO_SELF);
080010AA  4878 00FF 3972          pea       255
080010AE  4EB9 0800 3973          jsr       _OSTaskSuspend
080010B2  4598      
080010B4  584F      3974          addq.w    #4,A7
080010B6  C0BC 0000 3975          and.l     #255,D0
080010BA  00FF      
                    3976   OS_TaskStat_4:
                    3977   ; #else
                    3978   ; for (;;) {
                    3979   ; OSTimeDly(OS_TICKS_PER_SEC);
                    3980   ; }
                    3981   ; #endif
                    3982   ; }
                    3983   ; OS_ENTER_CRITICAL();
080010BC  40E7      3984          dc.w      16615
080010BE  007C      3985          dc.w      124
080010C0  0700      3986          dc.w      1792
                    3987   ; OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
080010C2  2F12      3988          move.l    (A2),-(A7)
080010C4  4878 0064 3989          pea       100
080010C8  4EB9 0800 3990          jsr       ULMUL
080010CC  5680      
080010CE  2017      3991          move.l    (A7),D0
080010D0  504F      3992          addq.w    #8,A7
080010D2  23C0 0800 3993          move.l    D0,_OSIdleCtr.L
080010D6  0328      
                    3994   ; OS_EXIT_CRITICAL();
080010D8  46DF      3995          dc.w      18143
                    3996   ; for (;;) {
                    3997   OS_TaskStat_6:
                    3998   ; OS_ENTER_CRITICAL();
080010DA  40E7      3999          dc.w      16615
080010DC  007C      4000          dc.w      124
080010DE  0700      4001          dc.w      1792
                    4002   ; OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
080010E0  23F9 0800 4003          move.l    _OSIdleCtr.L,_OSIdleCtrRun.L
080010E4  0328 0800 
080010E8  020C      
                    4004   ; OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
080010EA  42B9 0800 4005          clr.l     _OSIdleCtr.L
080010EE  0328      
                    4006   ; OS_EXIT_CRITICAL();
080010F0  46DF      4007          dc.w      18143
                    4008   ; OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
080010F2  7064      4009          moveq     #100,D0
080010F4  2F39 0800 4010          move.l    _OSIdleCtrRun.L,-(A7)
080010F8  020C      
080010FA  2F12      4011          move.l    (A2),-(A7)
080010FC  4EB9 0800 4012          jsr       ULDIV
08001100  5720      
08001102  2217      4013          move.l    (A7),D1
08001104  504F      4014          addq.w    #8,A7
08001106  9081      4015          sub.l     D1,D0
08001108  13C0 0800 4016          move.b    D0,_OSCPUUsage.L
0800110C  0206      
                    4017   ; OSTaskStatHook();                        /* Invoke user definable hook                         */
0800110E  4EB9 0800 4018          jsr       _OSTaskStatHook
08001112  0280      
                    4019   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4020   ; OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
08001114  4EB9 0800 4021          jsr       _OS_TaskStatStkChk
08001118  1128      
                    4022   ; #endif
                    4023   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
0800111A  4878 000A 4024          pea       10
0800111E  4EB9 0800 4025          jsr       _OSTimeDly
08001122  4828      
08001124  584F      4026          addq.w    #4,A7
08001126  60B2      4027          bra       OS_TaskStat_6
                    4028   ; }
                    4029   ; }
                    4030   ; #endif
                    4031   ; /*$PAGE*/
                    4032   ; /*
                    4033   ; *********************************************************************************************************
                    4034   ; *                                        CHECK ALL TASK STACKS
                    4035   ; *
                    4036   ; * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
                    4037   ; *
                    4038   ; * Arguments  : none
                    4039   ; *
                    4040   ; * Returns    : none
                    4041   ; *********************************************************************************************************
                    4042   ; */
                    4043   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4044   ; void  OS_TaskStatStkChk (void)
                    4045   ; {
                    4046   _OS_TaskStatStkChk:
08001128  4E56 FFF4 4047          link      A6,#-12
0800112C  48E7 3000 4048          movem.l   D2/D3,-(A7)
                    4049   ; OS_TCB      *ptcb;
                    4050   ; OS_STK_DATA  stk_data;
                    4051   ; INT8U        err;
                    4052   ; INT8U        prio;
                    4053   ; for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
08001130  4203      4054          clr.b     D3
                    4055   OS_TaskStatStkChk_1:
08001132  0C03 003F 4056          cmp.b     #63,D3
08001136  6200 0068 4057          bhi       OS_TaskStatStkChk_3
                    4058   ; err = OSTaskStkChk(prio, &stk_data);
0800113A  486E FFF6 4059          pea       -10(A6)
0800113E  C6BC 0000 4060          and.l     #255,D3
08001142  00FF      
08001144  2F03      4061          move.l    D3,-(A7)
08001146  4EB9 0800 4062          jsr       _OSTaskStkChk
0800114A  44E0      
0800114C  504F      4063          addq.w    #8,A7
0800114E  1D40 FFFF 4064          move.b    D0,-1(A6)
                    4065   ; if (err == OS_ERR_NONE) {
08001152  102E FFFF 4066          move.b    -1(A6),D0
08001156  6600 0044 4067          bne       OS_TaskStatStkChk_8
                    4068   ; ptcb = OSTCBPrioTbl[prio];
0800115A  C6BC 0000 4069          and.l     #255,D3
0800115E  00FF      
08001160  2003      4070          move.l    D3,D0
08001162  E588      4071          lsl.l     #2,D0
08001164  41F9 0800 4072          lea       _OSTCBPrioTbl.L,A0
08001168  043C      
0800116A  2430 0800 4073          move.l    0(A0,D0.L),D2
                    4074   ; if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
0800116E  4A82      4075          tst.l     D2
08001170  672A      4076          beq.s     OS_TaskStatStkChk_8
                    4077   ; if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
08001172  0C82 0000 4078          cmp.l     #1,D2
08001176  0001      
08001178  6722      4079          beq.s     OS_TaskStatStkChk_8
                    4080   ; #if OS_TASK_PROFILE_EN > 0u
                    4081   ; #if OS_STK_GROWTH == 1u
                    4082   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
0800117A  2042      4083          move.l    D2,A0
0800117C  2028 0008 4084          move.l    8(A0),D0
08001180  2042      4085          move.l    D2,A0
08001182  2228 000C 4086          move.l    12(A0),D1
08001186  E389      4087          lsl.l     #1,D1
08001188  D081      4088          add.l     D1,D0
0800118A  2042      4089          move.l    D2,A0
0800118C  2140 0046 4090          move.l    D0,70(A0)
                    4091   ; #else
                    4092   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    4093   ; #endif
                    4094   ; ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
08001190  41EE FFF6 4095          lea       -10(A6),A0
08001194  2242      4096          move.l    D2,A1
08001196  2368 0004 4097          move.l    4(A0),74(A1)
0800119A  004A      
                    4098   OS_TaskStatStkChk_8:
0800119C  5203      4099          addq.b    #1,D3
0800119E  6092      4100          bra       OS_TaskStatStkChk_1
                    4101   OS_TaskStatStkChk_3:
080011A0  4CDF 000C 4102          movem.l   (A7)+,D2/D3
080011A4  4E5E      4103          unlk      A6
080011A6  4E75      4104          rts
                    4105   ; #endif
                    4106   ; }
                    4107   ; }
                    4108   ; }
                    4109   ; }
                    4110   ; }
                    4111   ; #endif
                    4112   ; /*$PAGE*/
                    4113   ; /*
                    4114   ; *********************************************************************************************************
                    4115   ; *                                           INITIALIZE TCB
                    4116   ; *
                    4117   ; * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
                    4118   ; *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
                    4119   ; *
                    4120   ; * Arguments  : prio          is the priority of the task being created
                    4121   ; *
                    4122   ; *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
                    4123   ; *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
                    4124   ; *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
                    4125   ; *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
                    4126   ; *                            specific.
                    4127   ; *
                    4128   ; *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
                    4129   ; *                            'OSTaskCreate()'.
                    4130   ; *
                    4131   ; *              id            is the task's ID (0..65535)
                    4132   ; *
                    4133   ; *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
                    4134   ; *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
                    4135   ; *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
                    4136   ; *                            units are established by the #define constant OS_STK which is CPU
                    4137   ; *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
                    4138   ; *
                    4139   ; *              pext          is a pointer to a user supplied memory area that is used to extend the task
                    4140   ; *                            control block.  This allows you to store the contents of floating-point
                    4141   ; *                            registers, MMU registers or anything else you could find useful during a
                    4142   ; *                            context switch.  You can even assign a name to each task and store this name
                    4143   ; *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
                    4144   ; *
                    4145   ; *              opt           options as passed to 'OSTaskCreateExt()' or,
                    4146   ; *                            0 if called from 'OSTaskCreate()'.
                    4147   ; *
                    4148   ; * Returns    : OS_ERR_NONE         if the call was successful
                    4149   ; *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
                    4150   ; *                                  be created.
                    4151   ; *
                    4152   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    4153   ; *********************************************************************************************************
                    4154   ; */
                    4155   ; INT8U  OS_TCBInit (INT8U    prio,
                    4156   ; OS_STK  *ptos,
                    4157   ; OS_STK  *pbos,
                    4158   ; INT16U   id,
                    4159   ; INT32U   stk_size,
                    4160   ; void    *pext,
                    4161   ; INT16U   opt)
                    4162   ; {
                    4163   _OS_TCBInit:
080011A8  4E56 0000 4164          link      A6,#0
080011AC  48E7 3820 4165          movem.l   D2/D3/D4/A2,-(A7)
080011B0  45F9 0800 4166          lea       _OSTCBList.L,A2
080011B4  0438      
080011B6  182E 000B 4167          move.b    11(A6),D4
080011BA  C8BC 0000 4168          and.l     #255,D4
080011BE  00FF      
                    4169   ; OS_TCB    *ptcb;
                    4170   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4171   ; OS_CPU_SR  cpu_sr = 0u;
                    4172   ; #endif
                    4173   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    4174   ; INT8U      i;
                    4175   ; #endif
                    4176   ; OS_ENTER_CRITICAL();
080011C0  40E7      4177          dc.w      16615
080011C2  007C      4178          dc.w      124
080011C4  0700      4179          dc.w      1792
                    4180   ; ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
080011C6  2439 0800 4181          move.l    _OSTCBFreeList.L,D2
080011CA  0430      
                    4182   ; if (ptcb != (OS_TCB *)0) {
080011CC  4A82      4183          tst.l     D2
080011CE  6700 017E 4184          beq       OS_TCBInit_1
                    4185   ; OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
080011D2  2042      4186          move.l    D2,A0
080011D4  23E8 0014 4187          move.l    20(A0),_OSTCBFreeList.L
080011D8  0800 0430 
                    4188   ; OS_EXIT_CRITICAL();
080011DC  46DF      4189          dc.w      18143
                    4190   ; ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
080011DE  2042      4191          move.l    D2,A0
080011E0  20AE 000C 4192          move.l    12(A6),(A0)
                    4193   ; ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
080011E4  2042      4194          move.l    D2,A0
080011E6  1144 0034 4195          move.b    D4,52(A0)
                    4196   ; ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
080011EA  2042      4197          move.l    D2,A0
080011EC  4228 0032 4198          clr.b     50(A0)
                    4199   ; ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
080011F0  2042      4200          move.l    D2,A0
080011F2  4228 0033 4201          clr.b     51(A0)
                    4202   ; ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
080011F6  2042      4203          move.l    D2,A0
080011F8  42A8 002E 4204          clr.l     46(A0)
                    4205   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4206   ; ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
080011FC  2042      4207          move.l    D2,A0
080011FE  216E 001C 4208          move.l    28(A6),4(A0)
08001202  0004      
                    4209   ; ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
08001204  2042      4210          move.l    D2,A0
08001206  216E 0018 4211          move.l    24(A6),12(A0)
0800120A  000C      
                    4212   ; ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
0800120C  2042      4213          move.l    D2,A0
0800120E  216E 0010 4214          move.l    16(A6),8(A0)
08001212  0008      
                    4215   ; ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
08001214  2042      4216          move.l    D2,A0
08001216  316E 0022 4217          move.w    34(A6),16(A0)
0800121A  0010      
                    4218   ; ptcb->OSTCBId            = id;                     /* Store task ID                            */
0800121C  2042      4219          move.l    D2,A0
0800121E  316E 0016 4220          move.w    22(A6),18(A0)
08001222  0012      
                    4221   ; #else
                    4222   ; pext                     = pext;                   /* Prevent compiler warning if not used     */
                    4223   ; stk_size                 = stk_size;
                    4224   ; pbos                     = pbos;
                    4225   ; opt                      = opt;
                    4226   ; id                       = id;
                    4227   ; #endif
                    4228   ; #if OS_TASK_DEL_EN > 0u
                    4229   ; ptcb->OSTCBDelReq        = OS_ERR_NONE;
08001224  2042      4230          move.l    D2,A0
08001226  4228 0039 4231          clr.b     57(A0)
                    4232   ; #endif
                    4233   ; #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
                    4234   ; ptcb->OSTCBY             = (INT8U)(prio >> 3u);
0800122A  1004      4235          move.b    D4,D0
0800122C  E608      4236          lsr.b     #3,D0
0800122E  2042      4237          move.l    D2,A0
08001230  1140 0036 4238          move.b    D0,54(A0)
                    4239   ; ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
08001234  1004      4240          move.b    D4,D0
08001236  C03C 0007 4241          and.b     #7,D0
0800123A  2042      4242          move.l    D2,A0
0800123C  1140 0035 4243          move.b    D0,53(A0)
                    4244   ; #else                                                             /* Pre-compute X, Y                  */
                    4245   ; ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
                    4246   ; ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
                    4247   ; #endif
                    4248   ; /* Pre-compute BitX and BitY         */
                    4249   ; ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
08001240  7001      4250          moveq     #1,D0
08001242  2042      4251          move.l    D2,A0
08001244  1228 0036 4252          move.b    54(A0),D1
08001248  C2BC 0000 4253          and.l     #255,D1
0800124C  00FF      
0800124E  E3A8      4254          lsl.l     D1,D0
08001250  2042      4255          move.l    D2,A0
08001252  1140 0038 4256          move.b    D0,56(A0)
                    4257   ; ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
08001256  7001      4258          moveq     #1,D0
08001258  2042      4259          move.l    D2,A0
0800125A  1228 0035 4260          move.b    53(A0),D1
0800125E  C2BC 0000 4261          and.l     #255,D1
08001262  00FF      
08001264  E3A8      4262          lsl.l     D1,D0
08001266  2042      4263          move.l    D2,A0
08001268  1140 0037 4264          move.b    D0,55(A0)
                    4265   ; #if (OS_EVENT_EN)
                    4266   ; ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
0800126C  2042      4267          move.l    D2,A0
0800126E  42A8 001C 4268          clr.l     28(A0)
                    4269   ; #if (OS_EVENT_MULTI_EN > 0u)
                    4270   ; ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
08001272  2042      4271          move.l    D2,A0
08001274  42A8 0020 4272          clr.l     32(A0)
                    4273   ; #endif
                    4274   ; #endif
                    4275   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
                    4276   ; ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
08001278  2042      4277          move.l    D2,A0
0800127A  42A8 0028 4278          clr.l     40(A0)
                    4279   ; #endif
                    4280   ; #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    4281   ; ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
0800127E  2042      4282          move.l    D2,A0
08001280  42A8 0024 4283          clr.l     36(A0)
                    4284   ; #endif
                    4285   ; #if OS_TASK_PROFILE_EN > 0u
                    4286   ; ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
08001284  2042      4287          move.l    D2,A0
08001286  42A8 003A 4288          clr.l     58(A0)
                    4289   ; ptcb->OSTCBCyclesStart = 0uL;
0800128A  2042      4290          move.l    D2,A0
0800128C  42A8 0042 4291          clr.l     66(A0)
                    4292   ; ptcb->OSTCBCyclesTot   = 0uL;
08001290  2042      4293          move.l    D2,A0
08001292  42A8 003E 4294          clr.l     62(A0)
                    4295   ; ptcb->OSTCBStkBase     = (OS_STK *)0;
08001296  2042      4296          move.l    D2,A0
08001298  42A8 0046 4297          clr.l     70(A0)
                    4298   ; ptcb->OSTCBStkUsed     = 0uL;
0800129C  2042      4299          move.l    D2,A0
0800129E  42A8 004A 4300          clr.l     74(A0)
                    4301   ; #endif
                    4302   ; #if OS_TASK_NAME_EN > 0u
                    4303   ; ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
080012A2  41F9 0800 4304          lea       @ucos_ii_1.L,A0
080012A6  57FE      
080012A8  2242      4305          move.l    D2,A1
080012AA  2348 004E 4306          move.l    A0,78(A1)
                    4307   ; #endif
                    4308   ; #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
                    4309   ; for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
080012AE  4203      4310          clr.b     D3
                    4311   OS_TCBInit_3:
080012B0  0C03 0001 4312          cmp.b     #1,D3
080012B4  6416      4313          bhs.s     OS_TCBInit_5
                    4314   ; ptcb->OSTCBRegTbl[i] = 0u;
080012B6  2042      4315          move.l    D2,A0
080012B8  C6BC 0000 4316          and.l     #255,D3
080012BC  00FF      
080012BE  2003      4317          move.l    D3,D0
080012C0  E588      4318          lsl.l     #2,D0
080012C2  D1C0      4319          add.l     D0,A0
080012C4  42A8 0052 4320          clr.l     82(A0)
080012C8  5203      4321          addq.b    #1,D3
080012CA  60E4      4322          bra       OS_TCBInit_3
                    4323   OS_TCBInit_5:
                    4324   ; }
                    4325   ; #endif
                    4326   ; OSTCBInitHook(ptcb);
080012CC  2F02      4327          move.l    D2,-(A7)
080012CE  4EB9 0800 4328          jsr       _OSTCBInitHook
080012D2  02AE      
080012D4  584F      4329          addq.w    #4,A7
                    4330   ; OS_ENTER_CRITICAL();
080012D6  40E7      4331          dc.w      16615
080012D8  007C      4332          dc.w      124
080012DA  0700      4333          dc.w      1792
                    4334   ; OSTCBPrioTbl[prio] = ptcb;
080012DC  C8BC 0000 4335          and.l     #255,D4
080012E0  00FF      
080012E2  2004      4336          move.l    D4,D0
080012E4  E588      4337          lsl.l     #2,D0
080012E6  41F9 0800 4338          lea       _OSTCBPrioTbl.L,A0
080012EA  043C      
080012EC  2182 0800 4339          move.l    D2,0(A0,D0.L)
                    4340   ; OS_EXIT_CRITICAL();
080012F0  46DF      4341          dc.w      18143
                    4342   ; OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
080012F2  2F02      4343          move.l    D2,-(A7)
080012F4  4EB9 0800 4344          jsr       _OSTaskCreateHook
080012F8  0264      
080012FA  584F      4345          addq.w    #4,A7
                    4346   ; OS_ENTER_CRITICAL();
080012FC  40E7      4347          dc.w      16615
080012FE  007C      4348          dc.w      124
08001300  0700      4349          dc.w      1792
                    4350   ; ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
08001302  2042      4351          move.l    D2,A0
08001304  2152 0014 4352          move.l    (A2),20(A0)
                    4353   ; ptcb->OSTCBPrev    = (OS_TCB *)0;
08001308  2042      4354          move.l    D2,A0
0800130A  42A8 0018 4355          clr.l     24(A0)
                    4356   ; if (OSTCBList != (OS_TCB *)0) {
0800130E  2012      4357          move.l    (A2),D0
08001310  6706      4358          beq.s     OS_TCBInit_6
                    4359   ; OSTCBList->OSTCBPrev = ptcb;
08001312  2052      4360          move.l    (A2),A0
08001314  2142 0018 4361          move.l    D2,24(A0)
                    4362   OS_TCBInit_6:
                    4363   ; }
                    4364   ; OSTCBList               = ptcb;
08001318  2482      4365          move.l    D2,(A2)
                    4366   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0800131A  2042      4367          move.l    D2,A0
0800131C  1028 0038 4368          move.b    56(A0),D0
08001320  8139 0800 4369          or.b      D0,_OSRdyGrp.L
08001324  031A      
                    4370   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
08001326  2042      4371          move.l    D2,A0
08001328  1028 0036 4372          move.b    54(A0),D0
0800132C  C0BC 0000 4373          and.l     #255,D0
08001330  00FF      
08001332  41F9 0800 4374          lea       _OSRdyTbl.L,A0
08001336  031C      
08001338  2242      4375          move.l    D2,A1
0800133A  1229 0037 4376          move.b    55(A1),D1
0800133E  8330 0800 4377          or.b      D1,0(A0,D0.L)
                    4378   ; OSTaskCtr++;                                       /* Increment the #tasks counter             */
08001342  5239 0800 4379          addq.b    #1,_OSTaskCtr.L
08001346  0326      
                    4380   ; OS_EXIT_CRITICAL();
08001348  46DF      4381          dc.w      18143
                    4382   ; return (OS_ERR_NONE);
0800134A  4200      4383          clr.b     D0
0800134C  6004      4384          bra.s     OS_TCBInit_8
                    4385   OS_TCBInit_1:
                    4386   ; }
                    4387   ; OS_EXIT_CRITICAL();
0800134E  46DF      4388          dc.w      18143
                    4389   ; return (OS_ERR_TASK_NO_MORE_TCB);
08001350  7042      4390          moveq     #66,D0
                    4391   OS_TCBInit_8:
08001352  4CDF 041C 4392          movem.l   (A7)+,D2/D3/D4/A2
08001356  4E5E      4393          unlk      A6
08001358  4E75      4394          rts
                    4395   ; /*
                    4396   ; *********************************************************************************************************
                    4397   ; *                                                uC/OS-II
                    4398   ; *                                          The Real-Time Kernel
                    4399   ; *                                         EVENT FLAG  MANAGEMENT
                    4400   ; *
                    4401   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    4402   ; *                                           All Rights Reserved
                    4403   ; *
                    4404   ; * File    : OS_FLAG.C
                    4405   ; * By      : Jean J. Labrosse
                    4406   ; * Version : V2.92.07
                    4407   ; *
                    4408   ; * LICENSING TERMS:
                    4409   ; * ---------------
                    4410   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    4411   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    4412   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    4413   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    4414   ; * licensing fee.
                    4415   ; *********************************************************************************************************
                    4416   ; */
                    4417   ; #define  MICRIUM_SOURCE
                    4418   ; #ifndef  OS_MASTER_FILE
                    4419   ; #include <ucos_ii.h>
                    4420   ; #endif
                    4421   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    4422   ; /*
                    4423   ; *********************************************************************************************************
                    4424   ; *                                          LOCAL PROTOTYPES
                    4425   ; *********************************************************************************************************
                    4426   ; */
                    4427   ; static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
                    4428   ; static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
                    4429   ; /*$PAGE*/
                    4430   ; /*
                    4431   ; *********************************************************************************************************
                    4432   ; *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
                    4433   ; *
                    4434   ; * Description: This function is called to check the status of a combination of bits to be set or cleared
                    4435   ; *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
                    4436   ; *              bits to be set/cleared.
                    4437   ; *
                    4438   ; *              This call does not block if the desired flags are not present.
                    4439   ; *
                    4440   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4441   ; *
                    4442   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    4443   ; *                            The bits you want are specified by setting the corresponding bits in
                    4444   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    4445   ; *                            'flags' would contain 0x03.
                    4446   ; *
                    4447   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    4448   ; *                            to be set/cleared.
                    4449   ; *                            You can specify the following argument:
                    4450   ; *
                    4451   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
                    4452   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
                    4453   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
                    4454   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
                    4455   ; *
                    4456   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    4457   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    4458   ; *                                  the flags that are present, set 'wait_type' to:
                    4459   ; *
                    4460   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    4461   ; *
                    4462   ; *              perr          is a pointer to an error code and can be:
                    4463   ; *                            OS_ERR_NONE               No error
                    4464   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    4465   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    4466   ; *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
                    4467   ; *                                                      group handle.
                    4468   ; *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
                    4469   ; *                                                      available.
                    4470   ; *
                    4471   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    4472   ; *              occurred.
                    4473   ; *
                    4474   ; * Called from: Task or ISR
                    4475   ; *
                    4476   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    4477   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    4478   ; *                 event flags.
                    4479   ; *********************************************************************************************************
                    4480   ; */
                    4481   ; #if OS_FLAG_ACCEPT_EN > 0u
                    4482   ; OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                    4483   ; OS_FLAGS      flags,
                    4484   ; INT8U         wait_type,
                    4485   ; INT8U        *perr)
                    4486   ; {
                    4487   _OSFlagAccept:
0800135A  4E56 FFFC 4488          link      A6,#-4
0800135E  48E7 3F00 4489          movem.l   D2/D3/D4/D5/D6/D7,-(A7)
08001362  262E 0008 4490          move.l    8(A6),D3
08001366  282E 0014 4491          move.l    20(A6),D4
0800136A  3A2E 000E 4492          move.w    14(A6),D5
0800136E  CABC 0000 4493          and.l     #65535,D5
08001372  FFFF      
08001374  1E2E 0013 4494          move.b    19(A6),D7
08001378  CEBC 0000 4495          and.l     #255,D7
0800137C  00FF      
                    4496   ; OS_FLAGS      flags_rdy;
                    4497   ; INT8U         result;
                    4498   ; BOOLEAN       consume;
                    4499   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4500   ; OS_CPU_SR     cpu_sr = 0u;
                    4501   ; #endif
                    4502   ; #ifdef OS_SAFETY_CRITICAL
                    4503   ; if (perr == (INT8U *)0) {
                    4504   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4505   ; return ((OS_FLAGS)0);
                    4506   ; }
                    4507   ; #endif
                    4508   ; #if OS_ARG_CHK_EN > 0u
                    4509   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4510   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4511   ; return ((OS_FLAGS)0);
                    4512   ; }
                    4513   ; #endif
                    4514   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
0800137E  2043      4515          move.l    D3,A0
08001380  1010      4516          move.b    (A0),D0
08001382  0C00 0005 4517          cmp.b     #5,D0
08001386  670C      4518          beq.s     OSFlagAccept_1
                    4519   ; *perr = OS_ERR_EVENT_TYPE;
08001388  2044      4520          move.l    D4,A0
0800138A  10BC 0001 4521          move.b    #1,(A0)
                    4522   ; return ((OS_FLAGS)0);
0800138E  4240      4523          clr.w     D0
08001390  6000 0100 4524          bra       OSFlagAccept_3
                    4525   OSFlagAccept_1:
                    4526   ; }
                    4527   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
08001394  1007      4528          move.b    D7,D0
08001396  C03C 0080 4529          and.b     #128,D0
0800139A  1D40 FFFF 4530          move.b    D0,-1(A6)
                    4531   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
0800139E  102E FFFF 4532          move.b    -1(A6),D0
080013A2  6708      4533          beq.s     OSFlagAccept_4
                    4534   ; wait_type &= (INT8U)~OS_FLAG_CONSUME;
080013A4  CE3C 007F 4535          and.b     #127,D7
                    4536   ; consume    = OS_TRUE;
080013A8  7C01      4537          moveq     #1,D6
080013AA  6002      4538          bra.s     OSFlagAccept_5
                    4539   OSFlagAccept_4:
                    4540   ; } else {
                    4541   ; consume    = OS_FALSE;
080013AC  4206      4542          clr.b     D6
                    4543   OSFlagAccept_5:
                    4544   ; }
                    4545   ; /*$PAGE*/
                    4546   ; *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
080013AE  2044      4547          move.l    D4,A0
080013B0  4210      4548          clr.b     (A0)
                    4549   ; OS_ENTER_CRITICAL();
080013B2  40E7      4550          dc.w      16615
080013B4  007C      4551          dc.w      124
080013B6  0700      4552          dc.w      1792
                    4553   ; switch (wait_type) {
080013B8  CEBC 0000 4554          and.l     #255,D7
080013BC  00FF      
080013BE  2007      4555          move.l    D7,D0
080013C0  0C80 0000 4556          cmp.l     #4,D0
080013C4  0004      
080013C6  6400 00BE 4557          bhs       OSFlagAccept_6
080013CA  E380      4558          asl.l     #1,D0
080013CC  303B 0806 4559          move.w    OSFlagAccept_8(PC,D0.L),D0
080013D0  4EFB 0002 4560          jmp       OSFlagAccept_8(PC,D0.W)
                    4561   OSFlagAccept_8:
080013D4  0060      4562          dc.w      OSFlagAccept_11-OSFlagAccept_8
080013D6  008A      4563          dc.w      OSFlagAccept_12-OSFlagAccept_8
080013D8  0008      4564          dc.w      OSFlagAccept_9-OSFlagAccept_8
080013DA  0034      4565          dc.w      OSFlagAccept_10-OSFlagAccept_8
                    4566   OSFlagAccept_9:
                    4567   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    4568   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
080013DC  2043      4569          move.l    D3,A0
080013DE  3028 0006 4570          move.w    6(A0),D0
080013E2  C045      4571          and.w     D5,D0
080013E4  3400      4572          move.w    D0,D2
                    4573   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
080013E6  B445      4574          cmp.w     D5,D2
080013E8  6612      4575          bne.s     OSFlagAccept_14
                    4576   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
080013EA  0C06 0001 4577          cmp.b     #1,D6
080013EE  660A      4578          bne.s     OSFlagAccept_16
                    4579   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
080013F0  2043      4580          move.l    D3,A0
080013F2  3002      4581          move.w    D2,D0
080013F4  4640      4582          not.w     D0
080013F6  C168 0006 4583          and.w     D0,6(A0)
                    4584   OSFlagAccept_16:
080013FA  6006      4585          bra.s     OSFlagAccept_15
                    4586   OSFlagAccept_14:
                    4587   ; }
                    4588   ; } else {
                    4589   ; *perr = OS_ERR_FLAG_NOT_RDY;
080013FC  2044      4590          move.l    D4,A0
080013FE  10BC 0070 4591          move.b    #112,(A0)
                    4592   OSFlagAccept_15:
                    4593   ; }
                    4594   ; OS_EXIT_CRITICAL();
08001402  46DF      4595          dc.w      18143
                    4596   ; break;
08001404  6000 008A 4597          bra       OSFlagAccept_7
                    4598   OSFlagAccept_10:
                    4599   ; case OS_FLAG_WAIT_SET_ANY:
                    4600   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
08001408  2043      4601          move.l    D3,A0
0800140A  3028 0006 4602          move.w    6(A0),D0
0800140E  C045      4603          and.w     D5,D0
08001410  3400      4604          move.w    D0,D2
                    4605   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
08001412  4A42      4606          tst.w     D2
08001414  6712      4607          beq.s     OSFlagAccept_18
                    4608   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
08001416  0C06 0001 4609          cmp.b     #1,D6
0800141A  660A      4610          bne.s     OSFlagAccept_20
                    4611   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
0800141C  2043      4612          move.l    D3,A0
0800141E  3002      4613          move.w    D2,D0
08001420  4640      4614          not.w     D0
08001422  C168 0006 4615          and.w     D0,6(A0)
                    4616   OSFlagAccept_20:
08001426  6006      4617          bra.s     OSFlagAccept_19
                    4618   OSFlagAccept_18:
                    4619   ; }
                    4620   ; } else {
                    4621   ; *perr = OS_ERR_FLAG_NOT_RDY;
08001428  2044      4622          move.l    D4,A0
0800142A  10BC 0070 4623          move.b    #112,(A0)
                    4624   OSFlagAccept_19:
                    4625   ; }
                    4626   ; OS_EXIT_CRITICAL();
0800142E  46DF      4627          dc.w      18143
                    4628   ; break;
08001430  6000 005E 4629          bra       OSFlagAccept_7
                    4630   OSFlagAccept_11:
                    4631   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    4632   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    4633   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
08001434  2043      4634          move.l    D3,A0
08001436  3028 0006 4635          move.w    6(A0),D0
0800143A  4640      4636          not.w     D0
0800143C  C045      4637          and.w     D5,D0
0800143E  3400      4638          move.w    D0,D2
                    4639   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
08001440  B445      4640          cmp.w     D5,D2
08001442  660E      4641          bne.s     OSFlagAccept_22
                    4642   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
08001444  0C06 0001 4643          cmp.b     #1,D6
08001448  6606      4644          bne.s     OSFlagAccept_24
                    4645   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
0800144A  2043      4646          move.l    D3,A0
0800144C  8568 0006 4647          or.w      D2,6(A0)
                    4648   OSFlagAccept_24:
08001450  6006      4649          bra.s     OSFlagAccept_23
                    4650   OSFlagAccept_22:
                    4651   ; }
                    4652   ; } else {
                    4653   ; *perr = OS_ERR_FLAG_NOT_RDY;
08001452  2044      4654          move.l    D4,A0
08001454  10BC 0070 4655          move.b    #112,(A0)
                    4656   OSFlagAccept_23:
                    4657   ; }
                    4658   ; OS_EXIT_CRITICAL();
08001458  46DF      4659          dc.w      18143
                    4660   ; break;
0800145A  6000 0034 4661          bra       OSFlagAccept_7
                    4662   OSFlagAccept_12:
                    4663   ; case OS_FLAG_WAIT_CLR_ANY:
                    4664   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
0800145E  2043      4665          move.l    D3,A0
08001460  3028 0006 4666          move.w    6(A0),D0
08001464  4640      4667          not.w     D0
08001466  C045      4668          and.w     D5,D0
08001468  3400      4669          move.w    D0,D2
                    4670   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
0800146A  4A42      4671          tst.w     D2
0800146C  670E      4672          beq.s     OSFlagAccept_26
                    4673   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
0800146E  0C06 0001 4674          cmp.b     #1,D6
08001472  6606      4675          bne.s     OSFlagAccept_28
                    4676   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
08001474  2043      4677          move.l    D3,A0
08001476  8568 0006 4678          or.w      D2,6(A0)
                    4679   OSFlagAccept_28:
0800147A  6006      4680          bra.s     OSFlagAccept_27
                    4681   OSFlagAccept_26:
                    4682   ; }
                    4683   ; } else {
                    4684   ; *perr = OS_ERR_FLAG_NOT_RDY;
0800147C  2044      4685          move.l    D4,A0
0800147E  10BC 0070 4686          move.b    #112,(A0)
                    4687   OSFlagAccept_27:
                    4688   ; }
                    4689   ; OS_EXIT_CRITICAL();
08001482  46DF      4690          dc.w      18143
                    4691   ; break;
08001484  600A      4692          bra.s     OSFlagAccept_7
                    4693   OSFlagAccept_6:
                    4694   ; #endif
                    4695   ; default:
                    4696   ; OS_EXIT_CRITICAL();
08001486  46DF      4697          dc.w      18143
                    4698   ; flags_rdy = (OS_FLAGS)0;
08001488  4242      4699          clr.w     D2
                    4700   ; *perr     = OS_ERR_FLAG_WAIT_TYPE;
0800148A  2044      4701          move.l    D4,A0
0800148C  10BC 006F 4702          move.b    #111,(A0)
                    4703   ; break;
                    4704   OSFlagAccept_7:
                    4705   ; }
                    4706   ; return (flags_rdy);
08001490  3002      4707          move.w    D2,D0
                    4708   OSFlagAccept_3:
08001492  4CDF 00FC 4709          movem.l   (A7)+,D2/D3/D4/D5/D6/D7
08001496  4E5E      4710          unlk      A6
08001498  4E75      4711          rts
                    4712   ; }
                    4713   ; #endif
                    4714   ; /*$PAGE*/
                    4715   ; /*
                    4716   ; *********************************************************************************************************
                    4717   ; *                                        CREATE AN EVENT FLAG
                    4718   ; *
                    4719   ; * Description: This function is called to create an event flag group.
                    4720   ; *
                    4721   ; * Arguments  : flags         Contains the initial value to store in the event flag group.
                    4722   ; *
                    4723   ; *              perr          is a pointer to an error code which will be returned to your application:
                    4724   ; *                               OS_ERR_NONE               if the call was successful.
                    4725   ; *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
                    4726   ; *                                                         ISR.
                    4727   ; *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
                    4728   ; *
                    4729   ; * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
                    4730   ; *
                    4731   ; * Called from: Task ONLY
                    4732   ; *********************************************************************************************************
                    4733   ; */
                    4734   ; OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
                    4735   ; INT8U    *perr)
                    4736   ; {
                    4737   _OSFlagCreate:
0800149A  4E56 0000 4738          link      A6,#0
0800149E  48E7 3020 4739          movem.l   D2/D3/A2,-(A7)
080014A2  45F9 0800 4740          lea       _OSFlagFreeList.L,A2
080014A6  0202      
080014A8  262E 000C 4741          move.l    12(A6),D3
                    4742   ; OS_FLAG_GRP *pgrp;
                    4743   ; #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
                    4744   ; OS_CPU_SR    cpu_sr = 0u;
                    4745   ; #endif
                    4746   ; #ifdef OS_SAFETY_CRITICAL
                    4747   ; if (perr == (INT8U *)0) {
                    4748   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4749   ; return ((OS_FLAG_GRP *)0);
                    4750   ; }
                    4751   ; #endif
                    4752   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    4753   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    4754   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4755   ; return ((OS_FLAG_GRP *)0);
                    4756   ; }
                    4757   ; #endif
                    4758   ; if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
080014AC  1039 0800 4759          move.b    _OSIntNesting.L,D0
080014B0  0312      
080014B2  0C00 0000 4760          cmp.b     #0,D0
080014B6  630C      4761          bls.s     OSFlagCreate_1
                    4762   ; *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
080014B8  2043      4763          move.l    D3,A0
080014BA  10BC 0010 4764          move.b    #16,(A0)
                    4765   ; return ((OS_FLAG_GRP *)0);
080014BE  4280      4766          clr.l     D0
080014C0  6000 0046 4767          bra       OSFlagCreate_3
                    4768   OSFlagCreate_1:
                    4769   ; }
                    4770   ; OS_ENTER_CRITICAL();
080014C4  40E7      4771          dc.w      16615
080014C6  007C      4772          dc.w      124
080014C8  0700      4773          dc.w      1792
                    4774   ; pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
080014CA  2412      4775          move.l    (A2),D2
                    4776   ; if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
080014CC  4A82      4777          tst.l     D2
080014CE  672E      4778          beq.s     OSFlagCreate_4
                    4779   ; /* Adjust free list                                */
                    4780   ; OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
080014D0  2052      4781          move.l    (A2),A0
080014D2  24A8 0002 4782          move.l    2(A0),(A2)
                    4783   ; pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
080014D6  2042      4784          move.l    D2,A0
080014D8  10BC 0005 4785          move.b    #5,(A0)
                    4786   ; pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
080014DC  2042      4787          move.l    D2,A0
080014DE  316E 000A 4788          move.w    10(A6),6(A0)
080014E2  0006      
                    4789   ; pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
080014E4  2042      4790          move.l    D2,A0
080014E6  42A8 0002 4791          clr.l     2(A0)
                    4792   ; #if OS_FLAG_NAME_EN > 0u
                    4793   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
080014EA  41F9 0800 4794          lea       @ucos_ii_1.L,A0
080014EE  57FE      
080014F0  2242      4795          move.l    D2,A1
080014F2  2348 0008 4796          move.l    A0,8(A1)
                    4797   ; #endif
                    4798   ; OS_EXIT_CRITICAL();
080014F6  46DF      4799          dc.w      18143
                    4800   ; *perr                = OS_ERR_NONE;
080014F8  2043      4801          move.l    D3,A0
080014FA  4210      4802          clr.b     (A0)
080014FC  6008      4803          bra.s     OSFlagCreate_5
                    4804   OSFlagCreate_4:
                    4805   ; } else {
                    4806   ; OS_EXIT_CRITICAL();
080014FE  46DF      4807          dc.w      18143
                    4808   ; *perr                = OS_ERR_FLAG_GRP_DEPLETED;
08001500  2043      4809          move.l    D3,A0
08001502  10BC 0072 4810          move.b    #114,(A0)
                    4811   OSFlagCreate_5:
                    4812   ; }
                    4813   ; return (pgrp);                                  /* Return pointer to event flag group              */
08001506  2002      4814          move.l    D2,D0
                    4815   OSFlagCreate_3:
08001508  4CDF 040C 4816          movem.l   (A7)+,D2/D3/A2
0800150C  4E5E      4817          unlk      A6
0800150E  4E75      4818          rts
                    4819   ; }
                    4820   ; /*$PAGE*/
                    4821   ; /*
                    4822   ; *********************************************************************************************************
                    4823   ; *                                     DELETE AN EVENT FLAG GROUP
                    4824   ; *
                    4825   ; * Description: This function deletes an event flag group and readies all tasks pending on the event flag
                    4826   ; *              group.
                    4827   ; *
                    4828   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4829   ; *
                    4830   ; *              opt           determines delete options as follows:
                    4831   ; *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
                    4832   ; *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
                    4833   ; *                                                    waiting.  In this case, all the tasks pending will be
                    4834   ; *                                                    readied.
                    4835   ; *
                    4836   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    4837   ; *                            OS_ERR_NONE               The call was successful and the event flag group was
                    4838   ; *                                                      deleted
                    4839   ; *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
                    4840   ; *                                                      an ISR
                    4841   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    4842   ; *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
                    4843   ; *                            OS_ERR_INVALID_OPT        An invalid option was specified
                    4844   ; *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
                    4845   ; *                                                      group.
                    4846   ; *
                    4847   ; * Returns    : pgrp          upon error
                    4848   ; *              (OS_EVENT *)0 if the event flag group was successfully deleted.
                    4849   ; *
                    4850   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    4851   ; *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
                    4852   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    4853   ; *                 time is directly proportional to the number of tasks waiting on the event flag group.
                    4854   ; *              3) All tasks that were waiting for the event flag will be readied and returned an
                    4855   ; *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
                    4856   ; *********************************************************************************************************
                    4857   ; */
                    4858   ; #if OS_FLAG_DEL_EN > 0u
                    4859   ; OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
                    4860   ; INT8U         opt,
                    4861   ; INT8U        *perr)
                    4862   ; {
                    4863   _OSFlagDel:
08001510  4E56 0000 4864          link      A6,#0
08001514  48E7 3E20 4865          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
08001518  242E 0008 4866          move.l    8(A6),D2
0800151C  262E 0010 4867          move.l    16(A6),D3
08001520  45F9 0800 4868          lea       _OSFlagFreeList.L,A2
08001524  0202      
                    4869   ; BOOLEAN       tasks_waiting;
                    4870   ; OS_FLAG_NODE *pnode;
                    4871   ; OS_FLAG_GRP  *pgrp_return;
                    4872   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4873   ; OS_CPU_SR     cpu_sr = 0u;
                    4874   ; #endif
                    4875   ; #ifdef OS_SAFETY_CRITICAL
                    4876   ; if (perr == (INT8U *)0) {
                    4877   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4878   ; return ((OS_FLAG_GRP *)0);
                    4879   ; }
                    4880   ; #endif
                    4881   ; #if OS_ARG_CHK_EN > 0u
                    4882   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4883   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4884   ; return (pgrp);
                    4885   ; }
                    4886   ; #endif
                    4887   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
08001526  1039 0800 4888          move.b    _OSIntNesting.L,D0
0800152A  0312      
0800152C  0C00 0000 4889          cmp.b     #0,D0
08001530  630C      4890          bls.s     OSFlagDel_1
                    4891   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
08001532  2043      4892          move.l    D3,A0
08001534  10BC 000F 4893          move.b    #15,(A0)
                    4894   ; return (pgrp);
08001538  2002      4895          move.l    D2,D0
0800153A  6000 00EE 4896          bra       OSFlagDel_3
                    4897   OSFlagDel_1:
                    4898   ; }
                    4899   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
0800153E  2042      4900          move.l    D2,A0
08001540  1010      4901          move.b    (A0),D0
08001542  0C00 0005 4902          cmp.b     #5,D0
08001546  670C      4903          beq.s     OSFlagDel_4
                    4904   ; *perr = OS_ERR_EVENT_TYPE;
08001548  2043      4905          move.l    D3,A0
0800154A  10BC 0001 4906          move.b    #1,(A0)
                    4907   ; return (pgrp);
0800154E  2002      4908          move.l    D2,D0
08001550  6000 00D8 4909          bra       OSFlagDel_3
                    4910   OSFlagDel_4:
                    4911   ; }
                    4912   ; OS_ENTER_CRITICAL();
08001554  40E7      4913          dc.w      16615
08001556  007C      4914          dc.w      124
08001558  0700      4915          dc.w      1792
                    4916   ; if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
0800155A  2042      4917          move.l    D2,A0
0800155C  2028 0002 4918          move.l    2(A0),D0
08001560  6704      4919          beq.s     OSFlagDel_6
                    4920   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
08001562  7C01      4921          moveq     #1,D6
08001564  6002      4922          bra.s     OSFlagDel_7
                    4923   OSFlagDel_6:
                    4924   ; } else {
                    4925   ; tasks_waiting = OS_FALSE;                          /* No                                       */
08001566  4206      4926          clr.b     D6
                    4927   OSFlagDel_7:
                    4928   ; }
                    4929   ; switch (opt) {
08001568  102E 000F 4930          move.b    15(A6),D0
0800156C  C0BC 0000 4931          and.l     #255,D0
08001570  00FF      
08001572  0C80 0000 4932          cmp.l     #1,D0
08001576  0001      
08001578  6700 0048 4933          beq       OSFlagDel_11
0800157C  6200 00A0 4934          bhi       OSFlagDel_8
08001580  4A80      4935          tst.l     D0
08001582  6704      4936          beq.s     OSFlagDel_10
08001584  6000 0098 4937          bra       OSFlagDel_8
                    4938   OSFlagDel_10:
                    4939   ; case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
                    4940   ; if (tasks_waiting == OS_FALSE) {
08001588  4A06      4941          tst.b     D6
0800158A  6628      4942          bne.s     OSFlagDel_13
                    4943   ; #if OS_FLAG_NAME_EN > 0u
                    4944   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
0800158C  41F9 0800 4945          lea       @ucos_ii_1.L,A0
08001590  57FE      
08001592  2242      4946          move.l    D2,A1
08001594  2348 0008 4947          move.l    A0,8(A1)
                    4948   ; #endif
                    4949   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
08001598  2042      4950          move.l    D2,A0
0800159A  4210      4951          clr.b     (A0)
                    4952   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
0800159C  2042      4953          move.l    D2,A0
0800159E  2152 0002 4954          move.l    (A2),2(A0)
                    4955   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
080015A2  2042      4956          move.l    D2,A0
080015A4  4268 0006 4957          clr.w     6(A0)
                    4958   ; OSFlagFreeList       = pgrp;
080015A8  2482      4959          move.l    D2,(A2)
                    4960   ; OS_EXIT_CRITICAL();
080015AA  46DF      4961          dc.w      18143
                    4962   ; *perr                = OS_ERR_NONE;
080015AC  2043      4963          move.l    D3,A0
080015AE  4210      4964          clr.b     (A0)
                    4965   ; pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
080015B0  4285      4966          clr.l     D5
080015B2  600A      4967          bra.s     OSFlagDel_14
                    4968   OSFlagDel_13:
                    4969   ; } else {
                    4970   ; OS_EXIT_CRITICAL();
080015B4  46DF      4971          dc.w      18143
                    4972   ; *perr                = OS_ERR_TASK_WAITING;
080015B6  2043      4973          move.l    D3,A0
080015B8  10BC 0049 4974          move.b    #73,(A0)
                    4975   ; pgrp_return          = pgrp;
080015BC  2A02      4976          move.l    D2,D5
                    4977   OSFlagDel_14:
                    4978   ; }
                    4979   ; break;
080015BE  6000 0068 4980          bra       OSFlagDel_9
                    4981   OSFlagDel_11:
                    4982   ; case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
                    4983   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
080015C2  2042      4984          move.l    D2,A0
080015C4  2828 0002 4985          move.l    2(A0),D4
                    4986   ; while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                    4987   OSFlagDel_15:
080015C8  4A84      4988          tst.l     D4
080015CA  671E      4989          beq.s     OSFlagDel_17
                    4990   ; (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
080015CC  4878 0002 4991          pea       2
080015D0  42A7      4992          clr.l     -(A7)
080015D2  2F04      4993          move.l    D4,-(A7)
080015D4  4EB9 0800 4994          jsr       @ucos_ii_OS_FlagTaskRdy
080015D8  1D50      
080015DA  DEFC 000C 4995          add.w     #12,A7
080015DE  C0BC 0000 4996          and.l     #255,D0
080015E2  00FF      
                    4997   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
080015E4  2044      4998          move.l    D4,A0
080015E6  2810      4999          move.l    (A0),D4
080015E8  60DE      5000          bra       OSFlagDel_15
                    5001   OSFlagDel_17:
                    5002   ; }
                    5003   ; #if OS_FLAG_NAME_EN > 0u
                    5004   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
080015EA  41F9 0800 5005          lea       @ucos_ii_1.L,A0
080015EE  57FE      
080015F0  2242      5006          move.l    D2,A1
080015F2  2348 0008 5007          move.l    A0,8(A1)
                    5008   ; #endif
                    5009   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
080015F6  2042      5010          move.l    D2,A0
080015F8  4210      5011          clr.b     (A0)
                    5012   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
080015FA  2042      5013          move.l    D2,A0
080015FC  2152 0002 5014          move.l    (A2),2(A0)
                    5015   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
08001600  2042      5016          move.l    D2,A0
08001602  4268 0006 5017          clr.w     6(A0)
                    5018   ; OSFlagFreeList       = pgrp;
08001606  2482      5019          move.l    D2,(A2)
                    5020   ; OS_EXIT_CRITICAL();
08001608  46DF      5021          dc.w      18143
                    5022   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0800160A  0C06 0001 5023          cmp.b     #1,D6
0800160E  6606      5024          bne.s     OSFlagDel_18
                    5025   ; OS_Sched();                               /* Find highest priority task ready to run  */
08001610  4EB9 0800 5026          jsr       _OS_Sched
08001614  0F8A      
                    5027   OSFlagDel_18:
                    5028   ; }
                    5029   ; *perr = OS_ERR_NONE;
08001616  2043      5030          move.l    D3,A0
08001618  4210      5031          clr.b     (A0)
                    5032   ; pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
0800161A  4285      5033          clr.l     D5
                    5034   ; break;
0800161C  600A      5035          bra.s     OSFlagDel_9
                    5036   OSFlagDel_8:
                    5037   ; default:
                    5038   ; OS_EXIT_CRITICAL();
0800161E  46DF      5039          dc.w      18143
                    5040   ; *perr                = OS_ERR_INVALID_OPT;
08001620  2043      5041          move.l    D3,A0
08001622  10BC 0007 5042          move.b    #7,(A0)
                    5043   ; pgrp_return          = pgrp;
08001626  2A02      5044          move.l    D2,D5
                    5045   ; break;
                    5046   OSFlagDel_9:
                    5047   ; }
                    5048   ; return (pgrp_return);
08001628  2005      5049          move.l    D5,D0
                    5050   OSFlagDel_3:
0800162A  4CDF 047C 5051          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
0800162E  4E5E      5052          unlk      A6
08001630  4E75      5053          rts
                    5054   ; }
                    5055   ; #endif
                    5056   ; /*$PAGE*/
                    5057   ; /*
                    5058   ; *********************************************************************************************************
                    5059   ; *                                 GET THE NAME OF AN EVENT FLAG GROUP
                    5060   ; *
                    5061   ; * Description: This function is used to obtain the name assigned to an event flag group
                    5062   ; *
                    5063   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5064   ; *
                    5065   ; *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
                    5066   ; *                        group.
                    5067   ; *
                    5068   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5069   ; *
                    5070   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5071   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5072   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5073   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5074   ; *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
                    5075   ; *
                    5076   ; * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
                    5077   ; *********************************************************************************************************
                    5078   ; */
                    5079   ; #if OS_FLAG_NAME_EN > 0u
                    5080   ; INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
                    5081   ; INT8U        **pname,
                    5082   ; INT8U         *perr)
                    5083   ; {
                    5084   _OSFlagNameGet:
08001632  4E56 FFFC 5085          link      A6,#-4
08001636  2F02      5086          move.l    D2,-(A7)
08001638  242E 0010 5087          move.l    16(A6),D2
                    5088   ; INT8U      len;
                    5089   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5090   ; OS_CPU_SR  cpu_sr = 0u;
                    5091   ; #endif
                    5092   ; #ifdef OS_SAFETY_CRITICAL
                    5093   ; if (perr == (INT8U *)0) {
                    5094   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5095   ; return (0u);
                    5096   ; }
                    5097   ; #endif
                    5098   ; #if OS_ARG_CHK_EN > 0u
                    5099   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5100   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5101   ; return (0u);
                    5102   ; }
                    5103   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5104   ; *perr = OS_ERR_PNAME_NULL;
                    5105   ; return (0u);
                    5106   ; }
                    5107   ; #endif
                    5108   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
0800163C  1039 0800 5109          move.b    _OSIntNesting.L,D0
08001640  0312      
08001642  0C00 0000 5110          cmp.b     #0,D0
08001646  630C      5111          bls.s     OSFlagNameGet_1
                    5112   ; *perr = OS_ERR_NAME_GET_ISR;
08001648  2042      5113          move.l    D2,A0
0800164A  10BC 0011 5114          move.b    #17,(A0)
                    5115   ; return (0u);
0800164E  4200      5116          clr.b     D0
08001650  6000 0048 5117          bra       OSFlagNameGet_3
                    5118   OSFlagNameGet_1:
                    5119   ; }
                    5120   ; OS_ENTER_CRITICAL();
08001654  40E7      5121          dc.w      16615
08001656  007C      5122          dc.w      124
08001658  0700      5123          dc.w      1792
                    5124   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
0800165A  206E 0008 5125          move.l    8(A6),A0
0800165E  1010      5126          move.b    (A0),D0
08001660  0C00 0005 5127          cmp.b     #5,D0
08001664  670C      5128          beq.s     OSFlagNameGet_4
                    5129   ; OS_EXIT_CRITICAL();
08001666  46DF      5130          dc.w      18143
                    5131   ; *perr = OS_ERR_EVENT_TYPE;
08001668  2042      5132          move.l    D2,A0
0800166A  10BC 0001 5133          move.b    #1,(A0)
                    5134   ; return (0u);
0800166E  4200      5135          clr.b     D0
08001670  6028      5136          bra.s     OSFlagNameGet_3
                    5137   OSFlagNameGet_4:
                    5138   ; }
                    5139   ; *pname = pgrp->OSFlagName;
08001672  206E 0008 5140          move.l    8(A6),A0
08001676  226E 000C 5141          move.l    12(A6),A1
0800167A  22A8 0008 5142          move.l    8(A0),(A1)
                    5143   ; len    = OS_StrLen(*pname);
0800167E  206E 000C 5144          move.l    12(A6),A0
08001682  2F10      5145          move.l    (A0),-(A7)
08001684  4EB9 0800 5146          jsr       _OS_StrLen
08001688  1034      
0800168A  584F      5147          addq.w    #4,A7
0800168C  1D40 FFFF 5148          move.b    D0,-1(A6)
                    5149   ; OS_EXIT_CRITICAL();
08001690  46DF      5150          dc.w      18143
                    5151   ; *perr  = OS_ERR_NONE;
08001692  2042      5152          move.l    D2,A0
08001694  4210      5153          clr.b     (A0)
                    5154   ; return (len);
08001696  102E FFFF 5155          move.b    -1(A6),D0
                    5156   OSFlagNameGet_3:
0800169A  241F      5157          move.l    (A7)+,D2
0800169C  4E5E      5158          unlk      A6
0800169E  4E75      5159          rts
                    5160   ; }
                    5161   ; #endif
                    5162   ; /*$PAGE*/
                    5163   ; /*
                    5164   ; *********************************************************************************************************
                    5165   ; *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
                    5166   ; *
                    5167   ; * Description: This function assigns a name to an event flag group.
                    5168   ; *
                    5169   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5170   ; *
                    5171   ; *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
                    5172   ; *                        group.
                    5173   ; *
                    5174   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5175   ; *
                    5176   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5177   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5178   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5179   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5180   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    5181   ; *
                    5182   ; * Returns    : None
                    5183   ; *********************************************************************************************************
                    5184   ; */
                    5185   ; #if OS_FLAG_NAME_EN > 0u
                    5186   ; void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
                    5187   ; INT8U        *pname,
                    5188   ; INT8U        *perr)
                    5189   ; {
                    5190   _OSFlagNameSet:
080016A0  4E56 0000 5191          link      A6,#0
080016A4  2F02      5192          move.l    D2,-(A7)
080016A6  242E 0010 5193          move.l    16(A6),D2
                    5194   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5195   ; OS_CPU_SR  cpu_sr = 0u;
                    5196   ; #endif
                    5197   ; #ifdef OS_SAFETY_CRITICAL
                    5198   ; if (perr == (INT8U *)0) {
                    5199   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5200   ; return;
                    5201   ; }
                    5202   ; #endif
                    5203   ; #if OS_ARG_CHK_EN > 0u
                    5204   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5205   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5206   ; return;
                    5207   ; }
                    5208   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5209   ; *perr = OS_ERR_PNAME_NULL;
                    5210   ; return;
                    5211   ; }
                    5212   ; #endif
                    5213   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
080016AA  1039 0800 5214          move.b    _OSIntNesting.L,D0
080016AE  0312      
080016B0  0C00 0000 5215          cmp.b     #0,D0
080016B4  630A      5216          bls.s     OSFlagNameSet_1
                    5217   ; *perr = OS_ERR_NAME_SET_ISR;
080016B6  2042      5218          move.l    D2,A0
080016B8  10BC 0012 5219          move.b    #18,(A0)
                    5220   ; return;
080016BC  6000 002E 5221          bra       OSFlagNameSet_3
                    5222   OSFlagNameSet_1:
                    5223   ; }
                    5224   ; OS_ENTER_CRITICAL();
080016C0  40E7      5225          dc.w      16615
080016C2  007C      5226          dc.w      124
080016C4  0700      5227          dc.w      1792
                    5228   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
080016C6  206E 0008 5229          move.l    8(A6),A0
080016CA  1010      5230          move.b    (A0),D0
080016CC  0C00 0005 5231          cmp.b     #5,D0
080016D0  670A      5232          beq.s     OSFlagNameSet_4
                    5233   ; OS_EXIT_CRITICAL();
080016D2  46DF      5234          dc.w      18143
                    5235   ; *perr = OS_ERR_EVENT_TYPE;
080016D4  2042      5236          move.l    D2,A0
080016D6  10BC 0001 5237          move.b    #1,(A0)
                    5238   ; return;
080016DA  6010      5239          bra.s     OSFlagNameSet_3
                    5240   OSFlagNameSet_4:
                    5241   ; }
                    5242   ; pgrp->OSFlagName = pname;
080016DC  206E 0008 5243          move.l    8(A6),A0
080016E0  216E 000C 5244          move.l    12(A6),8(A0)
080016E4  0008      
                    5245   ; OS_EXIT_CRITICAL();
080016E6  46DF      5246          dc.w      18143
                    5247   ; *perr            = OS_ERR_NONE;
080016E8  2042      5248          move.l    D2,A0
080016EA  4210      5249          clr.b     (A0)
                    5250   ; return;
                    5251   OSFlagNameSet_3:
080016EC  241F      5252          move.l    (A7)+,D2
080016EE  4E5E      5253          unlk      A6
080016F0  4E75      5254          rts
                    5255   ; }
                    5256   ; #endif
                    5257   ; /*$PAGE*/
                    5258   ; /*
                    5259   ; *********************************************************************************************************
                    5260   ; *                                     WAIT ON AN EVENT FLAG GROUP
                    5261   ; *
                    5262   ; * Description: This function is called to wait for a combination of bits to be set in an event flag
                    5263   ; *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
                    5264   ; *
                    5265   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5266   ; *
                    5267   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
                    5268   ; *                            The bits you want are specified by setting the corresponding bits in
                    5269   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    5270   ; *                            'flags' would contain 0x03.
                    5271   ; *
                    5272   ; *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
                    5273   ; *                            You can specify the following argument:
                    5274   ; *
                    5275   ; *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
                    5276   ; *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
                    5277   ; *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
                    5278   ; *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
                    5279   ; *
                    5280   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    5281   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    5282   ; *                                  the flags that are present, set 'wait_type' to:
                    5283   ; *
                    5284   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    5285   ; *
                    5286   ; *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
                    5287   ; *                            desired bit combination.  If you specify 0, however, your task will wait
                    5288   ; *                            forever at the specified event flag group or, until a message arrives.
                    5289   ; *
                    5290   ; *              perr          is a pointer to an error code and can be:
                    5291   ; *                            OS_ERR_NONE               The desired bits have been set within the specified
                    5292   ; *                                                      'timeout'.
                    5293   ; *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
                    5294   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5295   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    5296   ; *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
                    5297   ; *                                                      'timeout'.
                    5298   ; *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
                    5299   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    5300   ; *
                    5301   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    5302   ; *              occurred.
                    5303   ; *
                    5304   ; * Called from: Task ONLY
                    5305   ; *
                    5306   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    5307   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    5308   ; *                 event flags.
                    5309   ; *********************************************************************************************************
                    5310   ; */
                    5311   ; OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
                    5312   ; OS_FLAGS      flags,
                    5313   ; INT8U         wait_type,
                    5314   ; INT32U        timeout,
                    5315   ; INT8U        *perr)
                    5316   ; {
                    5317   _OSFlagPend:
080016F2  4E56 FFE8 5318          link      A6,#-24
080016F6  48E7 3F3C 5319          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
080016FA  262E 0008 5320          move.l    8(A6),D3
080016FE  282E 0018 5321          move.l    24(A6),D4
08001702  3A2E 000E 5322          move.w    14(A6),D5
08001706  CABC 0000 5323          and.l     #65535,D5
0800170A  FFFF      
0800170C  45F9 0800 5324          lea       _OSTCBCur.L,A2
08001710  042C      
08001712  1C2E 0013 5325          move.b    19(A6),D6
08001716  CCBC 0000 5326          and.l     #255,D6
0800171A  00FF      
0800171C  47EE FFEA 5327          lea       -22(A6),A3
08001720  286E 0014 5328          move.l    20(A6),A4
08001724  4BF9 0800 5329          lea       @ucos_ii_OS_FlagBlock.L,A5
08001728  1BF0      
                    5330   ; OS_FLAG_NODE  node;
                    5331   ; OS_FLAGS      flags_rdy;
                    5332   ; INT8U         result;
                    5333   ; INT8U         pend_stat;
                    5334   ; BOOLEAN       consume;
                    5335   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5336   ; OS_CPU_SR     cpu_sr = 0u;
                    5337   ; #endif
                    5338   ; #ifdef OS_SAFETY_CRITICAL
                    5339   ; if (perr == (INT8U *)0) {
                    5340   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5341   ; return ((OS_FLAGS)0);
                    5342   ; }
                    5343   ; #endif
                    5344   ; #if OS_ARG_CHK_EN > 0u
                    5345   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5346   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5347   ; return ((OS_FLAGS)0);
                    5348   ; }
                    5349   ; #endif
                    5350   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0800172A  1039 0800 5351          move.b    _OSIntNesting.L,D0
0800172E  0312      
08001730  0C00 0000 5352          cmp.b     #0,D0
08001734  630C      5353          bls.s     OSFlagPend_1
                    5354   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
08001736  2044      5355          move.l    D4,A0
08001738  10BC 0002 5356          move.b    #2,(A0)
                    5357   ; return ((OS_FLAGS)0);
0800173C  4240      5358          clr.w     D0
0800173E  6000 028C 5359          bra       OSFlagPend_3
                    5360   OSFlagPend_1:
                    5361   ; }
                    5362   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
08001742  1039 0800 5363          move.b    _OSLockNesting.L,D0
08001746  0314      
08001748  0C00 0000 5364          cmp.b     #0,D0
0800174C  630C      5365          bls.s     OSFlagPend_4
                    5366   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
0800174E  2044      5367          move.l    D4,A0
08001750  10BC 000D 5368          move.b    #13,(A0)
                    5369   ; return ((OS_FLAGS)0);
08001754  4240      5370          clr.w     D0
08001756  6000 0274 5371          bra       OSFlagPend_3
                    5372   OSFlagPend_4:
                    5373   ; }
                    5374   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
0800175A  2043      5375          move.l    D3,A0
0800175C  1010      5376          move.b    (A0),D0
0800175E  0C00 0005 5377          cmp.b     #5,D0
08001762  670C      5378          beq.s     OSFlagPend_6
                    5379   ; *perr = OS_ERR_EVENT_TYPE;
08001764  2044      5380          move.l    D4,A0
08001766  10BC 0001 5381          move.b    #1,(A0)
                    5382   ; return ((OS_FLAGS)0);
0800176A  4240      5383          clr.w     D0
0800176C  6000 025E 5384          bra       OSFlagPend_3
                    5385   OSFlagPend_6:
                    5386   ; }
                    5387   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
08001770  1006      5388          move.b    D6,D0
08001772  C03C 0080 5389          and.b     #128,D0
08001776  1D40 FFFE 5390          move.b    D0,-2(A6)
                    5391   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
0800177A  102E FFFE 5392          move.b    -2(A6),D0
0800177E  670C      5393          beq.s     OSFlagPend_8
                    5394   ; wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
08001780  103C 0080 5395          move.b    #128,D0
08001784  4600      5396          not.b     D0
08001786  CC00      5397          and.b     D0,D6
                    5398   ; consume    = OS_TRUE;
08001788  7E01      5399          moveq     #1,D7
0800178A  6002      5400          bra.s     OSFlagPend_9
                    5401   OSFlagPend_8:
                    5402   ; } else {
                    5403   ; consume    = OS_FALSE;
0800178C  7E00      5404          moveq     #0,D7
                    5405   OSFlagPend_9:
                    5406   ; }
                    5407   ; /*$PAGE*/
                    5408   ; OS_ENTER_CRITICAL();
0800178E  40E7      5409          dc.w      16615
08001790  007C      5410          dc.w      124
08001792  0700      5411          dc.w      1792
                    5412   ; switch (wait_type) {
08001794  CCBC 0000 5413          and.l     #255,D6
08001798  00FF      
0800179A  2006      5414          move.l    D6,D0
0800179C  0C80 0000 5415          cmp.l     #4,D0
080017A0  0004      
080017A2  6400 0156 5416          bhs       OSFlagPend_10
080017A6  E380      5417          asl.l     #1,D0
080017A8  303B 0806 5418          move.w    OSFlagPend_12(PC,D0.L),D0
080017AC  4EFB 0002 5419          jmp       OSFlagPend_12(PC,D0.W)
                    5420   OSFlagPend_12:
080017B0  00AC      5421          dc.w      OSFlagPend_15-OSFlagPend_12
080017B2  00FC      5422          dc.w      OSFlagPend_16-OSFlagPend_12
080017B4  0008      5423          dc.w      OSFlagPend_13-OSFlagPend_12
080017B6  005A      5424          dc.w      OSFlagPend_14-OSFlagPend_12
                    5425   OSFlagPend_13:
                    5426   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    5427   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
080017B8  2043      5428          move.l    D3,A0
080017BA  3028 0006 5429          move.w    6(A0),D0
080017BE  C045      5430          and.w     D5,D0
080017C0  3400      5431          move.w    D0,D2
                    5432   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
080017C2  B445      5433          cmp.w     D5,D2
080017C4  6622      5434          bne.s     OSFlagPend_18
                    5435   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
080017C6  0C07 0001 5436          cmp.b     #1,D7
080017CA  660A      5437          bne.s     OSFlagPend_20
                    5438   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
080017CC  2043      5439          move.l    D3,A0
080017CE  3002      5440          move.w    D2,D0
080017D0  4640      5441          not.w     D0
080017D2  C168 0006 5442          and.w     D0,6(A0)
                    5443   OSFlagPend_20:
                    5444   ; }
                    5445   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
080017D6  2052      5446          move.l    (A2),A0
080017D8  3142 002C 5447          move.w    D2,44(A0)
                    5448   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
080017DC  46DF      5449          dc.w      18143
                    5450   ; *perr                   = OS_ERR_NONE;
080017DE  2044      5451          move.l    D4,A0
080017E0  4210      5452          clr.b     (A0)
                    5453   ; return (flags_rdy);
080017E2  3002      5454          move.w    D2,D0
080017E4  6000 01E6 5455          bra       OSFlagPend_3
                    5456   OSFlagPend_18:
                    5457   ; } else {                                      /* Block task until events occur or timeout */
                    5458   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
080017E8  2F0C      5459          move.l    A4,-(A7)
080017EA  CCBC 0000 5460          and.l     #255,D6
080017EE  00FF      
080017F0  2F06      5461          move.l    D6,-(A7)
080017F2  CABC 0000 5462          and.l     #65535,D5
080017F6  FFFF      
080017F8  2F05      5463          move.l    D5,-(A7)
080017FA  2F0B      5464          move.l    A3,-(A7)
080017FC  2F03      5465          move.l    D3,-(A7)
080017FE  4E95      5466          jsr       (A5)
08001800  DEFC 0014 5467          add.w     #20,A7
                    5468   ; OS_EXIT_CRITICAL();
08001804  46DF      5469          dc.w      18143
                    5470   ; }
                    5471   ; break;
08001806  6000 0102 5472          bra       OSFlagPend_11
                    5473   OSFlagPend_14:
                    5474   ; case OS_FLAG_WAIT_SET_ANY:
                    5475   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
0800180A  2043      5476          move.l    D3,A0
0800180C  3028 0006 5477          move.w    6(A0),D0
08001810  C045      5478          and.w     D5,D0
08001812  3400      5479          move.w    D0,D2
                    5480   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
08001814  4A42      5481          tst.w     D2
08001816  6722      5482          beq.s     OSFlagPend_22
                    5483   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
08001818  0C07 0001 5484          cmp.b     #1,D7
0800181C  660A      5485          bne.s     OSFlagPend_24
                    5486   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
0800181E  2043      5487          move.l    D3,A0
08001820  3002      5488          move.w    D2,D0
08001822  4640      5489          not.w     D0
08001824  C168 0006 5490          and.w     D0,6(A0)
                    5491   OSFlagPend_24:
                    5492   ; }
                    5493   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
08001828  2052      5494          move.l    (A2),A0
0800182A  3142 002C 5495          move.w    D2,44(A0)
                    5496   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
0800182E  46DF      5497          dc.w      18143
                    5498   ; *perr                   = OS_ERR_NONE;
08001830  2044      5499          move.l    D4,A0
08001832  4210      5500          clr.b     (A0)
                    5501   ; return (flags_rdy);
08001834  3002      5502          move.w    D2,D0
08001836  6000 0194 5503          bra       OSFlagPend_3
                    5504   OSFlagPend_22:
                    5505   ; } else {                                      /* Block task until events occur or timeout */
                    5506   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
0800183A  2F0C      5507          move.l    A4,-(A7)
0800183C  CCBC 0000 5508          and.l     #255,D6
08001840  00FF      
08001842  2F06      5509          move.l    D6,-(A7)
08001844  CABC 0000 5510          and.l     #65535,D5
08001848  FFFF      
0800184A  2F05      5511          move.l    D5,-(A7)
0800184C  2F0B      5512          move.l    A3,-(A7)
0800184E  2F03      5513          move.l    D3,-(A7)
08001850  4E95      5514          jsr       (A5)
08001852  DEFC 0014 5515          add.w     #20,A7
                    5516   ; OS_EXIT_CRITICAL();
08001856  46DF      5517          dc.w      18143
                    5518   ; }
                    5519   ; break;
08001858  6000 00B0 5520          bra       OSFlagPend_11
                    5521   OSFlagPend_15:
                    5522   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5523   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    5524   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
0800185C  2043      5525          move.l    D3,A0
0800185E  3028 0006 5526          move.w    6(A0),D0
08001862  4640      5527          not.w     D0
08001864  C045      5528          and.w     D5,D0
08001866  3400      5529          move.w    D0,D2
                    5530   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
08001868  B445      5531          cmp.w     D5,D2
0800186A  661E      5532          bne.s     OSFlagPend_26
                    5533   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
0800186C  0C07 0001 5534          cmp.b     #1,D7
08001870  6606      5535          bne.s     OSFlagPend_28
                    5536   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
08001872  2043      5537          move.l    D3,A0
08001874  8568 0006 5538          or.w      D2,6(A0)
                    5539   OSFlagPend_28:
                    5540   ; }
                    5541   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
08001878  2052      5542          move.l    (A2),A0
0800187A  3142 002C 5543          move.w    D2,44(A0)
                    5544   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
0800187E  46DF      5545          dc.w      18143
                    5546   ; *perr                   = OS_ERR_NONE;
08001880  2044      5547          move.l    D4,A0
08001882  4210      5548          clr.b     (A0)
                    5549   ; return (flags_rdy);
08001884  3002      5550          move.w    D2,D0
08001886  6000 0144 5551          bra       OSFlagPend_3
                    5552   OSFlagPend_26:
                    5553   ; } else {                                      /* Block task until events occur or timeout */
                    5554   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
0800188A  2F0C      5555          move.l    A4,-(A7)
0800188C  CCBC 0000 5556          and.l     #255,D6
08001890  00FF      
08001892  2F06      5557          move.l    D6,-(A7)
08001894  CABC 0000 5558          and.l     #65535,D5
08001898  FFFF      
0800189A  2F05      5559          move.l    D5,-(A7)
0800189C  2F0B      5560          move.l    A3,-(A7)
0800189E  2F03      5561          move.l    D3,-(A7)
080018A0  4E95      5562          jsr       (A5)
080018A2  DEFC 0014 5563          add.w     #20,A7
                    5564   ; OS_EXIT_CRITICAL();
080018A6  46DF      5565          dc.w      18143
                    5566   ; }
                    5567   ; break;
080018A8  6000 0060 5568          bra       OSFlagPend_11
                    5569   OSFlagPend_16:
                    5570   ; case OS_FLAG_WAIT_CLR_ANY:
                    5571   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
080018AC  2043      5572          move.l    D3,A0
080018AE  3028 0006 5573          move.w    6(A0),D0
080018B2  4640      5574          not.w     D0
080018B4  C045      5575          and.w     D5,D0
080018B6  3400      5576          move.w    D0,D2
                    5577   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
080018B8  4A42      5578          tst.w     D2
080018BA  671E      5579          beq.s     OSFlagPend_30
                    5580   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
080018BC  0C07 0001 5581          cmp.b     #1,D7
080018C0  6606      5582          bne.s     OSFlagPend_32
                    5583   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
080018C2  2043      5584          move.l    D3,A0
080018C4  8568 0006 5585          or.w      D2,6(A0)
                    5586   OSFlagPend_32:
                    5587   ; }
                    5588   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
080018C8  2052      5589          move.l    (A2),A0
080018CA  3142 002C 5590          move.w    D2,44(A0)
                    5591   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
080018CE  46DF      5592          dc.w      18143
                    5593   ; *perr                   = OS_ERR_NONE;
080018D0  2044      5594          move.l    D4,A0
080018D2  4210      5595          clr.b     (A0)
                    5596   ; return (flags_rdy);
080018D4  3002      5597          move.w    D2,D0
080018D6  6000 00F4 5598          bra       OSFlagPend_3
                    5599   OSFlagPend_30:
                    5600   ; } else {                                      /* Block task until events occur or timeout */
                    5601   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
080018DA  2F0C      5602          move.l    A4,-(A7)
080018DC  CCBC 0000 5603          and.l     #255,D6
080018E0  00FF      
080018E2  2F06      5604          move.l    D6,-(A7)
080018E4  CABC 0000 5605          and.l     #65535,D5
080018E8  FFFF      
080018EA  2F05      5606          move.l    D5,-(A7)
080018EC  2F0B      5607          move.l    A3,-(A7)
080018EE  2F03      5608          move.l    D3,-(A7)
080018F0  4E95      5609          jsr       (A5)
080018F2  DEFC 0014 5610          add.w     #20,A7
                    5611   ; OS_EXIT_CRITICAL();
080018F6  46DF      5612          dc.w      18143
                    5613   ; }
                    5614   ; break;
080018F8  6010      5615          bra.s     OSFlagPend_11
                    5616   OSFlagPend_10:
                    5617   ; #endif
                    5618   ; default:
                    5619   ; OS_EXIT_CRITICAL();
080018FA  46DF      5620          dc.w      18143
                    5621   ; flags_rdy = (OS_FLAGS)0;
080018FC  4242      5622          clr.w     D2
                    5623   ; *perr      = OS_ERR_FLAG_WAIT_TYPE;
080018FE  2044      5624          move.l    D4,A0
08001900  10BC 006F 5625          move.b    #111,(A0)
                    5626   ; return (flags_rdy);
08001904  3002      5627          move.w    D2,D0
08001906  6000 00C4 5628          bra       OSFlagPend_3
                    5629   OSFlagPend_11:
                    5630   ; }
                    5631   ; /*$PAGE*/
                    5632   ; OS_Sched();                                            /* Find next HPT ready to run               */
0800190A  4EB9 0800 5633          jsr       _OS_Sched
0800190E  0F8A      
                    5634   ; OS_ENTER_CRITICAL();
08001910  40E7      5635          dc.w      16615
08001912  007C      5636          dc.w      124
08001914  0700      5637          dc.w      1792
                    5638   ; if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
08001916  2052      5639          move.l    (A2),A0
08001918  1028 0033 5640          move.b    51(A0),D0
0800191C  6700 0056 5641          beq       OSFlagPend_34
                    5642   ; pend_stat                = OSTCBCur->OSTCBStatPend;
08001920  2052      5643          move.l    (A2),A0
08001922  1D68 0033 5644          move.b    51(A0),-1(A6)
08001926  FFFF      
                    5645   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
08001928  2052      5646          move.l    (A2),A0
0800192A  4228 0033 5647          clr.b     51(A0)
                    5648   ; OS_FlagUnlink(&node);
0800192E  2F0B      5649          move.l    A3,-(A7)
08001930  4EB9 0800 5650          jsr       _OS_FlagUnlink
08001934  1DCC      
08001936  584F      5651          addq.w    #4,A7
                    5652   ; OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
08001938  2052      5653          move.l    (A2),A0
0800193A  4228 0032 5654          clr.b     50(A0)
                    5655   ; OS_EXIT_CRITICAL();
0800193E  46DF      5656          dc.w      18143
                    5657   ; flags_rdy                = (OS_FLAGS)0;
08001940  4242      5658          clr.w     D2
                    5659   ; switch (pend_stat) {
08001942  102E FFFF 5660          move.b    -1(A6),D0
08001946  C0BC 0000 5661          and.l     #255,D0
0800194A  00FF      
0800194C  0C80 0000 5662          cmp.l     #2,D0
08001950  0002      
08001952  670C      5663          beq.s     OSFlagPend_38
08001954  6212      5664          bhi.s     OSFlagPend_39
08001956  0C80 0000 5665          cmp.l     #1,D0
0800195A  0001      
0800195C  670A      5666          beq.s     OSFlagPend_39
0800195E  6008      5667          bra.s     OSFlagPend_39
                    5668   OSFlagPend_38:
                    5669   ; case OS_STAT_PEND_ABORT:
                    5670   ; *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
08001960  2044      5671          move.l    D4,A0
08001962  10BC 000E 5672          move.b    #14,(A0)
                    5673   ; break;
08001966  6006      5674          bra.s     OSFlagPend_37
                    5675   OSFlagPend_39:
                    5676   ; case OS_STAT_PEND_TO:
                    5677   ; default:
                    5678   ; *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
08001968  2044      5679          move.l    D4,A0
0800196A  10BC 000A 5680          move.b    #10,(A0)
                    5681   ; break;
                    5682   OSFlagPend_37:
                    5683   ; }
                    5684   ; return (flags_rdy);
0800196E  3002      5685          move.w    D2,D0
08001970  6000 005A 5686          bra       OSFlagPend_3
                    5687   OSFlagPend_34:
                    5688   ; }
                    5689   ; flags_rdy = OSTCBCur->OSTCBFlagsRdy;
08001974  2052      5690          move.l    (A2),A0
08001976  3428 002C 5691          move.w    44(A0),D2
                    5692   ; if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
0800197A  0C07 0001 5693          cmp.b     #1,D7
0800197E  6600 0044 5694          bne       OSFlagPend_44
                    5695   ; switch (wait_type) {
08001982  CCBC 0000 5696          and.l     #255,D6
08001986  00FF      
08001988  2006      5697          move.l    D6,D0
0800198A  0C80 0000 5698          cmp.l     #4,D0
0800198E  0004      
08001990  6426      5699          bhs.s     OSFlagPend_43
08001992  E380      5700          asl.l     #1,D0
08001994  303B 0806 5701          move.w    OSFlagPend_45(PC,D0.L),D0
08001998  4EFB 0002 5702          jmp       OSFlagPend_45(PC,D0.W)
                    5703   OSFlagPend_45:
0800199C  0014      5704          dc.w      OSFlagPend_48-OSFlagPend_45
0800199E  0014      5705          dc.w      OSFlagPend_48-OSFlagPend_45
080019A0  0008      5706          dc.w      OSFlagPend_46-OSFlagPend_45
080019A2  0008      5707          dc.w      OSFlagPend_46-OSFlagPend_45
                    5708   OSFlagPend_46:
                    5709   ; case OS_FLAG_WAIT_SET_ALL:
                    5710   ; case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                    5711   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
080019A4  2043      5712          move.l    D3,A0
080019A6  3002      5713          move.w    D2,D0
080019A8  4640      5714          not.w     D0
080019AA  C168 0006 5715          and.w     D0,6(A0)
                    5716   ; break;
080019AE  6014      5717          bra.s     OSFlagPend_44
                    5718   OSFlagPend_48:
                    5719   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5720   ; case OS_FLAG_WAIT_CLR_ALL:
                    5721   ; case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                    5722   ; pgrp->OSFlagFlags |=  flags_rdy;
080019B0  2043      5723          move.l    D3,A0
080019B2  8568 0006 5724          or.w      D2,6(A0)
                    5725   ; break;
080019B6  600C      5726          bra.s     OSFlagPend_44
                    5727   OSFlagPend_43:
                    5728   ; #endif
                    5729   ; default:
                    5730   ; OS_EXIT_CRITICAL();
080019B8  46DF      5731          dc.w      18143
                    5732   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
080019BA  2044      5733          move.l    D4,A0
080019BC  10BC 006F 5734          move.b    #111,(A0)
                    5735   ; return ((OS_FLAGS)0);
080019C0  4240      5736          clr.w     D0
080019C2  6008      5737          bra.s     OSFlagPend_3
                    5738   OSFlagPend_44:
                    5739   ; }
                    5740   ; }
                    5741   ; OS_EXIT_CRITICAL();
080019C4  46DF      5742          dc.w      18143
                    5743   ; *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
080019C6  2044      5744          move.l    D4,A0
080019C8  4210      5745          clr.b     (A0)
                    5746   ; return (flags_rdy);
080019CA  3002      5747          move.w    D2,D0
                    5748   OSFlagPend_3:
080019CC  4CDF 3CFC 5749          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
080019D0  4E5E      5750          unlk      A6
080019D2  4E75      5751          rts
                    5752   ; }
                    5753   ; /*$PAGE*/
                    5754   ; /*
                    5755   ; *********************************************************************************************************
                    5756   ; *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
                    5757   ; *
                    5758   ; * Description: This function is called to obtain the flags that caused the task to become ready to run.
                    5759   ; *              In other words, this function allows you to tell "Who done it!".
                    5760   ; *
                    5761   ; * Arguments  : None
                    5762   ; *
                    5763   ; * Returns    : The flags that caused the task to be ready.
                    5764   ; *
                    5765   ; * Called from: Task ONLY
                    5766   ; *********************************************************************************************************
                    5767   ; */
                    5768   ; OS_FLAGS  OSFlagPendGetFlagsRdy (void)
                    5769   ; {
                    5770   _OSFlagPendGetFlagsRdy:
080019D4  4E56 FFFC 5771          link      A6,#-4
                    5772   ; OS_FLAGS      flags;
                    5773   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5774   ; OS_CPU_SR     cpu_sr = 0u;
                    5775   ; #endif
                    5776   ; OS_ENTER_CRITICAL();
080019D8  40E7      5777          dc.w      16615
080019DA  007C      5778          dc.w      124
080019DC  0700      5779          dc.w      1792
                    5780   ; flags = OSTCBCur->OSTCBFlagsRdy;
080019DE  2079 0800 5781          move.l    _OSTCBCur.L,A0
080019E2  042C      
080019E4  3D68 002C 5782          move.w    44(A0),-2(A6)
080019E8  FFFE      
                    5783   ; OS_EXIT_CRITICAL();
080019EA  46DF      5784          dc.w      18143
                    5785   ; return (flags);
080019EC  302E FFFE 5786          move.w    -2(A6),D0
080019F0  4E5E      5787          unlk      A6
080019F2  4E75      5788          rts
                    5789   ; }
                    5790   ; /*$PAGE*/
                    5791   ; /*
                    5792   ; *********************************************************************************************************
                    5793   ; *                                       POST EVENT FLAG BIT(S)
                    5794   ; *
                    5795   ; * Description: This function is called to set or clear some bits in an event flag group.  The bits to
                    5796   ; *              set or clear are specified by a 'bit mask'.
                    5797   ; *
                    5798   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5799   ; *
                    5800   ; *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
                    5801   ; *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
                    5802   ; *                            and 5 you would set 'flags' to:
                    5803   ; *
                    5804   ; *                                0x31     (note, bit 0 is least significant bit)
                    5805   ; *
                    5806   ; *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
                    5807   ; *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
                    5808   ; *                            4 and 5 you would specify 'flags' as:
                    5809   ; *
                    5810   ; *                                0x31     (note, bit 0 is least significant bit)
                    5811   ; *
                    5812   ; *              opt           indicates whether the flags will be:
                    5813   ; *                                set     (OS_FLAG_SET) or
                    5814   ; *                                cleared (OS_FLAG_CLR)
                    5815   ; *
                    5816   ; *              perr          is a pointer to an error code and can be:
                    5817   ; *                            OS_ERR_NONE                The call was successfull
                    5818   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    5819   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    5820   ; *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
                    5821   ; *
                    5822   ; * Returns    : the new value of the event flags bits that are still set.
                    5823   ; *
                    5824   ; * Called From: Task or ISR
                    5825   ; *
                    5826   ; * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
                    5827   ; *                 flag group.
                    5828   ; *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
                    5829   ; *                 the event flag group.
                    5830   ; *********************************************************************************************************
                    5831   ; */
                    5832   ; OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
                    5833   ; OS_FLAGS      flags,
                    5834   ; INT8U         opt,
                    5835   ; INT8U        *perr)
                    5836   ; {
                    5837   _OSFlagPost:
080019F4  4E56 FFFC 5838          link      A6,#-4
080019F8  48E7 3F20 5839          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
080019FC  282E 0008 5840          move.l    8(A6),D4
08001A00  45F9 0800 5841          lea       @ucos_ii_OS_FlagTaskRdy.L,A2
08001A04  1D50      
08001A06  2E2E 0014 5842          move.l    20(A6),D7
                    5843   ; OS_FLAG_NODE *pnode;
                    5844   ; BOOLEAN       sched;
                    5845   ; OS_FLAGS      flags_cur;
                    5846   ; OS_FLAGS      flags_rdy;
                    5847   ; BOOLEAN       rdy;
                    5848   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    5849   ; OS_CPU_SR     cpu_sr = 0u;
                    5850   ; #endif
                    5851   ; #ifdef OS_SAFETY_CRITICAL
                    5852   ; if (perr == (INT8U *)0) {
                    5853   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5854   ; return ((OS_FLAGS)0);
                    5855   ; }
                    5856   ; #endif
                    5857   ; #if OS_ARG_CHK_EN > 0u
                    5858   ; if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
                    5859   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5860   ; return ((OS_FLAGS)0);
                    5861   ; }
                    5862   ; #endif
                    5863   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
08001A0A  2044      5864          move.l    D4,A0
08001A0C  1010      5865          move.b    (A0),D0
08001A0E  0C00 0005 5866          cmp.b     #5,D0
08001A12  670C      5867          beq.s     OSFlagPost_1
                    5868   ; *perr = OS_ERR_EVENT_TYPE;
08001A14  2047      5869          move.l    D7,A0
08001A16  10BC 0001 5870          move.b    #1,(A0)
                    5871   ; return ((OS_FLAGS)0);
08001A1A  4240      5872          clr.w     D0
08001A1C  6000 018E 5873          bra       OSFlagPost_3
                    5874   OSFlagPost_1:
                    5875   ; }
                    5876   ; /*$PAGE*/
                    5877   ; OS_ENTER_CRITICAL();
08001A20  40E7      5878          dc.w      16615
08001A22  007C      5879          dc.w      124
08001A24  0700      5880          dc.w      1792
                    5881   ; switch (opt) {
08001A26  102E 0013 5882          move.b    19(A6),D0
08001A2A  C0BC 0000 5883          and.l     #255,D0
08001A2E  00FF      
08001A30  0C80 0000 5884          cmp.l     #1,D0
08001A34  0001      
08001A36  6716      5885          beq.s     OSFlagPost_7
08001A38  6220      5886          bhi.s     OSFlagPost_4
08001A3A  4A80      5887          tst.l     D0
08001A3C  6702      5888          beq.s     OSFlagPost_6
08001A3E  601A      5889          bra.s     OSFlagPost_4
                    5890   OSFlagPost_6:
                    5891   ; case OS_FLAG_CLR:
                    5892   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
08001A40  2044      5893          move.l    D4,A0
08001A42  302E 000E 5894          move.w    14(A6),D0
08001A46  4640      5895          not.w     D0
08001A48  C168 0006 5896          and.w     D0,6(A0)
                    5897   ; break;
08001A4C  601A      5898          bra.s     OSFlagPost_5
                    5899   OSFlagPost_7:
                    5900   ; case OS_FLAG_SET:
                    5901   ; pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
08001A4E  2044      5902          move.l    D4,A0
08001A50  302E 000E 5903          move.w    14(A6),D0
08001A54  8168 0006 5904          or.w      D0,6(A0)
                    5905   ; break;
08001A58  600E      5906          bra.s     OSFlagPost_5
                    5907   OSFlagPost_4:
                    5908   ; default:
                    5909   ; OS_EXIT_CRITICAL();                     /* INVALID option                                 */
08001A5A  46DF      5910          dc.w      18143
                    5911   ; *perr = OS_ERR_FLAG_INVALID_OPT;
08001A5C  2047      5912          move.l    D7,A0
08001A5E  10BC 0071 5913          move.b    #113,(A0)
                    5914   ; return ((OS_FLAGS)0);
08001A62  4240      5915          clr.w     D0
08001A64  6000 0146 5916          bra       OSFlagPost_3
                    5917   OSFlagPost_5:
                    5918   ; }
                    5919   ; sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
08001A68  4206      5920          clr.b     D6
                    5921   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
08001A6A  2044      5922          move.l    D4,A0
08001A6C  2428 0002 5923          move.l    2(A0),D2
                    5924   ; while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
                    5925   OSFlagPost_9:
08001A70  4A82      5926          tst.l     D2
08001A72  6700 0112 5927          beq       OSFlagPost_11
                    5928   ; switch (pnode->OSFlagNodeWaitType) {
08001A76  2042      5929          move.l    D2,A0
08001A78  1028 0012 5930          move.b    18(A0),D0
08001A7C  C0BC 0000 5931          and.l     #255,D0
08001A80  00FF      
08001A82  0C80 0000 5932          cmp.l     #4,D0
08001A86  0004      
08001A88  6400 00E6 5933          bhs       OSFlagPost_12
08001A8C  E380      5934          asl.l     #1,D0
08001A8E  303B 0806 5935          move.w    OSFlagPost_14(PC,D0.L),D0
08001A92  4EFB 0002 5936          jmp       OSFlagPost_14(PC,D0.W)
                    5937   OSFlagPost_14:
08001A96  0070      5938          dc.w      OSFlagPost_17-OSFlagPost_14
08001A98  00A8      5939          dc.w      OSFlagPost_18-OSFlagPost_14
08001A9A  0008      5940          dc.w      OSFlagPost_15-OSFlagPost_14
08001A9C  003E      5941          dc.w      OSFlagPost_16-OSFlagPost_14
                    5942   OSFlagPost_15:
                    5943   ; case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                    5944   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
08001A9E  2044      5945          move.l    D4,A0
08001AA0  3028 0006 5946          move.w    6(A0),D0
08001AA4  2042      5947          move.l    D2,A0
08001AA6  C068 0010 5948          and.w     16(A0),D0
08001AAA  3600      5949          move.w    D0,D3
                    5950   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
08001AAC  2042      5951          move.l    D2,A0
08001AAE  B668 0010 5952          cmp.w     16(A0),D3
08001AB2  661C      5953          bne.s     OSFlagPost_22
                    5954   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
08001AB4  42A7      5955          clr.l     -(A7)
08001AB6  C6BC 0000 5956          and.l     #65535,D3
08001ABA  FFFF      
08001ABC  2F03      5957          move.l    D3,-(A7)
08001ABE  2F02      5958          move.l    D2,-(A7)
08001AC0  4E92      5959          jsr       (A2)
08001AC2  DEFC 000C 5960          add.w     #12,A7
08001AC6  1A00      5961          move.b    D0,D5
                    5962   ; if (rdy == OS_TRUE) {
08001AC8  0C05 0001 5963          cmp.b     #1,D5
08001ACC  6602      5964          bne.s     OSFlagPost_22
                    5965   ; sched = OS_TRUE;                     /* When done we will reschedule          */
08001ACE  7C01      5966          moveq     #1,D6
                    5967   OSFlagPost_22:
                    5968   ; }
                    5969   ; }
                    5970   ; break;
08001AD0  6000 00AC 5971          bra       OSFlagPost_13
                    5972   OSFlagPost_16:
                    5973   ; case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                    5974   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
08001AD4  2044      5975          move.l    D4,A0
08001AD6  3028 0006 5976          move.w    6(A0),D0
08001ADA  2042      5977          move.l    D2,A0
08001ADC  C068 0010 5978          and.w     16(A0),D0
08001AE0  3600      5979          move.w    D0,D3
                    5980   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
08001AE2  4A43      5981          tst.w     D3
08001AE4  671C      5982          beq.s     OSFlagPost_26
                    5983   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
08001AE6  42A7      5984          clr.l     -(A7)
08001AE8  C6BC 0000 5985          and.l     #65535,D3
08001AEC  FFFF      
08001AEE  2F03      5986          move.l    D3,-(A7)
08001AF0  2F02      5987          move.l    D2,-(A7)
08001AF2  4E92      5988          jsr       (A2)
08001AF4  DEFC 000C 5989          add.w     #12,A7
08001AF8  1A00      5990          move.b    D0,D5
                    5991   ; if (rdy == OS_TRUE) {
08001AFA  0C05 0001 5992          cmp.b     #1,D5
08001AFE  6602      5993          bne.s     OSFlagPost_26
                    5994   ; sched = OS_TRUE;                     /* When done we will reschedule          */
08001B00  7C01      5995          moveq     #1,D6
                    5996   OSFlagPost_26:
                    5997   ; }
                    5998   ; }
                    5999   ; break;
08001B02  6000 007A 6000          bra       OSFlagPost_13
                    6001   OSFlagPost_17:
                    6002   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    6003   ; case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                    6004   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
08001B06  2044      6005          move.l    D4,A0
08001B08  3028 0006 6006          move.w    6(A0),D0
08001B0C  4640      6007          not.w     D0
08001B0E  2042      6008          move.l    D2,A0
08001B10  C068 0010 6009          and.w     16(A0),D0
08001B14  3600      6010          move.w    D0,D3
                    6011   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
08001B16  2042      6012          move.l    D2,A0
08001B18  B668 0010 6013          cmp.w     16(A0),D3
08001B1C  661C      6014          bne.s     OSFlagPost_30
                    6015   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
08001B1E  42A7      6016          clr.l     -(A7)
08001B20  C6BC 0000 6017          and.l     #65535,D3
08001B24  FFFF      
08001B26  2F03      6018          move.l    D3,-(A7)
08001B28  2F02      6019          move.l    D2,-(A7)
08001B2A  4E92      6020          jsr       (A2)
08001B2C  DEFC 000C 6021          add.w     #12,A7
08001B30  1A00      6022          move.b    D0,D5
                    6023   ; if (rdy == OS_TRUE) {
08001B32  0C05 0001 6024          cmp.b     #1,D5
08001B36  6602      6025          bne.s     OSFlagPost_30
                    6026   ; sched = OS_TRUE;                     /* When done we will reschedule          */
08001B38  7C01      6027          moveq     #1,D6
                    6028   OSFlagPost_30:
                    6029   ; }
                    6030   ; }
                    6031   ; break;
08001B3A  6000 0042 6032          bra       OSFlagPost_13
                    6033   OSFlagPost_18:
                    6034   ; case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                    6035   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
08001B3E  2044      6036          move.l    D4,A0
08001B40  3028 0006 6037          move.w    6(A0),D0
08001B44  4640      6038          not.w     D0
08001B46  2042      6039          move.l    D2,A0
08001B48  C068 0010 6040          and.w     16(A0),D0
08001B4C  3600      6041          move.w    D0,D3
                    6042   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
08001B4E  4A43      6043          tst.w     D3
08001B50  671C      6044          beq.s     OSFlagPost_34
                    6045   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
08001B52  42A7      6046          clr.l     -(A7)
08001B54  C6BC 0000 6047          and.l     #65535,D3
08001B58  FFFF      
08001B5A  2F03      6048          move.l    D3,-(A7)
08001B5C  2F02      6049          move.l    D2,-(A7)
08001B5E  4E92      6050          jsr       (A2)
08001B60  DEFC 000C 6051          add.w     #12,A7
08001B64  1A00      6052          move.b    D0,D5
                    6053   ; if (rdy == OS_TRUE) {
08001B66  0C05 0001 6054          cmp.b     #1,D5
08001B6A  6602      6055          bne.s     OSFlagPost_34
                    6056   ; sched = OS_TRUE;                     /* When done we will reschedule          */
08001B6C  7C01      6057          moveq     #1,D6
                    6058   OSFlagPost_34:
                    6059   ; }
                    6060   ; }
                    6061   ; break;
08001B6E  600E      6062          bra.s     OSFlagPost_13
                    6063   OSFlagPost_12:
                    6064   ; #endif
                    6065   ; default:
                    6066   ; OS_EXIT_CRITICAL();
08001B70  46DF      6067          dc.w      18143
                    6068   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
08001B72  2047      6069          move.l    D7,A0
08001B74  10BC 006F 6070          move.b    #111,(A0)
                    6071   ; return ((OS_FLAGS)0);
08001B78  4240      6072          clr.w     D0
08001B7A  6000 0030 6073          bra       OSFlagPost_3
                    6074   OSFlagPost_13:
                    6075   ; }
                    6076   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
08001B7E  2042      6077          move.l    D2,A0
08001B80  2410      6078          move.l    (A0),D2
08001B82  6000 FEEC 6079          bra       OSFlagPost_9
                    6080   OSFlagPost_11:
                    6081   ; }
                    6082   ; OS_EXIT_CRITICAL();
08001B86  46DF      6083          dc.w      18143
                    6084   ; if (sched == OS_TRUE) {
08001B88  0C06 0001 6085          cmp.b     #1,D6
08001B8C  6606      6086          bne.s     OSFlagPost_36
                    6087   ; OS_Sched();
08001B8E  4EB9 0800 6088          jsr       _OS_Sched
08001B92  0F8A      
                    6089   OSFlagPost_36:
                    6090   ; }
                    6091   ; OS_ENTER_CRITICAL();
08001B94  40E7      6092          dc.w      16615
08001B96  007C      6093          dc.w      124
08001B98  0700      6094          dc.w      1792
                    6095   ; flags_cur = pgrp->OSFlagFlags;
08001B9A  2044      6096          move.l    D4,A0
08001B9C  3D68 0006 6097          move.w    6(A0),-2(A6)
08001BA0  FFFE      
                    6098   ; OS_EXIT_CRITICAL();
08001BA2  46DF      6099          dc.w      18143
                    6100   ; *perr     = OS_ERR_NONE;
08001BA4  2047      6101          move.l    D7,A0
08001BA6  4210      6102          clr.b     (A0)
                    6103   ; return (flags_cur);
08001BA8  302E FFFE 6104          move.w    -2(A6),D0
                    6105   OSFlagPost_3:
08001BAC  4CDF 04FC 6106          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
08001BB0  4E5E      6107          unlk      A6
08001BB2  4E75      6108          rts
                    6109   ; }
                    6110   ; /*$PAGE*/
                    6111   ; /*
                    6112   ; *********************************************************************************************************
                    6113   ; *                                          QUERY EVENT FLAG
                    6114   ; *
                    6115   ; * Description: This function is used to check the value of the event flag group.
                    6116   ; *
                    6117   ; * Arguments  : pgrp         is a pointer to the desired event flag group.
                    6118   ; *
                    6119   ; *              perr          is a pointer to an error code returned to the called:
                    6120   ; *                            OS_ERR_NONE                The call was successfull
                    6121   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6122   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6123   ; *
                    6124   ; * Returns    : The current value of the event flag group.
                    6125   ; *
                    6126   ; * Called From: Task or ISR
                    6127   ; *********************************************************************************************************
                    6128   ; */
                    6129   ; #if OS_FLAG_QUERY_EN > 0u
                    6130   ; OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
                    6131   ; INT8U        *perr)
                    6132   ; {
                    6133   _OSFlagQuery:
08001BB4  4E56 FFFC 6134          link      A6,#-4
                    6135   ; OS_FLAGS   flags;
                    6136   ; #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
                    6137   ; OS_CPU_SR  cpu_sr = 0u;
                    6138   ; #endif
                    6139   ; #ifdef OS_SAFETY_CRITICAL
                    6140   ; if (perr == (INT8U *)0) {
                    6141   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6142   ; return ((OS_FLAGS)0);
                    6143   ; }
                    6144   ; #endif
                    6145   ; #if OS_ARG_CHK_EN > 0u
                    6146   ; if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
                    6147   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6148   ; return ((OS_FLAGS)0);
                    6149   ; }
                    6150   ; #endif
                    6151   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
08001BB8  206E 0008 6152          move.l    8(A6),A0
08001BBC  1010      6153          move.b    (A0),D0
08001BBE  0C00 0005 6154          cmp.b     #5,D0
08001BC2  670C      6155          beq.s     OSFlagQuery_1
                    6156   ; *perr = OS_ERR_EVENT_TYPE;
08001BC4  206E 000C 6157          move.l    12(A6),A0
08001BC8  10BC 0001 6158          move.b    #1,(A0)
                    6159   ; return ((OS_FLAGS)0);
08001BCC  4240      6160          clr.w     D0
08001BCE  601C      6161          bra.s     OSFlagQuery_3
                    6162   OSFlagQuery_1:
                    6163   ; }
                    6164   ; OS_ENTER_CRITICAL();
08001BD0  40E7      6165          dc.w      16615
08001BD2  007C      6166          dc.w      124
08001BD4  0700      6167          dc.w      1792
                    6168   ; flags = pgrp->OSFlagFlags;
08001BD6  206E 0008 6169          move.l    8(A6),A0
08001BDA  3D68 0006 6170          move.w    6(A0),-2(A6)
08001BDE  FFFE      
                    6171   ; OS_EXIT_CRITICAL();
08001BE0  46DF      6172          dc.w      18143
                    6173   ; *perr = OS_ERR_NONE;
08001BE2  206E 000C 6174          move.l    12(A6),A0
08001BE6  4210      6175          clr.b     (A0)
                    6176   ; return (flags);                               /* Return the current value of the event flags       */
08001BE8  302E FFFE 6177          move.w    -2(A6),D0
                    6178   OSFlagQuery_3:
08001BEC  4E5E      6179          unlk      A6
08001BEE  4E75      6180          rts
                    6181   ; }
                    6182   ; #endif
                    6183   ; /*$PAGE*/
                    6184   ; /*
                    6185   ; *********************************************************************************************************
                    6186   ; *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
                    6187   ; *
                    6188   ; * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
                    6189   ; *              event flag bit(s) are set.
                    6190   ; *
                    6191   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6192   ; *
                    6193   ; *              pnode         is a pointer to a structure which contains data about the task waiting for
                    6194   ; *                            event flag bit(s) to be set.
                    6195   ; *
                    6196   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    6197   ; *                            The bits you want are specified by setting the corresponding bits in
                    6198   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    6199   ; *                            'flags' would contain 0x03.
                    6200   ; *
                    6201   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    6202   ; *                            to be set/cleared.
                    6203   ; *                            You can specify the following argument:
                    6204   ; *
                    6205   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
                    6206   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
                    6207   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
                    6208   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
                    6209   ; *
                    6210   ; *              timeout       is the desired amount of time that the task will wait for the event flag
                    6211   ; *                            bit(s) to be set.
                    6212   ; *
                    6213   ; * Returns    : none
                    6214   ; *
                    6215   ; * Called by  : OSFlagPend()  OS_FLAG.C
                    6216   ; *
                    6217   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    6218   ; *********************************************************************************************************
                    6219   ; */
                    6220   ; static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
                    6221   ; OS_FLAG_NODE *pnode,
                    6222   ; OS_FLAGS      flags,
                    6223   ; INT8U         wait_type,
                    6224   ; INT32U        timeout)
                    6225   ; {
                    6226   @ucos_ii_OS_FlagBlock:
08001BF0  4E56 0000 6227          link      A6,#0
08001BF4  48E7 3C20 6228          movem.l   D2/D3/D4/D5/A2,-(A7)
08001BF8  242E 000C 6229          move.l    12(A6),D2
08001BFC  45F9 0800 6230          lea       _OSTCBCur.L,A2
08001C00  042C      
08001C02  262E 0008 6231          move.l    8(A6),D3
                    6232   ; OS_FLAG_NODE  *pnode_next;
                    6233   ; INT8U          y;
                    6234   ; OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
08001C06  2052      6235          move.l    (A2),A0
08001C08  0028 0020 6236          or.b      #32,50(A0)
08001C0C  0032      
                    6237   ; OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
08001C0E  2052      6238          move.l    (A2),A0
08001C10  4228 0033 6239          clr.b     51(A0)
                    6240   ; OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
08001C14  2052      6241          move.l    (A2),A0
08001C16  216E 0018 6242          move.l    24(A6),46(A0)
08001C1A  002E      
                    6243   ; #if OS_TASK_DEL_EN > 0u
                    6244   ; OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
08001C1C  2052      6245          move.l    (A2),A0
08001C1E  2142 0028 6246          move.l    D2,40(A0)
                    6247   ; #endif
                    6248   ; pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
08001C22  2042      6249          move.l    D2,A0
08001C24  316E 0012 6250          move.w    18(A6),16(A0)
08001C28  0010      
                    6251   ; pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
08001C2A  2042      6252          move.l    D2,A0
08001C2C  116E 0017 6253          move.b    23(A6),18(A0)
08001C30  0012      
                    6254   ; pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
08001C32  2042      6255          move.l    D2,A0
08001C34  2152 0008 6256          move.l    (A2),8(A0)
                    6257   ; pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
08001C38  2043      6258          move.l    D3,A0
08001C3A  2242      6259          move.l    D2,A1
08001C3C  22A8 0002 6260          move.l    2(A0),(A1)
                    6261   ; pnode->OSFlagNodePrev     = (void *)0;
08001C40  2042      6262          move.l    D2,A0
08001C42  42A8 0004 6263          clr.l     4(A0)
                    6264   ; pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
08001C46  2042      6265          move.l    D2,A0
08001C48  2143 000C 6266          move.l    D3,12(A0)
                    6267   ; pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
08001C4C  2043      6268          move.l    D3,A0
08001C4E  2A28 0002 6269          move.l    2(A0),D5
                    6270   ; if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
08001C52  4A85      6271          tst.l     D5
08001C54  6706      6272          beq.s     @ucos_ii_OS_FlagBlock_1
                    6273   ; pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
08001C56  2045      6274          move.l    D5,A0
08001C58  2142 0004 6275          move.l    D2,4(A0)
                    6276   @ucos_ii_OS_FlagBlock_1:
                    6277   ; }
                    6278   ; pgrp->OSFlagWaitList = (void *)pnode;
08001C5C  2043      6279          move.l    D3,A0
08001C5E  2142 0002 6280          move.l    D2,2(A0)
                    6281   ; y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
08001C62  2052      6282          move.l    (A2),A0
08001C64  1828 0036 6283          move.b    54(A0),D4
                    6284   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
08001C68  C8BC 0000 6285          and.l     #255,D4
08001C6C  00FF      
08001C6E  41F9 0800 6286          lea       _OSRdyTbl.L,A0
08001C72  031C      
08001C74  2252      6287          move.l    (A2),A1
08001C76  1029 0037 6288          move.b    55(A1),D0
08001C7A  4600      6289          not.b     D0
08001C7C  C130 4800 6290          and.b     D0,0(A0,D4.L)
                    6291   ; if (OSRdyTbl[y] == 0x00u) {
08001C80  C8BC 0000 6292          and.l     #255,D4
08001C84  00FF      
08001C86  41F9 0800 6293          lea       _OSRdyTbl.L,A0
08001C8A  031C      
08001C8C  1030 4800 6294          move.b    0(A0,D4.L),D0
08001C90  660E      6295          bne.s     @ucos_ii_OS_FlagBlock_3
                    6296   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
08001C92  2052      6297          move.l    (A2),A0
08001C94  1028 0038 6298          move.b    56(A0),D0
08001C98  4600      6299          not.b     D0
08001C9A  C139 0800 6300          and.b     D0,_OSRdyGrp.L
08001C9E  031A      
                    6301   @ucos_ii_OS_FlagBlock_3:
08001CA0  4CDF 043C 6302          movem.l   (A7)+,D2/D3/D4/D5/A2
08001CA4  4E5E      6303          unlk      A6
08001CA6  4E75      6304          rts
                    6305   ; }
                    6306   ; }
                    6307   ; /*$PAGE*/
                    6308   ; /*
                    6309   ; *********************************************************************************************************
                    6310   ; *                                  INITIALIZE THE EVENT FLAG MODULE
                    6311   ; *
                    6312   ; * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
                    6313   ; *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
                    6314   ; *
                    6315   ; * Arguments  : none
                    6316   ; *
                    6317   ; * Returns    : none
                    6318   ; *
                    6319   ; * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
                    6320   ; *********************************************************************************************************
                    6321   ; */
                    6322   ; void  OS_FlagInit (void)
                    6323   ; {
                    6324   _OS_FlagInit:
08001CA8  4E56 FFF8 6325          link      A6,#-8
08001CAC  48E7 3020 6326          movem.l   D2/D3/A2,-(A7)
08001CB0  45F9 0800 6327          lea       _OSFlagTbl.L,A2
08001CB4  01C6      
                    6328   ; #if OS_MAX_FLAGS == 1u
                    6329   ; OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
                    6330   ; OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                    6331   ; OSFlagFreeList->OSFlagWaitList = (void *)0;
                    6332   ; OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
                    6333   ; #if OS_FLAG_NAME_EN > 0u
                    6334   ; OSFlagFreeList->OSFlagName     = (INT8U *)"?";
                    6335   ; #endif
                    6336   ; #endif
                    6337   ; #if OS_MAX_FLAGS >= 2u
                    6338   ; INT16U        ix;
                    6339   ; INT16U        ix_next;
                    6340   ; OS_FLAG_GRP  *pgrp1;
                    6341   ; OS_FLAG_GRP  *pgrp2;
                    6342   ; OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
08001CB6  4878 003C 6343          pea       60
08001CBA  2F0A      6344          move.l    A2,-(A7)
08001CBC  4EB9 0800 6345          jsr       _OS_MemClr
08001CC0  0F3E      
08001CC2  504F      6346          addq.w    #8,A7
                    6347   ; for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
08001CC4  4243      6348          clr.w     D3
                    6349   OS_FlagInit_1:
08001CC6  0C43 0004 6350          cmp.w     #4,D3
08001CCA  6400 004E 6351          bhs       OS_FlagInit_3
                    6352   ; ix_next = ix + 1u;
08001CCE  3003      6353          move.w    D3,D0
08001CD0  5240      6354          addq.w    #1,D0
08001CD2  3D40 FFFA 6355          move.w    D0,-6(A6)
                    6356   ; pgrp1 = &OSFlagTbl[ix];
08001CD6  200A      6357          move.l    A2,D0
08001CD8  C6BC 0000 6358          and.l     #65535,D3
08001CDC  FFFF      
08001CDE  2203      6359          move.l    D3,D1
08001CE0  C3FC 000C 6360          muls      #12,D1
08001CE4  D081      6361          add.l     D1,D0
08001CE6  2400      6362          move.l    D0,D2
                    6363   ; pgrp2 = &OSFlagTbl[ix_next];
08001CE8  200A      6364          move.l    A2,D0
08001CEA  322E FFFA 6365          move.w    -6(A6),D1
08001CEE  C2BC 0000 6366          and.l     #65535,D1
08001CF2  FFFF      
08001CF4  C3FC 000C 6367          muls      #12,D1
08001CF8  D081      6368          add.l     D1,D0
08001CFA  2D40 FFFC 6369          move.l    D0,-4(A6)
                    6370   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
08001CFE  2042      6371          move.l    D2,A0
08001D00  4210      6372          clr.b     (A0)
                    6373   ; pgrp1->OSFlagWaitList = (void *)pgrp2;
08001D02  2042      6374          move.l    D2,A0
08001D04  216E FFFC 6375          move.l    -4(A6),2(A0)
08001D08  0002      
                    6376   ; #if OS_FLAG_NAME_EN > 0u
                    6377   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
08001D0A  41F9 0800 6378          lea       @ucos_ii_1.L,A0
08001D0E  57FE      
08001D10  2242      6379          move.l    D2,A1
08001D12  2348 0008 6380          move.l    A0,8(A1)
08001D16  5243      6381          addq.w    #1,D3
08001D18  60AC      6382          bra       OS_FlagInit_1
                    6383   OS_FlagInit_3:
                    6384   ; #endif
                    6385   ; }
                    6386   ; pgrp1                 = &OSFlagTbl[ix];
08001D1A  200A      6387          move.l    A2,D0
08001D1C  C6BC 0000 6388          and.l     #65535,D3
08001D20  FFFF      
08001D22  2203      6389          move.l    D3,D1
08001D24  C3FC 000C 6390          muls      #12,D1
08001D28  D081      6391          add.l     D1,D0
08001D2A  2400      6392          move.l    D0,D2
                    6393   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
08001D2C  2042      6394          move.l    D2,A0
08001D2E  4210      6395          clr.b     (A0)
                    6396   ; pgrp1->OSFlagWaitList = (void *)0;
08001D30  2042      6397          move.l    D2,A0
08001D32  42A8 0002 6398          clr.l     2(A0)
                    6399   ; #if OS_FLAG_NAME_EN > 0u
                    6400   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
08001D36  41F9 0800 6401          lea       @ucos_ii_1.L,A0
08001D3A  57FE      
08001D3C  2242      6402          move.l    D2,A1
08001D3E  2348 0008 6403          move.l    A0,8(A1)
                    6404   ; #endif
                    6405   ; OSFlagFreeList        = &OSFlagTbl[0];
08001D42  23CA 0800 6406          move.l    A2,_OSFlagFreeList.L
08001D46  0202      
08001D48  4CDF 040C 6407          movem.l   (A7)+,D2/D3/A2
08001D4C  4E5E      6408          unlk      A6
08001D4E  4E75      6409          rts
                    6410   ; #endif
                    6411   ; }
                    6412   ; /*$PAGE*/
                    6413   ; /*
                    6414   ; *********************************************************************************************************
                    6415   ; *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
                    6416   ; *
                    6417   ; * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
                    6418   ; *              desired event flag bits have been set.
                    6419   ; *
                    6420   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6421   ; *                            event flag bit(s) to be set.
                    6422   ; *
                    6423   ; *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
                    6424   ; *                            ready-to-run.
                    6425   ; *
                    6426   ; *              pend_stat   is used to indicate the readied task's pending status:
                    6427   ; *
                    6428   ; *
                    6429   ; * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
                    6430   ; *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
                    6431   ; *
                    6432   ; * Called by  : OSFlagsPost() OS_FLAG.C
                    6433   ; *
                    6434   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6435   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6436   ; *********************************************************************************************************
                    6437   ; */
                    6438   ; static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
                    6439   ; OS_FLAGS      flags_rdy,
                    6440   ; INT8U         pend_stat)
                    6441   ; {
                    6442   @ucos_ii_OS_FlagTaskRdy:
08001D50  4E56 0000 6443          link      A6,#0
08001D54  48E7 3000 6444          movem.l   D2/D3,-(A7)
                    6445   ; OS_TCB   *ptcb;
                    6446   ; BOOLEAN   sched;
                    6447   ; ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
08001D58  206E 0008 6448          move.l    8(A6),A0
08001D5C  2428 0008 6449          move.l    8(A0),D2
                    6450   ; ptcb->OSTCBDly       = 0u;
08001D60  2042      6451          move.l    D2,A0
08001D62  42A8 002E 6452          clr.l     46(A0)
                    6453   ; ptcb->OSTCBFlagsRdy  = flags_rdy;
08001D66  2042      6454          move.l    D2,A0
08001D68  316E 000E 6455          move.w    14(A6),44(A0)
08001D6C  002C      
                    6456   ; ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
08001D6E  2042      6457          move.l    D2,A0
08001D70  7020      6458          moveq     #32,D0
08001D72  4600      6459          not.b     D0
08001D74  C128 0032 6460          and.b     D0,50(A0)
                    6461   ; ptcb->OSTCBStatPend  = pend_stat;
08001D78  2042      6462          move.l    D2,A0
08001D7A  116E 0013 6463          move.b    19(A6),51(A0)
08001D7E  0033      
                    6464   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
08001D80  2042      6465          move.l    D2,A0
08001D82  1028 0032 6466          move.b    50(A0),D0
08001D86  662C      6467          bne.s     @ucos_ii_OS_FlagTaskRdy_1
                    6468   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
08001D88  2042      6469          move.l    D2,A0
08001D8A  1028 0038 6470          move.b    56(A0),D0
08001D8E  8139 0800 6471          or.b      D0,_OSRdyGrp.L
08001D92  031A      
                    6472   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
08001D94  2042      6473          move.l    D2,A0
08001D96  1028 0036 6474          move.b    54(A0),D0
08001D9A  C0BC 0000 6475          and.l     #255,D0
08001D9E  00FF      
08001DA0  41F9 0800 6476          lea       _OSRdyTbl.L,A0
08001DA4  031C      
08001DA6  2242      6477          move.l    D2,A1
08001DA8  1229 0037 6478          move.b    55(A1),D1
08001DAC  8330 0800 6479          or.b      D1,0(A0,D0.L)
                    6480   ; sched                   = OS_TRUE;
08001DB0  7601      6481          moveq     #1,D3
08001DB2  6002      6482          bra.s     @ucos_ii_OS_FlagTaskRdy_2
                    6483   @ucos_ii_OS_FlagTaskRdy_1:
                    6484   ; } else {
                    6485   ; sched                   = OS_FALSE;
08001DB4  4203      6486          clr.b     D3
                    6487   @ucos_ii_OS_FlagTaskRdy_2:
                    6488   ; }
                    6489   ; OS_FlagUnlink(pnode);
08001DB6  2F2E 0008 6490          move.l    8(A6),-(A7)
08001DBA  4EB9 0800 6491          jsr       _OS_FlagUnlink
08001DBE  1DCC      
08001DC0  584F      6492          addq.w    #4,A7
                    6493   ; return (sched);
08001DC2  1003      6494          move.b    D3,D0
08001DC4  4CDF 000C 6495          movem.l   (A7)+,D2/D3
08001DC8  4E5E      6496          unlk      A6
08001DCA  4E75      6497          rts
                    6498   ; }
                    6499   ; /*$PAGE*/
                    6500   ; /*
                    6501   ; *********************************************************************************************************
                    6502   ; *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
                    6503   ; *
                    6504   ; * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
                    6505   ; *              list of tasks waiting for the event flag.
                    6506   ; *
                    6507   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6508   ; *                            event flag bit(s) to be set.
                    6509   ; *
                    6510   ; * Returns    : none
                    6511   ; *
                    6512   ; * Called by  : OS_FlagTaskRdy() OS_FLAG.C
                    6513   ; *              OSFlagPend()     OS_FLAG.C
                    6514   ; *              OSTaskDel()      OS_TASK.C
                    6515   ; *
                    6516   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6517   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6518   ; *********************************************************************************************************
                    6519   ; */
                    6520   ; void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
                    6521   ; {
                    6522   _OS_FlagUnlink:
08001DCC  4E56 FFF8 6523          link      A6,#-8
08001DD0  48E7 3800 6524          movem.l   D2/D3/D4,-(A7)
08001DD4  262E 0008 6525          move.l    8(A6),D3
                    6526   ; #if OS_TASK_DEL_EN > 0u
                    6527   ; OS_TCB       *ptcb;
                    6528   ; #endif
                    6529   ; OS_FLAG_GRP  *pgrp;
                    6530   ; OS_FLAG_NODE *pnode_prev;
                    6531   ; OS_FLAG_NODE *pnode_next;
                    6532   ; pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
08001DD8  2043      6533          move.l    D3,A0
08001DDA  2828 0004 6534          move.l    4(A0),D4
                    6535   ; pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
08001DDE  2043      6536          move.l    D3,A0
08001DE0  2410      6537          move.l    (A0),D2
                    6538   ; if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
08001DE2  4A84      6539          tst.l     D4
08001DE4  661C      6540          bne.s     OS_FlagUnlink_1
                    6541   ; pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
08001DE6  2043      6542          move.l    D3,A0
08001DE8  2D68 000C 6543          move.l    12(A0),-4(A6)
08001DEC  FFFC      
                    6544   ; pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
08001DEE  206E FFFC 6545          move.l    -4(A6),A0
08001DF2  2142 0002 6546          move.l    D2,2(A0)
                    6547   ; if (pnode_next != (OS_FLAG_NODE *)0) {
08001DF6  4A82      6548          tst.l     D2
08001DF8  6706      6549          beq.s     OS_FlagUnlink_3
                    6550   ; pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
08001DFA  2042      6551          move.l    D2,A0
08001DFC  42A8 0004 6552          clr.l     4(A0)
                    6553   OS_FlagUnlink_3:
08001E00  600E      6554          bra.s     OS_FlagUnlink_5
                    6555   OS_FlagUnlink_1:
                    6556   ; }
                    6557   ; } else {                                                    /* No,  A node somewhere in the list   */
                    6558   ; pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
08001E02  2044      6559          move.l    D4,A0
08001E04  2082      6560          move.l    D2,(A0)
                    6561   ; if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
08001E06  4A82      6562          tst.l     D2
08001E08  6706      6563          beq.s     OS_FlagUnlink_5
                    6564   ; pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
08001E0A  2042      6565          move.l    D2,A0
08001E0C  2144 0004 6566          move.l    D4,4(A0)
                    6567   OS_FlagUnlink_5:
                    6568   ; }
                    6569   ; }
                    6570   ; #if OS_TASK_DEL_EN > 0u
                    6571   ; ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
08001E10  2043      6572          move.l    D3,A0
08001E12  2D68 0008 6573          move.l    8(A0),-8(A6)
08001E16  FFF8      
                    6574   ; ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
08001E18  206E FFF8 6575          move.l    -8(A6),A0
08001E1C  42A8 0028 6576          clr.l     40(A0)
08001E20  4CDF 001C 6577          movem.l   (A7)+,D2/D3/D4
08001E24  4E5E      6578          unlk      A6
08001E26  4E75      6579          rts
                    6580   ; /*
                    6581   ; *********************************************************************************************************
                    6582   ; *                                                uC/OS-II
                    6583   ; *                                          The Real-Time Kernel
                    6584   ; *                                       MESSAGE MAILBOX MANAGEMENT
                    6585   ; *
                    6586   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    6587   ; *                                           All Rights Reserved
                    6588   ; *
                    6589   ; * File    : OS_MBOX.C
                    6590   ; * By      : Jean J. Labrosse
                    6591   ; * Version : V2.92.07
                    6592   ; *
                    6593   ; * LICENSING TERMS:
                    6594   ; * ---------------
                    6595   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    6596   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    6597   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    6598   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    6599   ; * licensing fee.
                    6600   ; *********************************************************************************************************
                    6601   ; */
                    6602   ; #define  MICRIUM_SOURCE
                    6603   ; #ifndef  OS_MASTER_FILE
                    6604   ; #include <ucos_ii.h>
                    6605   ; #endif
                    6606   ; #if OS_MBOX_EN > 0u
                    6607   ; /*
                    6608   ; *********************************************************************************************************
                    6609   ; *                                        ACCEPT MESSAGE FROM MAILBOX
                    6610   ; *
                    6611   ; * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
                    6612   ; *              OSMboxAccept() does not suspend the calling task if a message is not available.
                    6613   ; *
                    6614   ; * Arguments  : pevent        is a pointer to the event control block
                    6615   ; *
                    6616   ; * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
                    6617   ; *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
                    6618   ; *              == (void *)0  if the mailbox is empty or,
                    6619   ; *                            if 'pevent' is a NULL pointer or,
                    6620   ; *                            if you didn't pass the proper event pointer.
                    6621   ; *********************************************************************************************************
                    6622   ; */
                    6623   ; #if OS_MBOX_ACCEPT_EN > 0u
                    6624   ; void  *OSMboxAccept (OS_EVENT *pevent)
                    6625   ; {
                    6626   _OSMboxAccept:
08001E28  4E56 FFFC 6627          link      A6,#-4
08001E2C  2F02      6628          move.l    D2,-(A7)
08001E2E  242E 0008 6629          move.l    8(A6),D2
                    6630   ; void      *pmsg;
                    6631   ; #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
                    6632   ; OS_CPU_SR  cpu_sr = 0u;
                    6633   ; #endif
                    6634   ; #if OS_ARG_CHK_EN > 0u
                    6635   ; if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
                    6636   ; return ((void *)0);
                    6637   ; }
                    6638   ; #endif
                    6639   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
08001E32  2042      6640          move.l    D2,A0
08001E34  1010      6641          move.b    (A0),D0
08001E36  0C00 0001 6642          cmp.b     #1,D0
08001E3A  6704      6643          beq.s     OSMboxAccept_1
                    6644   ; return ((void *)0);
08001E3C  4280      6645          clr.l     D0
08001E3E  601A      6646          bra.s     OSMboxAccept_3
                    6647   OSMboxAccept_1:
                    6648   ; }
                    6649   ; OS_ENTER_CRITICAL();
08001E40  40E7      6650          dc.w      16615
08001E42  007C      6651          dc.w      124
08001E44  0700      6652          dc.w      1792
                    6653   ; pmsg               = pevent->OSEventPtr;
08001E46  2042      6654          move.l    D2,A0
08001E48  2D68 0002 6655          move.l    2(A0),-4(A6)
08001E4C  FFFC      
                    6656   ; pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
08001E4E  2042      6657          move.l    D2,A0
08001E50  42A8 0002 6658          clr.l     2(A0)
                    6659   ; OS_EXIT_CRITICAL();
08001E54  46DF      6660          dc.w      18143
                    6661   ; return (pmsg);                                        /* Return the message received (or NULL)     */
08001E56  202E FFFC 6662          move.l    -4(A6),D0
                    6663   OSMboxAccept_3:
08001E5A  241F      6664          move.l    (A7)+,D2
08001E5C  4E5E      6665          unlk      A6
08001E5E  4E75      6666          rts
                    6667   ; }
                    6668   ; #endif
                    6669   ; /*$PAGE*/
                    6670   ; /*
                    6671   ; *********************************************************************************************************
                    6672   ; *                                          CREATE A MESSAGE MAILBOX
                    6673   ; *
                    6674   ; * Description: This function creates a message mailbox if free event control blocks are available.
                    6675   ; *
                    6676   ; * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
                    6677   ; *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
                    6678   ; *                            will be considered empty.
                    6679   ; *
                    6680   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    6681   ; *                                created mailbox
                    6682   ; *              == (OS_EVENT *)0  if no event control blocks were available
                    6683   ; *********************************************************************************************************
                    6684   ; */
                    6685   ; OS_EVENT  *OSMboxCreate (void *pmsg)
                    6686   ; {
                    6687   _OSMboxCreate:
08001E60  4E56 0000 6688          link      A6,#0
08001E64  48E7 2020 6689          movem.l   D2/A2,-(A7)
08001E68  45F9 0800 6690          lea       _OSEventFreeList.L,A2
08001E6C  00E6      
                    6691   ; OS_EVENT  *pevent;
                    6692   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    6693   ; OS_CPU_SR  cpu_sr = 0u;
                    6694   ; #endif
                    6695   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    6696   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    6697   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6698   ; return ((OS_EVENT *)0);
                    6699   ; }
                    6700   ; #endif
                    6701   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
08001E6E  1039 0800 6702          move.b    _OSIntNesting.L,D0
08001E72  0312      
08001E74  0C00 0000 6703          cmp.b     #0,D0
08001E78  6306      6704          bls.s     OSMboxCreate_1
                    6705   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
08001E7A  4280      6706          clr.l     D0
08001E7C  6000 0046 6707          bra       OSMboxCreate_3
                    6708   OSMboxCreate_1:
                    6709   ; }
                    6710   ; OS_ENTER_CRITICAL();
08001E80  40E7      6711          dc.w      16615
08001E82  007C      6712          dc.w      124
08001E84  0700      6713          dc.w      1792
                    6714   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
08001E86  2412      6715          move.l    (A2),D2
                    6716   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
08001E88  2012      6717          move.l    (A2),D0
08001E8A  6706      6718          beq.s     OSMboxCreate_4
                    6719   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
08001E8C  2052      6720          move.l    (A2),A0
08001E8E  24A8 0002 6721          move.l    2(A0),(A2)
                    6722   OSMboxCreate_4:
                    6723   ; }
                    6724   ; OS_EXIT_CRITICAL();
08001E92  46DF      6725          dc.w      18143
                    6726   ; if (pevent != (OS_EVENT *)0) {
08001E94  4A82      6727          tst.l     D2
08001E96  672A      6728          beq.s     OSMboxCreate_6
                    6729   ; pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
08001E98  2042      6730          move.l    D2,A0
08001E9A  10BC 0001 6731          move.b    #1,(A0)
                    6732   ; pevent->OSEventCnt     = 0u;
08001E9E  2042      6733          move.l    D2,A0
08001EA0  4268 0006 6734          clr.w     6(A0)
                    6735   ; pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
08001EA4  2042      6736          move.l    D2,A0
08001EA6  216E 0008 6737          move.l    8(A6),2(A0)
08001EAA  0002      
                    6738   ; #if OS_EVENT_NAME_EN > 0u
                    6739   ; pevent->OSEventName    = (INT8U *)(void *)"?";
08001EAC  41F9 0800 6740          lea       @ucos_ii_1.L,A0
08001EB0  57FE      
08001EB2  2242      6741          move.l    D2,A1
08001EB4  2348 0012 6742          move.l    A0,18(A1)
                    6743   ; #endif
                    6744   ; OS_EventWaitListInit(pevent);
08001EB8  2F02      6745          move.l    D2,-(A7)
08001EBA  4EB9 0800 6746          jsr       _OS_EventWaitListInit
08001EBE  0C72      
08001EC0  584F      6747          addq.w    #4,A7
                    6748   OSMboxCreate_6:
                    6749   ; }
                    6750   ; return (pevent);                             /* Return pointer to event control block              */
08001EC2  2002      6751          move.l    D2,D0
                    6752   OSMboxCreate_3:
08001EC4  4CDF 0404 6753          movem.l   (A7)+,D2/A2
08001EC8  4E5E      6754          unlk      A6
08001ECA  4E75      6755          rts
                    6756   ; }
                    6757   ; /*$PAGE*/
                    6758   ; /*
                    6759   ; *********************************************************************************************************
                    6760   ; *                                           DELETE A MAIBOX
                    6761   ; *
                    6762   ; * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
                    6763   ; *
                    6764   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    6765   ; *                            mailbox.
                    6766   ; *
                    6767   ; *              opt           determines delete options as follows:
                    6768   ; *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
                    6769   ; *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
                    6770   ; *                                                    In this case, all the tasks pending will be readied.
                    6771   ; *
                    6772   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    6773   ; *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
                    6774   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
                    6775   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    6776   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
                    6777   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
                    6778   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    6779   ; *
                    6780   ; * Returns    : pevent        upon error
                    6781   ; *              (OS_EVENT *)0 if the mailbox was successfully deleted.
                    6782   ; *
                    6783   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    6784   ; *                 the mailbox MUST check the return code of OSMboxPend().
                    6785   ; *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
                    6786   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    6787   ; *                 time is directly proportional to the number of tasks waiting on the mailbox.
                    6788   ; *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
                    6789   ; *                 applications where the mailbox is used for mutual exclusion because the resource(s)
                    6790   ; *                 will no longer be guarded by the mailbox.
                    6791   ; *              5) All tasks that were waiting for the mailbox will be readied and returned an 
                    6792   ; *                 OS_ERR_PEND_ABORT if OSMboxDel() was called with OS_DEL_ALWAYS
                    6793   ; *********************************************************************************************************
                    6794   ; */
                    6795   ; #if OS_MBOX_DEL_EN > 0u
                    6796   ; OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
                    6797   ; INT8U      opt,
                    6798   ; INT8U     *perr)
                    6799   ; {
                    6800   _OSMboxDel:
08001ECC  4E56 0000 6801          link      A6,#0
08001ED0  48E7 3C20 6802          movem.l   D2/D3/D4/D5/A2,-(A7)
08001ED4  242E 0008 6803          move.l    8(A6),D2
08001ED8  262E 0010 6804          move.l    16(A6),D3
08001EDC  45F9 0800 6805          lea       _OSEventFreeList.L,A2
08001EE0  00E6      
                    6806   ; BOOLEAN    tasks_waiting;
                    6807   ; OS_EVENT  *pevent_return;
                    6808   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    6809   ; OS_CPU_SR  cpu_sr = 0u;
                    6810   ; #endif
                    6811   ; #ifdef OS_SAFETY_CRITICAL
                    6812   ; if (perr == (INT8U *)0) {
                    6813   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6814   ; return ((OS_EVENT *)0);
                    6815   ; }
                    6816   ; #endif
                    6817   ; #if OS_ARG_CHK_EN > 0u
                    6818   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    6819   ; *perr = OS_ERR_PEVENT_NULL;
                    6820   ; return (pevent);
                    6821   ; }
                    6822   ; #endif
                    6823   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
08001EE2  2042      6824          move.l    D2,A0
08001EE4  1010      6825          move.b    (A0),D0
08001EE6  0C00 0001 6826          cmp.b     #1,D0
08001EEA  670C      6827          beq.s     OSMboxDel_1
                    6828   ; *perr = OS_ERR_EVENT_TYPE;
08001EEC  2043      6829          move.l    D3,A0
08001EEE  10BC 0001 6830          move.b    #1,(A0)
                    6831   ; return (pevent);
08001EF2  2002      6832          move.l    D2,D0
08001EF4  6000 00EE 6833          bra       OSMboxDel_3
                    6834   OSMboxDel_1:
                    6835   ; }
                    6836   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
08001EF8  1039 0800 6837          move.b    _OSIntNesting.L,D0
08001EFC  0312      
08001EFE  0C00 0000 6838          cmp.b     #0,D0
08001F02  630C      6839          bls.s     OSMboxDel_4
                    6840   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
08001F04  2043      6841          move.l    D3,A0
08001F06  10BC 000F 6842          move.b    #15,(A0)
                    6843   ; return (pevent);
08001F0A  2002      6844          move.l    D2,D0
08001F0C  6000 00D6 6845          bra       OSMboxDel_3
                    6846   OSMboxDel_4:
                    6847   ; }
                    6848   ; OS_ENTER_CRITICAL();
08001F10  40E7      6849          dc.w      16615
08001F12  007C      6850          dc.w      124
08001F14  0700      6851          dc.w      1792
                    6852   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
08001F16  2042      6853          move.l    D2,A0
08001F18  1028 0008 6854          move.b    8(A0),D0
08001F1C  6704      6855          beq.s     OSMboxDel_6
                    6856   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
08001F1E  7A01      6857          moveq     #1,D5
08001F20  6002      6858          bra.s     OSMboxDel_7
                    6859   OSMboxDel_6:
                    6860   ; } else {
                    6861   ; tasks_waiting = OS_FALSE;                          /* No                                       */
08001F22  4205      6862          clr.b     D5
                    6863   OSMboxDel_7:
                    6864   ; }
                    6865   ; switch (opt) {
08001F24  102E 000F 6866          move.b    15(A6),D0
08001F28  C0BC 0000 6867          and.l     #255,D0
08001F2C  00FF      
08001F2E  0C80 0000 6868          cmp.l     #1,D0
08001F32  0001      
08001F34  6700 0048 6869          beq       OSMboxDel_11
08001F38  6200 009E 6870          bhi       OSMboxDel_8
08001F3C  4A80      6871          tst.l     D0
08001F3E  6704      6872          beq.s     OSMboxDel_10
08001F40  6000 0096 6873          bra       OSMboxDel_8
                    6874   OSMboxDel_10:
                    6875   ; case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
                    6876   ; if (tasks_waiting == OS_FALSE) {
08001F44  4A05      6877          tst.b     D5
08001F46  6628      6878          bne.s     OSMboxDel_13
                    6879   ; #if OS_EVENT_NAME_EN > 0u
                    6880   ; pevent->OSEventName = (INT8U *)(void *)"?";
08001F48  41F9 0800 6881          lea       @ucos_ii_1.L,A0
08001F4C  57FE      
08001F4E  2242      6882          move.l    D2,A1
08001F50  2348 0012 6883          move.l    A0,18(A1)
                    6884   ; #endif
                    6885   ; pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
08001F54  2042      6886          move.l    D2,A0
08001F56  4210      6887          clr.b     (A0)
                    6888   ; pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
08001F58  2042      6889          move.l    D2,A0
08001F5A  2152 0002 6890          move.l    (A2),2(A0)
                    6891   ; pevent->OSEventCnt  = 0u;
08001F5E  2042      6892          move.l    D2,A0
08001F60  4268 0006 6893          clr.w     6(A0)
                    6894   ; OSEventFreeList     = pevent;             /* Get next free event control block        */
08001F64  2482      6895          move.l    D2,(A2)
                    6896   ; OS_EXIT_CRITICAL();
08001F66  46DF      6897          dc.w      18143
                    6898   ; *perr               = OS_ERR_NONE;
08001F68  2043      6899          move.l    D3,A0
08001F6A  4210      6900          clr.b     (A0)
                    6901   ; pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
08001F6C  4284      6902          clr.l     D4
08001F6E  600A      6903          bra.s     OSMboxDel_14
                    6904   OSMboxDel_13:
                    6905   ; } else {
                    6906   ; OS_EXIT_CRITICAL();
08001F70  46DF      6907          dc.w      18143
                    6908   ; *perr               = OS_ERR_TASK_WAITING;
08001F72  2043      6909          move.l    D3,A0
08001F74  10BC 0049 6910          move.b    #73,(A0)
                    6911   ; pevent_return       = pevent;
08001F78  2802      6912          move.l    D2,D4
                    6913   OSMboxDel_14:
                    6914   ; }
                    6915   ; break;
08001F7A  6000 0066 6916          bra       OSMboxDel_9
                    6917   OSMboxDel_11:
                    6918   ; case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
                    6919   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                    6920   OSMboxDel_15:
08001F7E  2042      6921          move.l    D2,A0
08001F80  1028 0008 6922          move.b    8(A0),D0
08001F84  671E      6923          beq.s     OSMboxDel_17
                    6924   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
08001F86  4878 0002 6925          pea       2
08001F8A  4878 0002 6926          pea       2
08001F8E  42A7      6927          clr.l     -(A7)
08001F90  2F02      6928          move.l    D2,-(A7)
08001F92  4EB9 0800 6929          jsr       _OS_EventTaskRdy
08001F96  09AA      
08001F98  DEFC 0010 6930          add.w     #16,A7
08001F9C  C0BC 0000 6931          and.l     #255,D0
08001FA0  00FF      
08001FA2  60DA      6932          bra       OSMboxDel_15
                    6933   OSMboxDel_17:
                    6934   ; }
                    6935   ; #if OS_EVENT_NAME_EN > 0u
                    6936   ; pevent->OSEventName    = (INT8U *)(void *)"?";
08001FA4  41F9 0800 6937          lea       @ucos_ii_1.L,A0
08001FA8  57FE      
08001FAA  2242      6938          move.l    D2,A1
08001FAC  2348 0012 6939          move.l    A0,18(A1)
                    6940   ; #endif
                    6941   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
08001FB0  2042      6942          move.l    D2,A0
08001FB2  4210      6943          clr.b     (A0)
                    6944   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
08001FB4  2042      6945          move.l    D2,A0
08001FB6  2152 0002 6946          move.l    (A2),2(A0)
                    6947   ; pevent->OSEventCnt     = 0u;
08001FBA  2042      6948          move.l    D2,A0
08001FBC  4268 0006 6949          clr.w     6(A0)
                    6950   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
08001FC0  2482      6951          move.l    D2,(A2)
                    6952   ; OS_EXIT_CRITICAL();
08001FC2  46DF      6953          dc.w      18143
                    6954   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
08001FC4  0C05 0001 6955          cmp.b     #1,D5
08001FC8  6606      6956          bne.s     OSMboxDel_18
                    6957   ; OS_Sched();                               /* Find highest priority task ready to run  */
08001FCA  4EB9 0800 6958          jsr       _OS_Sched
08001FCE  0F8A      
                    6959   OSMboxDel_18:
                    6960   ; }
                    6961   ; *perr         = OS_ERR_NONE;
08001FD0  2043      6962          move.l    D3,A0
08001FD2  4210      6963          clr.b     (A0)
                    6964   ; pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
08001FD4  4284      6965          clr.l     D4
                    6966   ; break;
08001FD6  600A      6967          bra.s     OSMboxDel_9
                    6968   OSMboxDel_8:
                    6969   ; default:
                    6970   ; OS_EXIT_CRITICAL();
08001FD8  46DF      6971          dc.w      18143
                    6972   ; *perr         = OS_ERR_INVALID_OPT;
08001FDA  2043      6973          move.l    D3,A0
08001FDC  10BC 0007 6974          move.b    #7,(A0)
                    6975   ; pevent_return = pevent;
08001FE0  2802      6976          move.l    D2,D4
                    6977   ; break;
                    6978   OSMboxDel_9:
                    6979   ; }
                    6980   ; return (pevent_return);
08001FE2  2004      6981          move.l    D4,D0
                    6982   OSMboxDel_3:
08001FE4  4CDF 043C 6983          movem.l   (A7)+,D2/D3/D4/D5/A2
08001FE8  4E5E      6984          unlk      A6
08001FEA  4E75      6985          rts
                    6986   ; }
                    6987   ; #endif
                    6988   ; /*$PAGE*/
                    6989   ; /*
                    6990   ; *********************************************************************************************************
                    6991   ; *                                    PEND ON MAILBOX FOR A MESSAGE
                    6992   ; *
                    6993   ; * Description: This function waits for a message to be sent to a mailbox
                    6994   ; *
                    6995   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    6996   ; *
                    6997   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    6998   ; *                            wait for a message to arrive at the mailbox up to the amount of time
                    6999   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    7000   ; *                            forever at the specified mailbox or, until a message arrives.
                    7001   ; *
                    7002   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7003   ; *                            messages are:
                    7004   ; *
                    7005   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    7006   ; *                                                message.
                    7007   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    7008   ; *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
                    7009   ; *                            OS_ERR_EVENT_TYPE   Invalid event type
                    7010   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    7011   ; *                                                would lead to a suspension.
                    7012   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    7013   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    7014   ; *
                    7015   ; * Returns    : != (void *)0  is a pointer to the message received
                    7016   ; *              == (void *)0  if no message was received or,
                    7017   ; *                            if 'pevent' is a NULL pointer or,
                    7018   ; *                            if you didn't pass the proper pointer to the event control block.
                    7019   ; *********************************************************************************************************
                    7020   ; */
                    7021   ; /*$PAGE*/
                    7022   ; void  *OSMboxPend (OS_EVENT  *pevent,
                    7023   ; INT32U     timeout,
                    7024   ; INT8U     *perr)
                    7025   ; {
                    7026   _OSMboxPend:
08001FEC  4E56 0000 7027          link      A6,#0
08001FF0  48E7 3820 7028          movem.l   D2/D3/D4/A2,-(A7)
08001FF4  45F9 0800 7029          lea       _OSTCBCur.L,A2
08001FF8  042C      
08001FFA  262E 0010 7030          move.l    16(A6),D3
08001FFE  282E 0008 7031          move.l    8(A6),D4
                    7032   ; void      *pmsg;
                    7033   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7034   ; OS_CPU_SR  cpu_sr = 0u;
                    7035   ; #endif
                    7036   ; #ifdef OS_SAFETY_CRITICAL
                    7037   ; if (perr == (INT8U *)0) {
                    7038   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7039   ; return ((void *)0);
                    7040   ; }
                    7041   ; #endif
                    7042   ; #if OS_ARG_CHK_EN > 0u
                    7043   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7044   ; *perr = OS_ERR_PEVENT_NULL;
                    7045   ; return ((void *)0);
                    7046   ; }
                    7047   ; #endif
                    7048   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
08002002  2044      7049          move.l    D4,A0
08002004  1010      7050          move.b    (A0),D0
08002006  0C00 0001 7051          cmp.b     #1,D0
0800200A  670C      7052          beq.s     OSMboxPend_1
                    7053   ; *perr = OS_ERR_EVENT_TYPE;
0800200C  2043      7054          move.l    D3,A0
0800200E  10BC 0001 7055          move.b    #1,(A0)
                    7056   ; return ((void *)0);
08002012  4280      7057          clr.l     D0
08002014  6000 00F6 7058          bra       OSMboxPend_3
                    7059   OSMboxPend_1:
                    7060   ; }
                    7061   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
08002018  1039 0800 7062          move.b    _OSIntNesting.L,D0
0800201C  0312      
0800201E  0C00 0000 7063          cmp.b     #0,D0
08002022  630C      7064          bls.s     OSMboxPend_4
                    7065   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
08002024  2043      7066          move.l    D3,A0
08002026  10BC 0002 7067          move.b    #2,(A0)
                    7068   ; return ((void *)0);
0800202A  4280      7069          clr.l     D0
0800202C  6000 00DE 7070          bra       OSMboxPend_3
                    7071   OSMboxPend_4:
                    7072   ; }
                    7073   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
08002030  1039 0800 7074          move.b    _OSLockNesting.L,D0
08002034  0314      
08002036  0C00 0000 7075          cmp.b     #0,D0
0800203A  630C      7076          bls.s     OSMboxPend_6
                    7077   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
0800203C  2043      7078          move.l    D3,A0
0800203E  10BC 000D 7079          move.b    #13,(A0)
                    7080   ; return ((void *)0);
08002042  4280      7081          clr.l     D0
08002044  6000 00C6 7082          bra       OSMboxPend_3
                    7083   OSMboxPend_6:
                    7084   ; }
                    7085   ; OS_ENTER_CRITICAL();
08002048  40E7      7086          dc.w      16615
0800204A  007C      7087          dc.w      124
0800204C  0700      7088          dc.w      1792
                    7089   ; pmsg = pevent->OSEventPtr;
0800204E  2044      7090          move.l    D4,A0
08002050  2428 0002 7091          move.l    2(A0),D2
                    7092   ; if (pmsg != (void *)0) {                          /* See if there is already a message             */
08002054  4A82      7093          tst.l     D2
08002056  6712      7094          beq.s     OSMboxPend_8
                    7095   ; pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
08002058  2044      7096          move.l    D4,A0
0800205A  42A8 0002 7097          clr.l     2(A0)
                    7098   ; OS_EXIT_CRITICAL();
0800205E  46DF      7099          dc.w      18143
                    7100   ; *perr = OS_ERR_NONE;
08002060  2043      7101          move.l    D3,A0
08002062  4210      7102          clr.b     (A0)
                    7103   ; return (pmsg);                                /* Return the message received (or NULL)         */
08002064  2002      7104          move.l    D2,D0
08002066  6000 00A4 7105          bra       OSMboxPend_3
                    7106   OSMboxPend_8:
                    7107   ; }
                    7108   ; OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
0800206A  2052      7109          move.l    (A2),A0
0800206C  0028 0002 7110          or.b      #2,50(A0)
08002070  0032      
                    7111   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
08002072  2052      7112          move.l    (A2),A0
08002074  4228 0033 7113          clr.b     51(A0)
                    7114   ; OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
08002078  2052      7115          move.l    (A2),A0
0800207A  216E 000C 7116          move.l    12(A6),46(A0)
0800207E  002E      
                    7117   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
08002080  2F04      7118          move.l    D4,-(A7)
08002082  4EB9 0800 7119          jsr       _OS_EventTaskWait
08002086  0A8E      
08002088  584F      7120          addq.w    #4,A7
                    7121   ; OS_EXIT_CRITICAL();
0800208A  46DF      7122          dc.w      18143
                    7123   ; OS_Sched();                                       /* Find next highest priority task ready to run  */
0800208C  4EB9 0800 7124          jsr       _OS_Sched
08002090  0F8A      
                    7125   ; OS_ENTER_CRITICAL();
08002092  40E7      7126          dc.w      16615
08002094  007C      7127          dc.w      124
08002096  0700      7128          dc.w      1792
                    7129   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
08002098  2052      7130          move.l    (A2),A0
0800209A  1028 0033 7131          move.b    51(A0),D0
0800209E  C0BC 0000 7132          and.l     #255,D0
080020A2  00FF      
080020A4  0C80 0000 7133          cmp.l     #1,D0
080020A8  0001      
080020AA  6700 002A 7134          beq       OSMboxPend_14
080020AE  6206      7135          bhi.s     OSMboxPend_16
080020B0  4A80      7136          tst.l     D0
080020B2  670C      7137          beq.s     OSMboxPend_12
080020B4  6020      7138          bra.s     OSMboxPend_14
                    7139   OSMboxPend_16:
080020B6  0C80 0000 7140          cmp.l     #2,D0
080020BA  0002      
080020BC  670E      7141          beq.s     OSMboxPend_13
080020BE  6016      7142          bra.s     OSMboxPend_14
                    7143   OSMboxPend_12:
                    7144   ; case OS_STAT_PEND_OK:
                    7145   ; pmsg =  OSTCBCur->OSTCBMsg;
080020C0  2052      7146          move.l    (A2),A0
080020C2  2428 0024 7147          move.l    36(A0),D2
                    7148   ; *perr =  OS_ERR_NONE;
080020C6  2043      7149          move.l    D3,A0
080020C8  4210      7150          clr.b     (A0)
                    7151   ; break;
080020CA  601E      7152          bra.s     OSMboxPend_11
                    7153   OSMboxPend_13:
                    7154   ; case OS_STAT_PEND_ABORT:
                    7155   ; pmsg = (void *)0;
080020CC  4282      7156          clr.l     D2
                    7157   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
080020CE  2043      7158          move.l    D3,A0
080020D0  10BC 000E 7159          move.b    #14,(A0)
                    7160   ; break;
080020D4  6014      7161          bra.s     OSMboxPend_11
                    7162   OSMboxPend_14:
                    7163   ; case OS_STAT_PEND_TO:
                    7164   ; default:
                    7165   ; OS_EventTaskRemove(OSTCBCur, pevent);
080020D6  2F04      7166          move.l    D4,-(A7)
080020D8  2F12      7167          move.l    (A2),-(A7)
080020DA  4EB9 0800 7168          jsr       _OS_EventTaskRemove
080020DE  0BB0      
080020E0  504F      7169          addq.w    #8,A7
                    7170   ; pmsg = (void *)0;
080020E2  4282      7171          clr.l     D2
                    7172   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
080020E4  2043      7173          move.l    D3,A0
080020E6  10BC 000A 7174          move.b    #10,(A0)
                    7175   ; break;
                    7176   OSMboxPend_11:
                    7177   ; }
                    7178   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
080020EA  2052      7179          move.l    (A2),A0
080020EC  4228 0032 7180          clr.b     50(A0)
                    7181   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
080020F0  2052      7182          move.l    (A2),A0
080020F2  4228 0033 7183          clr.b     51(A0)
                    7184   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
080020F6  2052      7185          move.l    (A2),A0
080020F8  42A8 001C 7186          clr.l     28(A0)
                    7187   ; #if (OS_EVENT_MULTI_EN > 0u)
                    7188   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
080020FC  2052      7189          move.l    (A2),A0
080020FE  42A8 0020 7190          clr.l     32(A0)
                    7191   ; #endif
                    7192   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
08002102  2052      7193          move.l    (A2),A0
08002104  42A8 0024 7194          clr.l     36(A0)
                    7195   ; OS_EXIT_CRITICAL();
08002108  46DF      7196          dc.w      18143
                    7197   ; return (pmsg);                                    /* Return received message                       */
0800210A  2002      7198          move.l    D2,D0
                    7199   OSMboxPend_3:
0800210C  4CDF 041C 7200          movem.l   (A7)+,D2/D3/D4/A2
08002110  4E5E      7201          unlk      A6
08002112  4E75      7202          rts
                    7203   ; }
                    7204   ; /*$PAGE*/
                    7205   ; /*
                    7206   ; *********************************************************************************************************
                    7207   ; *                                     ABORT WAITING ON A MESSAGE MAILBOX
                    7208   ; *
                    7209   ; * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
                    7210   ; *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
                    7211   ; *              the mailbox via OSMboxPost() or OSMboxPostOpt().
                    7212   ; *
                    7213   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
                    7214   ; *
                    7215   ; *              opt           determines the type of ABORT performed:
                    7216   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    7217   ; *                                                     mailbox
                    7218   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    7219   ; *                                                     mailbox
                    7220   ; *
                    7221   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7222   ; *                            messages are:
                    7223   ; *
                    7224   ; *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
                    7225   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
                    7226   ; *                                                and informed of the aborted wait; check return value
                    7227   ; *                                                for the number of tasks whose wait on the mailbox
                    7228   ; *                                                was aborted.
                    7229   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
                    7230   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    7231   ; *
                    7232   ; * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
                    7233   ; *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
                    7234   ; *********************************************************************************************************
                    7235   ; */
                    7236   ; #if OS_MBOX_PEND_ABORT_EN > 0u
                    7237   ; INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
                    7238   ; INT8U      opt,
                    7239   ; INT8U     *perr)
                    7240   ; {
                    7241   _OSMboxPendAbort:
08002114  4E56 0000 7242          link      A6,#0
08002118  48E7 3800 7243          movem.l   D2/D3/D4,-(A7)
0800211C  242E 0008 7244          move.l    8(A6),D2
08002120  282E 0010 7245          move.l    16(A6),D4
                    7246   ; INT8U      nbr_tasks;
                    7247   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7248   ; OS_CPU_SR  cpu_sr = 0u;
                    7249   ; #endif
                    7250   ; #ifdef OS_SAFETY_CRITICAL
                    7251   ; if (perr == (INT8U *)0) {
                    7252   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7253   ; return (0u);
                    7254   ; }
                    7255   ; #endif
                    7256   ; #if OS_ARG_CHK_EN > 0u
                    7257   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7258   ; *perr = OS_ERR_PEVENT_NULL;
                    7259   ; return (0u);
                    7260   ; }
                    7261   ; #endif
                    7262   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
08002124  2042      7263          move.l    D2,A0
08002126  1010      7264          move.b    (A0),D0
08002128  0C00 0001 7265          cmp.b     #1,D0
0800212C  670C      7266          beq.s     OSMboxPendAbort_1
                    7267   ; *perr = OS_ERR_EVENT_TYPE;
0800212E  2044      7268          move.l    D4,A0
08002130  10BC 0001 7269          move.b    #1,(A0)
                    7270   ; return (0u);
08002134  4200      7271          clr.b     D0
08002136  6000 0092 7272          bra       OSMboxPendAbort_3
                    7273   OSMboxPendAbort_1:
                    7274   ; }
                    7275   ; OS_ENTER_CRITICAL();
0800213A  40E7      7276          dc.w      16615
0800213C  007C      7277          dc.w      124
0800213E  0700      7278          dc.w      1792
                    7279   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
08002140  2042      7280          move.l    D2,A0
08002142  1028 0008 7281          move.b    8(A0),D0
08002146  6700 007A 7282          beq       OSMboxPendAbort_4
                    7283   ; nbr_tasks = 0u;
0800214A  4203      7284          clr.b     D3
                    7285   ; switch (opt) {
0800214C  102E 000F 7286          move.b    15(A6),D0
08002150  C0BC 0000 7287          and.l     #255,D0
08002154  00FF      
08002156  0C80 0000 7288          cmp.l     #1,D0
0800215A  0001      
0800215C  670A      7289          beq.s     OSMboxPendAbort_8
0800215E  6200 0032 7290          bhi       OSMboxPendAbort_9
08002162  4A80      7291          tst.l     D0
08002164  672C      7292          beq.s     OSMboxPendAbort_9
08002166  602A      7293          bra.s     OSMboxPendAbort_9
                    7294   OSMboxPendAbort_8:
                    7295   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    7296   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
                    7297   OSMboxPendAbort_11:
08002168  2042      7298          move.l    D2,A0
0800216A  1028 0008 7299          move.b    8(A0),D0
0800216E  6720      7300          beq.s     OSMboxPendAbort_13
                    7301   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
08002170  4878 0002 7302          pea       2
08002174  4878 0002 7303          pea       2
08002178  42A7      7304          clr.l     -(A7)
0800217A  2F02      7305          move.l    D2,-(A7)
0800217C  4EB9 0800 7306          jsr       _OS_EventTaskRdy
08002180  09AA      
08002182  DEFC 0010 7307          add.w     #16,A7
08002186  C0BC 0000 7308          and.l     #255,D0
0800218A  00FF      
                    7309   ; nbr_tasks++;
0800218C  5203      7310          addq.b    #1,D3
0800218E  60D8      7311          bra       OSMboxPendAbort_11
                    7312   OSMboxPendAbort_13:
                    7313   ; }
                    7314   ; break;
08002190  601E      7315          bra.s     OSMboxPendAbort_7
                    7316   OSMboxPendAbort_9:
                    7317   ; case OS_PEND_OPT_NONE:
                    7318   ; default:                                       /* No,  ready HPT       waiting on mailbox  */
                    7319   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
08002192  4878 0002 7320          pea       2
08002196  4878 0002 7321          pea       2
0800219A  42A7      7322          clr.l     -(A7)
0800219C  2F02      7323          move.l    D2,-(A7)
0800219E  4EB9 0800 7324          jsr       _OS_EventTaskRdy
080021A2  09AA      
080021A4  DEFC 0010 7325          add.w     #16,A7
080021A8  C0BC 0000 7326          and.l     #255,D0
080021AC  00FF      
                    7327   ; nbr_tasks++;
080021AE  5203      7328          addq.b    #1,D3
                    7329   ; break;
                    7330   OSMboxPendAbort_7:
                    7331   ; }
                    7332   ; OS_EXIT_CRITICAL();
080021B0  46DF      7333          dc.w      18143
                    7334   ; OS_Sched();                                        /* Find HPT ready to run                    */
080021B2  4EB9 0800 7335          jsr       _OS_Sched
080021B6  0F8A      
                    7336   ; *perr = OS_ERR_PEND_ABORT;
080021B8  2044      7337          move.l    D4,A0
080021BA  10BC 000E 7338          move.b    #14,(A0)
                    7339   ; return (nbr_tasks);
080021BE  1003      7340          move.b    D3,D0
080021C0  6008      7341          bra.s     OSMboxPendAbort_3
                    7342   OSMboxPendAbort_4:
                    7343   ; }
                    7344   ; OS_EXIT_CRITICAL();
080021C2  46DF      7345          dc.w      18143
                    7346   ; *perr = OS_ERR_NONE;
080021C4  2044      7347          move.l    D4,A0
080021C6  4210      7348          clr.b     (A0)
                    7349   ; return (0u);                                           /* No tasks waiting on mailbox              */
080021C8  4200      7350          clr.b     D0
                    7351   OSMboxPendAbort_3:
080021CA  4CDF 001C 7352          movem.l   (A7)+,D2/D3/D4
080021CE  4E5E      7353          unlk      A6
080021D0  4E75      7354          rts
                    7355   ; }
                    7356   ; #endif
                    7357   ; /*$PAGE*/
                    7358   ; /*
                    7359   ; *********************************************************************************************************
                    7360   ; *                                      POST MESSAGE TO A MAILBOX
                    7361   ; *
                    7362   ; * Description: This function sends a message to a mailbox
                    7363   ; *
                    7364   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7365   ; *
                    7366   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7367   ; *
                    7368   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7369   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7370   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7371   ; *                                   are allowed to send another one.
                    7372   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7373   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7374   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7375   ; *
                    7376   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7377   ; *********************************************************************************************************
                    7378   ; */
                    7379   ; #if OS_MBOX_POST_EN > 0u
                    7380   ; INT8U  OSMboxPost (OS_EVENT  *pevent,
                    7381   ; void      *pmsg)
                    7382   ; {
                    7383   _OSMboxPost:
080021D2  4E56 0000 7384          link      A6,#0
080021D6  2F02      7385          move.l    D2,-(A7)
080021D8  242E 0008 7386          move.l    8(A6),D2
                    7387   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7388   ; OS_CPU_SR  cpu_sr = 0u;
                    7389   ; #endif
                    7390   ; #if OS_ARG_CHK_EN > 0u
                    7391   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7392   ; return (OS_ERR_PEVENT_NULL);
                    7393   ; }
                    7394   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7395   ; return (OS_ERR_POST_NULL_PTR);
                    7396   ; }
                    7397   ; #endif
                    7398   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
080021DC  2042      7399          move.l    D2,A0
080021DE  1010      7400          move.b    (A0),D0
080021E0  0C00 0001 7401          cmp.b     #1,D0
080021E4  6706      7402          beq.s     OSMboxPost_1
                    7403   ; return (OS_ERR_EVENT_TYPE);
080021E6  7001      7404          moveq     #1,D0
080021E8  6000 0052 7405          bra       OSMboxPost_3
                    7406   OSMboxPost_1:
                    7407   ; }
                    7408   ; OS_ENTER_CRITICAL();
080021EC  40E7      7409          dc.w      16615
080021EE  007C      7410          dc.w      124
080021F0  0700      7411          dc.w      1792
                    7412   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
080021F2  2042      7413          move.l    D2,A0
080021F4  1028 0008 7414          move.b    8(A0),D0
080021F8  6728      7415          beq.s     OSMboxPost_4
                    7416   ; /* Ready HPT waiting on event                    */
                    7417   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
080021FA  42A7      7418          clr.l     -(A7)
080021FC  4878 0002 7419          pea       2
08002200  2F2E 000C 7420          move.l    12(A6),-(A7)
08002204  2F02      7421          move.l    D2,-(A7)
08002206  4EB9 0800 7422          jsr       _OS_EventTaskRdy
0800220A  09AA      
0800220C  DEFC 0010 7423          add.w     #16,A7
08002210  C0BC 0000 7424          and.l     #255,D0
08002214  00FF      
                    7425   ; OS_EXIT_CRITICAL();
08002216  46DF      7426          dc.w      18143
                    7427   ; OS_Sched();                                   /* Find highest priority task ready to run       */
08002218  4EB9 0800 7428          jsr       _OS_Sched
0800221C  0F8A      
                    7429   ; return (OS_ERR_NONE);
0800221E  4200      7430          clr.b     D0
08002220  601A      7431          bra.s     OSMboxPost_3
                    7432   OSMboxPost_4:
                    7433   ; }
                    7434   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
08002222  2042      7435          move.l    D2,A0
08002224  2028 0002 7436          move.l    2(A0),D0
08002228  6706      7437          beq.s     OSMboxPost_6
                    7438   ; OS_EXIT_CRITICAL();
0800222A  46DF      7439          dc.w      18143
                    7440   ; return (OS_ERR_MBOX_FULL);
0800222C  7014      7441          moveq     #20,D0
0800222E  600C      7442          bra.s     OSMboxPost_3
                    7443   OSMboxPost_6:
                    7444   ; }
                    7445   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
08002230  2042      7446          move.l    D2,A0
08002232  216E 000C 7447          move.l    12(A6),2(A0)
08002236  0002      
                    7448   ; OS_EXIT_CRITICAL();
08002238  46DF      7449          dc.w      18143
                    7450   ; return (OS_ERR_NONE);
0800223A  4200      7451          clr.b     D0
                    7452   OSMboxPost_3:
0800223C  241F      7453          move.l    (A7)+,D2
0800223E  4E5E      7454          unlk      A6
08002240  4E75      7455          rts
                    7456   ; }
                    7457   ; #endif
                    7458   ; /*$PAGE*/
                    7459   ; /*
                    7460   ; *********************************************************************************************************
                    7461   ; *                                      POST MESSAGE TO A MAILBOX
                    7462   ; *
                    7463   ; * Description: This function sends a message to a mailbox
                    7464   ; *
                    7465   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7466   ; *
                    7467   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7468   ; *
                    7469   ; *              opt           determines the type of POST performed:
                    7470   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    7471   ; *                                                     (Identical to OSMboxPost())
                    7472   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
                    7473   ; *
                    7474   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    7475   ; *
                    7476   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7477   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7478   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7479   ; *                                   are allowed to send another one.
                    7480   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7481   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7482   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7483   ; *
                    7484   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7485   ; *
                    7486   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    7487   ; *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
                    7488   ; *********************************************************************************************************
                    7489   ; */
                    7490   ; #if OS_MBOX_POST_OPT_EN > 0u
                    7491   ; INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
                    7492   ; void      *pmsg,
                    7493   ; INT8U      opt)
                    7494   ; {
                    7495   _OSMboxPostOpt:
08002242  4E56 0000 7496          link      A6,#0
08002246  48E7 3000 7497          movem.l   D2/D3,-(A7)
0800224A  242E 0008 7498          move.l    8(A6),D2
0800224E  262E 000C 7499          move.l    12(A6),D3
                    7500   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7501   ; OS_CPU_SR  cpu_sr = 0u;
                    7502   ; #endif
                    7503   ; #if OS_ARG_CHK_EN > 0u
                    7504   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7505   ; return (OS_ERR_PEVENT_NULL);
                    7506   ; }
                    7507   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7508   ; return (OS_ERR_POST_NULL_PTR);
                    7509   ; }
                    7510   ; #endif
                    7511   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
08002252  2042      7512          move.l    D2,A0
08002254  1010      7513          move.b    (A0),D0
08002256  0C00 0001 7514          cmp.b     #1,D0
0800225A  6706      7515          beq.s     OSMboxPostOpt_1
                    7516   ; return (OS_ERR_EVENT_TYPE);
0800225C  7001      7517          moveq     #1,D0
0800225E  6000 008A 7518          bra       OSMboxPostOpt_3
                    7519   OSMboxPostOpt_1:
                    7520   ; }
                    7521   ; OS_ENTER_CRITICAL();
08002262  40E7      7522          dc.w      16615
08002264  007C      7523          dc.w      124
08002266  0700      7524          dc.w      1792
                    7525   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
08002268  2042      7526          move.l    D2,A0
0800226A  1028 0008 7527          move.b    8(A0),D0
0800226E  6700 0062 7528          beq       OSMboxPostOpt_4
                    7529   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
08002272  102E 0013 7530          move.b    19(A6),D0
08002276  C03C 0001 7531          and.b     #1,D0
0800227A  6726      7532          beq.s     OSMboxPostOpt_6
                    7533   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                    7534   OSMboxPostOpt_8:
0800227C  2042      7535          move.l    D2,A0
0800227E  1028 0008 7536          move.b    8(A0),D0
08002282  671C      7537          beq.s     OSMboxPostOpt_10
                    7538   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
08002284  42A7      7539          clr.l     -(A7)
08002286  4878 0002 7540          pea       2
0800228A  2F03      7541          move.l    D3,-(A7)
0800228C  2F02      7542          move.l    D2,-(A7)
0800228E  4EB9 0800 7543          jsr       _OS_EventTaskRdy
08002292  09AA      
08002294  DEFC 0010 7544          add.w     #16,A7
08002298  C0BC 0000 7545          and.l     #255,D0
0800229C  00FF      
0800229E  60DC      7546          bra       OSMboxPostOpt_8
                    7547   OSMboxPostOpt_10:
080022A0  601A      7548          bra.s     OSMboxPostOpt_7
                    7549   OSMboxPostOpt_6:
                    7550   ; }
                    7551   ; } else {                                      /* No,  Post to HPT waiting on mbox              */
                    7552   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
080022A2  42A7      7553          clr.l     -(A7)
080022A4  4878 0002 7554          pea       2
080022A8  2F03      7555          move.l    D3,-(A7)
080022AA  2F02      7556          move.l    D2,-(A7)
080022AC  4EB9 0800 7557          jsr       _OS_EventTaskRdy
080022B0  09AA      
080022B2  DEFC 0010 7558          add.w     #16,A7
080022B6  C0BC 0000 7559          and.l     #255,D0
080022BA  00FF      
                    7560   OSMboxPostOpt_7:
                    7561   ; }
                    7562   ; OS_EXIT_CRITICAL();
080022BC  46DF      7563          dc.w      18143
                    7564   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
080022BE  102E 0013 7565          move.b    19(A6),D0
080022C2  C03C 0004 7566          and.b     #4,D0
080022C6  6606      7567          bne.s     OSMboxPostOpt_11
                    7568   ; OS_Sched();                               /* Find HPT ready to run                         */
080022C8  4EB9 0800 7569          jsr       _OS_Sched
080022CC  0F8A      
                    7570   OSMboxPostOpt_11:
                    7571   ; }
                    7572   ; return (OS_ERR_NONE);
080022CE  4200      7573          clr.b     D0
080022D0  6018      7574          bra.s     OSMboxPostOpt_3
                    7575   OSMboxPostOpt_4:
                    7576   ; }
                    7577   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
080022D2  2042      7578          move.l    D2,A0
080022D4  2028 0002 7579          move.l    2(A0),D0
080022D8  6706      7580          beq.s     OSMboxPostOpt_13
                    7581   ; OS_EXIT_CRITICAL();
080022DA  46DF      7582          dc.w      18143
                    7583   ; return (OS_ERR_MBOX_FULL);
080022DC  7014      7584          moveq     #20,D0
080022DE  600A      7585          bra.s     OSMboxPostOpt_3
                    7586   OSMboxPostOpt_13:
                    7587   ; }
                    7588   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
080022E0  2042      7589          move.l    D2,A0
080022E2  2143 0002 7590          move.l    D3,2(A0)
                    7591   ; OS_EXIT_CRITICAL();
080022E6  46DF      7592          dc.w      18143
                    7593   ; return (OS_ERR_NONE);
080022E8  4200      7594          clr.b     D0
                    7595   OSMboxPostOpt_3:
080022EA  4CDF 000C 7596          movem.l   (A7)+,D2/D3
080022EE  4E5E      7597          unlk      A6
080022F0  4E75      7598          rts
                    7599   ; }
                    7600   ; #endif
                    7601   ; /*$PAGE*/
                    7602   ; /*
                    7603   ; *********************************************************************************************************
                    7604   ; *                                       QUERY A MESSAGE MAILBOX
                    7605   ; *
                    7606   ; * Description: This function obtains information about a message mailbox.
                    7607   ; *
                    7608   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7609   ; *
                    7610   ; *              p_mbox_data   is a pointer to a structure that will contain information about the message
                    7611   ; *                            mailbox.
                    7612   ; *
                    7613   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    7614   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
                    7615   ; *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
                    7616   ; *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
                    7617   ; *********************************************************************************************************
                    7618   ; */
                    7619   ; #if OS_MBOX_QUERY_EN > 0u
                    7620   ; INT8U  OSMboxQuery (OS_EVENT      *pevent,
                    7621   ; OS_MBOX_DATA  *p_mbox_data)
                    7622   ; {
                    7623   _OSMboxQuery:
080022F2  4E56 FFF8 7624          link      A6,#-8
080022F6  48E7 3800 7625          movem.l   D2/D3/D4,-(A7)
080022FA  242E 0008 7626          move.l    8(A6),D2
080022FE  282E 000C 7627          move.l    12(A6),D4
                    7628   ; INT8U       i;
                    7629   ; OS_PRIO    *psrc;
                    7630   ; OS_PRIO    *pdest;
                    7631   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7632   ; OS_CPU_SR   cpu_sr = 0u;
                    7633   ; #endif
                    7634   ; #if OS_ARG_CHK_EN > 0u
                    7635   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7636   ; return (OS_ERR_PEVENT_NULL);
                    7637   ; }
                    7638   ; if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
                    7639   ; return (OS_ERR_PDATA_NULL);
                    7640   ; }
                    7641   ; #endif
                    7642   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
08002302  2042      7643          move.l    D2,A0
08002304  1010      7644          move.b    (A0),D0
08002306  0C00 0001 7645          cmp.b     #1,D0
0800230A  6706      7646          beq.s     OSMboxQuery_1
                    7647   ; return (OS_ERR_EVENT_TYPE);
0800230C  7001      7648          moveq     #1,D0
0800230E  6000 004C 7649          bra       OSMboxQuery_3
                    7650   OSMboxQuery_1:
                    7651   ; }
                    7652   ; OS_ENTER_CRITICAL();
08002312  40E7      7653          dc.w      16615
08002314  007C      7654          dc.w      124
08002316  0700      7655          dc.w      1792
                    7656   ; p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
08002318  2042      7657          move.l    D2,A0
0800231A  2244      7658          move.l    D4,A1
0800231C  1368 0008 7659          move.b    8(A0),12(A1)
08002320  000C      
                    7660   ; psrc                    = &pevent->OSEventTbl[0];
08002322  700A      7661          moveq     #10,D0
08002324  D082      7662          add.l     D2,D0
08002326  2D40 FFF8 7663          move.l    D0,-8(A6)
                    7664   ; pdest                   = &p_mbox_data->OSEventTbl[0];
0800232A  7004      7665          moveq     #4,D0
0800232C  D084      7666          add.l     D4,D0
0800232E  2D40 FFFC 7667          move.l    D0,-4(A6)
                    7668   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
08002332  4203      7669          clr.b     D3
                    7670   OSMboxQuery_4:
08002334  0C03 0008 7671          cmp.b     #8,D3
08002338  6416      7672          bhs.s     OSMboxQuery_6
                    7673   ; *pdest++ = *psrc++;
0800233A  206E FFF8 7674          move.l    -8(A6),A0
0800233E  52AE FFF8 7675          addq.l    #1,-8(A6)
08002342  226E FFFC 7676          move.l    -4(A6),A1
08002346  52AE FFFC 7677          addq.l    #1,-4(A6)
0800234A  1290      7678          move.b    (A0),(A1)
0800234C  5203      7679          addq.b    #1,D3
0800234E  60E4      7680          bra       OSMboxQuery_4
                    7681   OSMboxQuery_6:
                    7682   ; }
                    7683   ; p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
08002350  2042      7684          move.l    D2,A0
08002352  2244      7685          move.l    D4,A1
08002354  22A8 0002 7686          move.l    2(A0),(A1)
                    7687   ; OS_EXIT_CRITICAL();
08002358  46DF      7688          dc.w      18143
                    7689   ; return (OS_ERR_NONE);
0800235A  4200      7690          clr.b     D0
                    7691   OSMboxQuery_3:
0800235C  4CDF 001C 7692          movem.l   (A7)+,D2/D3/D4
08002360  4E5E      7693          unlk      A6
08002362  4E75      7694          rts
                    7695   ; /*
                    7696   ; *********************************************************************************************************
                    7697   ; *                                                uC/OS-II
                    7698   ; *                                          The Real-Time Kernel
                    7699   ; *                                            MEMORY MANAGEMENT
                    7700   ; *
                    7701   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    7702   ; *                                           All Rights Reserved
                    7703   ; *
                    7704   ; * File    : OS_MEM.C
                    7705   ; * By      : Jean J. Labrosse
                    7706   ; * Version : V2.92.07
                    7707   ; *
                    7708   ; * LICENSING TERMS:
                    7709   ; * ---------------
                    7710   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    7711   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    7712   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    7713   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    7714   ; * licensing fee.
                    7715   ; *********************************************************************************************************
                    7716   ; */
                    7717   ; #define  MICRIUM_SOURCE
                    7718   ; #ifndef  OS_MASTER_FILE
                    7719   ; #include <ucos_ii.h>
                    7720   ; #endif
                    7721   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    7722   ; /*
                    7723   ; *********************************************************************************************************
                    7724   ; *                                      CREATE A MEMORY PARTITION
                    7725   ; *
                    7726   ; * Description : Create a fixed-sized memory partition that will be managed by uC/OS-II.
                    7727   ; *
                    7728   ; * Arguments   : addr     is the starting address of the memory partition
                    7729   ; *
                    7730   ; *               nblks    is the number of memory blocks to create from the partition.
                    7731   ; *
                    7732   ; *               blksize  is the size (in bytes) of each block in the memory partition.
                    7733   ; *
                    7734   ; *               perr     is a pointer to a variable containing an error message which will be set by
                    7735   ; *                        this function to either:
                    7736   ; *
                    7737   ; *                        OS_ERR_NONE              if the memory partition has been created correctly.
                    7738   ; *                        OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory
                    7739   ; *                                                 storage of the partition or, the block does not align
                    7740   ; *                                                 on a pointer boundary
                    7741   ; *                        OS_ERR_MEM_INVALID_PART  no free partitions available
                    7742   ; *                        OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be >= 2)
                    7743   ; *                        OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size
                    7744   ; *                                                   - must be greater than the size of a pointer
                    7745   ; *                                                   - must be able to hold an integral number of pointers
                    7746   ; * Returns    : != (OS_MEM *)0  is the partition was created
                    7747   ; *              == (OS_MEM *)0  if the partition was not created because of invalid arguments or, no
                    7748   ; *                              free partition is available.
                    7749   ; *********************************************************************************************************
                    7750   ; */
                    7751   ; OS_MEM  *OSMemCreate (void   *addr,
                    7752   ; INT32U  nblks,
                    7753   ; INT32U  blksize,
                    7754   ; INT8U  *perr)
                    7755   ; {
                    7756   _OSMemCreate:
08002364  4E56 FFFC 7757          link      A6,#-4
08002368  48E7 3F20 7758          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
0800236C  282E 0008 7759          move.l    8(A6),D4
08002370  45F9 0800 7760          lea       _OSMemFreeList.L,A2
08002374  0CA0      
08002376  2E2E 000C 7761          move.l    12(A6),D7
                    7762   ; OS_MEM    *pmem;
                    7763   ; INT8U     *pblk;
                    7764   ; void     **plink;
                    7765   ; INT32U     loops;
                    7766   ; INT32U     i;
                    7767   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7768   ; OS_CPU_SR  cpu_sr = 0u;
                    7769   ; #endif
                    7770   ; #ifdef OS_SAFETY_CRITICAL
                    7771   ; if (perr == (INT8U *)0) {
                    7772   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7773   ; return ((OS_MEM *)0);
                    7774   ; }
                    7775   ; #endif
                    7776   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    7777   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    7778   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7779   ; return ((OS_MEM *)0);
                    7780   ; }
                    7781   ; #endif
                    7782   ; #if OS_ARG_CHK_EN > 0u
                    7783   ; if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
                    7784   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    7785   ; return ((OS_MEM *)0);
                    7786   ; }
                    7787   ; if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
                    7788   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    7789   ; return ((OS_MEM *)0);
                    7790   ; }
                    7791   ; if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
                    7792   ; *perr = OS_ERR_MEM_INVALID_BLKS;
                    7793   ; return ((OS_MEM *)0);
                    7794   ; }
                    7795   ; if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
                    7796   ; *perr = OS_ERR_MEM_INVALID_SIZE;
                    7797   ; return ((OS_MEM *)0);
                    7798   ; }
                    7799   ; #endif
                    7800   ; OS_ENTER_CRITICAL();
0800237A  40E7      7801          dc.w      16615
0800237C  007C      7802          dc.w      124
0800237E  0700      7803          dc.w      1792
                    7804   ; pmem = OSMemFreeList;                             /* Get next free memory partition                */
08002380  2412      7805          move.l    (A2),D2
                    7806   ; if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
08002382  2012      7807          move.l    (A2),D0
08002384  6706      7808          beq.s     OSMemCreate_1
                    7809   ; OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
08002386  2052      7810          move.l    (A2),A0
08002388  24A8 0004 7811          move.l    4(A0),(A2)
                    7812   OSMemCreate_1:
                    7813   ; }
                    7814   ; OS_EXIT_CRITICAL();
0800238C  46DF      7815          dc.w      18143
                    7816   ; if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
0800238E  4A82      7817          tst.l     D2
08002390  660E      7818          bne.s     OSMemCreate_3
                    7819   ; *perr = OS_ERR_MEM_INVALID_PART;
08002392  206E 0014 7820          move.l    20(A6),A0
08002396  10BC 005A 7821          move.b    #90,(A0)
                    7822   ; return ((OS_MEM *)0);
0800239A  4280      7823          clr.l     D0
0800239C  6000 0050 7824          bra       OSMemCreate_5
                    7825   OSMemCreate_3:
                    7826   ; }
                    7827   ; plink = (void **)addr;                            /* Create linked list of free memory blocks      */
080023A0  2A04      7828          move.l    D4,D5
                    7829   ; pblk  = (INT8U *)addr;
080023A2  2604      7830          move.l    D4,D3
                    7831   ; loops  = nblks - 1u;
080023A4  2007      7832          move.l    D7,D0
080023A6  5380      7833          subq.l    #1,D0
080023A8  2D40 FFFC 7834          move.l    D0,-4(A6)
                    7835   ; for (i = 0u; i < loops; i++) {
080023AC  4286      7836          clr.l     D6
                    7837   OSMemCreate_6:
080023AE  BCAE FFFC 7838          cmp.l     -4(A6),D6
080023B2  6410      7839          bhs.s     OSMemCreate_8
                    7840   ; pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
080023B4  202E 0010 7841          move.l    16(A6),D0
080023B8  D680      7842          add.l     D0,D3
                    7843   ; *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
080023BA  2045      7844          move.l    D5,A0
080023BC  2083      7845          move.l    D3,(A0)
                    7846   ; plink = (void **)pblk;                        /* Position to  NEXT      block                  */
080023BE  2A03      7847          move.l    D3,D5
080023C0  5286      7848          addq.l    #1,D6
080023C2  60EA      7849          bra       OSMemCreate_6
                    7850   OSMemCreate_8:
                    7851   ; }
                    7852   ; *plink              = (void *)0;                  /* Last memory block points to NULL              */
080023C4  2045      7853          move.l    D5,A0
080023C6  4290      7854          clr.l     (A0)
                    7855   ; pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
080023C8  2042      7856          move.l    D2,A0
080023CA  2084      7857          move.l    D4,(A0)
                    7858   ; pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
080023CC  2042      7859          move.l    D2,A0
080023CE  2144 0004 7860          move.l    D4,4(A0)
                    7861   ; pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
080023D2  2042      7862          move.l    D2,A0
080023D4  2147 0010 7863          move.l    D7,16(A0)
                    7864   ; pmem->OSMemNBlks    = nblks;
080023D8  2042      7865          move.l    D2,A0
080023DA  2147 000C 7866          move.l    D7,12(A0)
                    7867   ; pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
080023DE  2042      7868          move.l    D2,A0
080023E0  216E 0010 7869          move.l    16(A6),8(A0)
080023E4  0008      
                    7870   ; *perr               = OS_ERR_NONE;
080023E6  206E 0014 7871          move.l    20(A6),A0
080023EA  4210      7872          clr.b     (A0)
                    7873   ; return (pmem);
080023EC  2002      7874          move.l    D2,D0
                    7875   OSMemCreate_5:
080023EE  4CDF 04FC 7876          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
080023F2  4E5E      7877          unlk      A6
080023F4  4E75      7878          rts
                    7879   ; }
                    7880   ; /*$PAGE*/
                    7881   ; /*
                    7882   ; *********************************************************************************************************
                    7883   ; *                                         GET A MEMORY BLOCK
                    7884   ; *
                    7885   ; * Description : Get a memory block from a partition
                    7886   ; *
                    7887   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    7888   ; *
                    7889   ; *               perr    is a pointer to a variable containing an error message which will be set by this
                    7890   ; *                       function to either:
                    7891   ; *
                    7892   ; *                       OS_ERR_NONE             if the memory partition has been created correctly.
                    7893   ; *                       OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller
                    7894   ; *                       OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'
                    7895   ; *
                    7896   ; * Returns     : A pointer to a memory block if no error is detected
                    7897   ; *               A pointer to NULL if an error is detected
                    7898   ; *********************************************************************************************************
                    7899   ; */
                    7900   ; void  *OSMemGet (OS_MEM  *pmem,
                    7901   ; INT8U   *perr)
                    7902   ; {
                    7903   _OSMemGet:
080023F6  4E56 0000 7904          link      A6,#0
080023FA  48E7 3000 7905          movem.l   D2/D3,-(A7)
080023FE  242E 0008 7906          move.l    8(A6),D2
                    7907   ; void      *pblk;
                    7908   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7909   ; OS_CPU_SR  cpu_sr = 0u;
                    7910   ; #endif
                    7911   ; #ifdef OS_SAFETY_CRITICAL
                    7912   ; if (perr == (INT8U *)0) {
                    7913   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7914   ; return ((void *)0);
                    7915   ; }
                    7916   ; #endif
                    7917   ; #if OS_ARG_CHK_EN > 0u
                    7918   ; if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
                    7919   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    7920   ; return ((void *)0);
                    7921   ; }
                    7922   ; #endif
                    7923   ; OS_ENTER_CRITICAL();
08002402  40E7      7924          dc.w      16615
08002404  007C      7925          dc.w      124
08002406  0700      7926          dc.w      1792
                    7927   ; if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
08002408  2042      7928          move.l    D2,A0
0800240A  2028 0010 7929          move.l    16(A0),D0
0800240E  0C80 0000 7930          cmp.l     #0,D0
08002412  0000      
08002414  6326      7931          bls.s     OSMemGet_1
                    7932   ; pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
08002416  2042      7933          move.l    D2,A0
08002418  2628 0004 7934          move.l    4(A0),D3
                    7935   ; pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
0800241C  2043      7936          move.l    D3,A0
0800241E  2242      7937          move.l    D2,A1
08002420  2350 0004 7938          move.l    (A0),4(A1)
                    7939   ; pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
08002424  2002      7940          move.l    D2,D0
08002426  0680 0000 7941          add.l     #16,D0
0800242A  0010      
0800242C  2040      7942          move.l    D0,A0
0800242E  5390      7943          subq.l    #1,(A0)
                    7944   ; OS_EXIT_CRITICAL();
08002430  46DF      7945          dc.w      18143
                    7946   ; *perr = OS_ERR_NONE;                          /*      No error                                 */
08002432  206E 000C 7947          move.l    12(A6),A0
08002436  4210      7948          clr.b     (A0)
                    7949   ; return (pblk);                                /*      Return memory block to caller            */
08002438  2003      7950          move.l    D3,D0
0800243A  600C      7951          bra.s     OSMemGet_3
                    7952   OSMemGet_1:
                    7953   ; }
                    7954   ; OS_EXIT_CRITICAL();
0800243C  46DF      7955          dc.w      18143
                    7956   ; *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
0800243E  206E 000C 7957          move.l    12(A6),A0
08002442  10BC 005D 7958          move.b    #93,(A0)
                    7959   ; return ((void *)0);                               /*      Return NULL pointer to caller            */
08002446  4280      7960          clr.l     D0
                    7961   OSMemGet_3:
08002448  4CDF 000C 7962          movem.l   (A7)+,D2/D3
0800244C  4E5E      7963          unlk      A6
0800244E  4E75      7964          rts
                    7965   ; }
                    7966   ; /*$PAGE*/
                    7967   ; /*
                    7968   ; *********************************************************************************************************
                    7969   ; *                                 GET THE NAME OF A MEMORY PARTITION
                    7970   ; *
                    7971   ; * Description: This function is used to obtain the name assigned to a memory partition.
                    7972   ; *
                    7973   ; * Arguments  : pmem      is a pointer to the memory partition
                    7974   ; *
                    7975   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the memory partition.
                    7976   ; *
                    7977   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    7978   ; *
                    7979   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    7980   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    7981   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    7982   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    7983   ; *
                    7984   ; * Returns    : The length of the string or 0 if 'pmem' is a NULL pointer.
                    7985   ; *********************************************************************************************************
                    7986   ; */
                    7987   ; #if OS_MEM_NAME_EN > 0u
                    7988   ; INT8U  OSMemNameGet (OS_MEM   *pmem,
                    7989   ; INT8U   **pname,
                    7990   ; INT8U    *perr)
                    7991   ; {
                    7992   _OSMemNameGet:
08002450  4E56 FFFC 7993          link      A6,#-4
                    7994   ; INT8U      len;
                    7995   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    7996   ; OS_CPU_SR  cpu_sr = 0u;
                    7997   ; #endif
                    7998   ; #ifdef OS_SAFETY_CRITICAL
                    7999   ; if (perr == (INT8U *)0) {
                    8000   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8001   ; return (0u);
                    8002   ; }
                    8003   ; #endif
                    8004   ; #if OS_ARG_CHK_EN > 0u
                    8005   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8006   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8007   ; return (0u);
                    8008   ; }
                    8009   ; if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
                    8010   ; *perr = OS_ERR_PNAME_NULL;
                    8011   ; return (0u);
                    8012   ; }
                    8013   ; #endif
                    8014   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
08002454  1039 0800 8015          move.b    _OSIntNesting.L,D0
08002458  0312      
0800245A  0C00 0000 8016          cmp.b     #0,D0
0800245E  630C      8017          bls.s     OSMemNameGet_1
                    8018   ; *perr = OS_ERR_NAME_GET_ISR;
08002460  206E 0010 8019          move.l    16(A6),A0
08002464  10BC 0011 8020          move.b    #17,(A0)
                    8021   ; return (0u);
08002468  4200      8022          clr.b     D0
0800246A  6030      8023          bra.s     OSMemNameGet_3
                    8024   OSMemNameGet_1:
                    8025   ; }
                    8026   ; OS_ENTER_CRITICAL();
0800246C  40E7      8027          dc.w      16615
0800246E  007C      8028          dc.w      124
08002470  0700      8029          dc.w      1792
                    8030   ; *pname = pmem->OSMemName;
08002472  206E 0008 8031          move.l    8(A6),A0
08002476  226E 000C 8032          move.l    12(A6),A1
0800247A  22A8 0014 8033          move.l    20(A0),(A1)
                    8034   ; len    = OS_StrLen(*pname);
0800247E  206E 000C 8035          move.l    12(A6),A0
08002482  2F10      8036          move.l    (A0),-(A7)
08002484  4EB9 0800 8037          jsr       _OS_StrLen
08002488  1034      
0800248A  584F      8038          addq.w    #4,A7
0800248C  1D40 FFFF 8039          move.b    D0,-1(A6)
                    8040   ; OS_EXIT_CRITICAL();
08002490  46DF      8041          dc.w      18143
                    8042   ; *perr  = OS_ERR_NONE;
08002492  206E 0010 8043          move.l    16(A6),A0
08002496  4210      8044          clr.b     (A0)
                    8045   ; return (len);
08002498  102E FFFF 8046          move.b    -1(A6),D0
                    8047   OSMemNameGet_3:
0800249C  4E5E      8048          unlk      A6
0800249E  4E75      8049          rts
                    8050   ; }
                    8051   ; #endif
                    8052   ; /*$PAGE*/
                    8053   ; /*
                    8054   ; *********************************************************************************************************
                    8055   ; *                                 ASSIGN A NAME TO A MEMORY PARTITION
                    8056   ; *
                    8057   ; * Description: This function assigns a name to a memory partition.
                    8058   ; *
                    8059   ; * Arguments  : pmem      is a pointer to the memory partition
                    8060   ; *
                    8061   ; *              pname     is a pointer to an ASCII string that contains the name of the memory partition.
                    8062   ; *
                    8063   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8064   ; *
                    8065   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8066   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8067   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8068   ; *                        OS_ERR_MEM_NAME_TOO_LONG   if the name doesn't fit in the storage area
                    8069   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    8070   ; *
                    8071   ; * Returns    : None
                    8072   ; *********************************************************************************************************
                    8073   ; */
                    8074   ; #if OS_MEM_NAME_EN > 0u
                    8075   ; void  OSMemNameSet (OS_MEM  *pmem,
                    8076   ; INT8U   *pname,
                    8077   ; INT8U   *perr)
                    8078   ; {
                    8079   _OSMemNameSet:
080024A0  4E56 0000 8080          link      A6,#0
                    8081   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8082   ; OS_CPU_SR  cpu_sr = 0u;
                    8083   ; #endif
                    8084   ; #ifdef OS_SAFETY_CRITICAL
                    8085   ; if (perr == (INT8U *)0) {
                    8086   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8087   ; return;
                    8088   ; }
                    8089   ; #endif
                    8090   ; #if OS_ARG_CHK_EN > 0u
                    8091   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8092   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8093   ; return;
                    8094   ; }
                    8095   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    8096   ; *perr = OS_ERR_PNAME_NULL;
                    8097   ; return;
                    8098   ; }
                    8099   ; #endif
                    8100   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
080024A4  1039 0800 8101          move.b    _OSIntNesting.L,D0
080024A8  0312      
080024AA  0C00 0000 8102          cmp.b     #0,D0
080024AE  630A      8103          bls.s     OSMemNameSet_1
                    8104   ; *perr = OS_ERR_NAME_SET_ISR;
080024B0  206E 0010 8105          move.l    16(A6),A0
080024B4  10BC 0012 8106          move.b    #18,(A0)
                    8107   ; return;
080024B8  6018      8108          bra.s     OSMemNameSet_3
                    8109   OSMemNameSet_1:
                    8110   ; }
                    8111   ; OS_ENTER_CRITICAL();
080024BA  40E7      8112          dc.w      16615
080024BC  007C      8113          dc.w      124
080024BE  0700      8114          dc.w      1792
                    8115   ; pmem->OSMemName = pname;
080024C0  206E 0008 8116          move.l    8(A6),A0
080024C4  216E 000C 8117          move.l    12(A6),20(A0)
080024C8  0014      
                    8118   ; OS_EXIT_CRITICAL();
080024CA  46DF      8119          dc.w      18143
                    8120   ; *perr           = OS_ERR_NONE;
080024CC  206E 0010 8121          move.l    16(A6),A0
080024D0  4210      8122          clr.b     (A0)
                    8123   OSMemNameSet_3:
080024D2  4E5E      8124          unlk      A6
080024D4  4E75      8125          rts
                    8126   ; }
                    8127   ; #endif
                    8128   ; /*$PAGE*/
                    8129   ; /*
                    8130   ; *********************************************************************************************************
                    8131   ; *                                       RELEASE A MEMORY BLOCK
                    8132   ; *
                    8133   ; * Description : Returns a memory block to a partition
                    8134   ; *
                    8135   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8136   ; *
                    8137   ; *               pblk    is a pointer to the memory block being released.
                    8138   ; *
                    8139   ; * Returns     : OS_ERR_NONE              if the memory block was inserted into the partition
                    8140   ; *               OS_ERR_MEM_FULL          if you are returning a memory block to an already FULL memory
                    8141   ; *                                        partition (You freed more blocks than you allocated!)
                    8142   ; *               OS_ERR_MEM_INVALID_PMEM  if you passed a NULL pointer for 'pmem'
                    8143   ; *               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
                    8144   ; *********************************************************************************************************
                    8145   ; */
                    8146   ; INT8U  OSMemPut (OS_MEM  *pmem,
                    8147   ; void    *pblk)
                    8148   ; {
                    8149   _OSMemPut:
080024D6  4E56 0000 8150          link      A6,#0
080024DA  2F02      8151          move.l    D2,-(A7)
080024DC  242E 0008 8152          move.l    8(A6),D2
                    8153   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8154   ; OS_CPU_SR  cpu_sr = 0u;
                    8155   ; #endif
                    8156   ; #if OS_ARG_CHK_EN > 0u
                    8157   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8158   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8159   ; }
                    8160   ; if (pblk == (void *)0) {                     /* Must release a valid block                         */
                    8161   ; return (OS_ERR_MEM_INVALID_PBLK);
                    8162   ; }
                    8163   ; #endif
                    8164   ; OS_ENTER_CRITICAL();
080024E0  40E7      8165          dc.w      16615
080024E2  007C      8166          dc.w      124
080024E4  0700      8167          dc.w      1792
                    8168   ; if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
080024E6  2042      8169          move.l    D2,A0
080024E8  2242      8170          move.l    D2,A1
080024EA  2028 0010 8171          move.l    16(A0),D0
080024EE  B0A9 000C 8172          cmp.l     12(A1),D0
080024F2  6506      8173          blo.s     OSMemPut_1
                    8174   ; OS_EXIT_CRITICAL();
080024F4  46DF      8175          dc.w      18143
                    8176   ; return (OS_ERR_MEM_FULL);
080024F6  705E      8177          moveq     #94,D0
080024F8  6024      8178          bra.s     OSMemPut_3
                    8179   OSMemPut_1:
                    8180   ; }
                    8181   ; *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
080024FA  2042      8182          move.l    D2,A0
080024FC  202E 000C 8183          move.l    12(A6),D0
08002500  2240      8184          move.l    D0,A1
08002502  22A8 0004 8185          move.l    4(A0),(A1)
                    8186   ; pmem->OSMemFreeList = pblk;
08002506  2042      8187          move.l    D2,A0
08002508  216E 000C 8188          move.l    12(A6),4(A0)
0800250C  0004      
                    8189   ; pmem->OSMemNFree++;                          /* One more memory block in this partition            */
0800250E  2002      8190          move.l    D2,D0
08002510  0680 0000 8191          add.l     #16,D0
08002514  0010      
08002516  2040      8192          move.l    D0,A0
08002518  5290      8193          addq.l    #1,(A0)
                    8194   ; OS_EXIT_CRITICAL();
0800251A  46DF      8195          dc.w      18143
                    8196   ; return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
0800251C  4200      8197          clr.b     D0
                    8198   OSMemPut_3:
0800251E  241F      8199          move.l    (A7)+,D2
08002520  4E5E      8200          unlk      A6
08002522  4E75      8201          rts
                    8202   ; }
                    8203   ; /*$PAGE*/
                    8204   ; /*
                    8205   ; *********************************************************************************************************
                    8206   ; *                                       QUERY MEMORY PARTITION
                    8207   ; *
                    8208   ; * Description : This function is used to determine the number of free memory blocks and the number of
                    8209   ; *               used memory blocks from a memory partition.
                    8210   ; *
                    8211   ; * Arguments   : pmem        is a pointer to the memory partition control block
                    8212   ; *
                    8213   ; *               p_mem_data  is a pointer to a structure that will contain information about the memory
                    8214   ; *                           partition.
                    8215   ; *
                    8216   ; * Returns     : OS_ERR_NONE               if no errors were found.
                    8217   ; *               OS_ERR_MEM_INVALID_PMEM   if you passed a NULL pointer for 'pmem'
                    8218   ; *               OS_ERR_MEM_INVALID_PDATA  if you passed a NULL pointer to the data recipient.
                    8219   ; *********************************************************************************************************
                    8220   ; */
                    8221   ; #if OS_MEM_QUERY_EN > 0u
                    8222   ; INT8U  OSMemQuery (OS_MEM       *pmem,
                    8223   ; OS_MEM_DATA  *p_mem_data)
                    8224   ; {
                    8225   _OSMemQuery:
08002524  4E56 0000 8226          link      A6,#0
08002528  48E7 3000 8227          movem.l   D2/D3,-(A7)
0800252C  242E 000C 8228          move.l    12(A6),D2
08002530  262E 0008 8229          move.l    8(A6),D3
                    8230   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8231   ; OS_CPU_SR  cpu_sr = 0u;
                    8232   ; #endif
                    8233   ; #if OS_ARG_CHK_EN > 0u
                    8234   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8235   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8236   ; }
                    8237   ; if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
                    8238   ; return (OS_ERR_MEM_INVALID_PDATA);
                    8239   ; }
                    8240   ; #endif
                    8241   ; OS_ENTER_CRITICAL();
08002534  40E7      8242          dc.w      16615
08002536  007C      8243          dc.w      124
08002538  0700      8244          dc.w      1792
                    8245   ; p_mem_data->OSAddr     = pmem->OSMemAddr;
0800253A  2043      8246          move.l    D3,A0
0800253C  2242      8247          move.l    D2,A1
0800253E  2290      8248          move.l    (A0),(A1)
                    8249   ; p_mem_data->OSFreeList = pmem->OSMemFreeList;
08002540  2043      8250          move.l    D3,A0
08002542  2242      8251          move.l    D2,A1
08002544  2368 0004 8252          move.l    4(A0),4(A1)
08002548  0004      
                    8253   ; p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
0800254A  2043      8254          move.l    D3,A0
0800254C  2242      8255          move.l    D2,A1
0800254E  2368 0008 8256          move.l    8(A0),8(A1)
08002552  0008      
                    8257   ; p_mem_data->OSNBlks    = pmem->OSMemNBlks;
08002554  2043      8258          move.l    D3,A0
08002556  2242      8259          move.l    D2,A1
08002558  2368 000C 8260          move.l    12(A0),12(A1)
0800255C  000C      
                    8261   ; p_mem_data->OSNFree    = pmem->OSMemNFree;
0800255E  2043      8262          move.l    D3,A0
08002560  2242      8263          move.l    D2,A1
08002562  2368 0010 8264          move.l    16(A0),16(A1)
08002566  0010      
                    8265   ; OS_EXIT_CRITICAL();
08002568  46DF      8266          dc.w      18143
                    8267   ; p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
0800256A  2042      8268          move.l    D2,A0
0800256C  2028 000C 8269          move.l    12(A0),D0
08002570  2042      8270          move.l    D2,A0
08002572  90A8 0010 8271          sub.l     16(A0),D0
08002576  2042      8272          move.l    D2,A0
08002578  2140 0014 8273          move.l    D0,20(A0)
                    8274   ; return (OS_ERR_NONE);
0800257C  4200      8275          clr.b     D0
0800257E  4CDF 000C 8276          movem.l   (A7)+,D2/D3
08002582  4E5E      8277          unlk      A6
08002584  4E75      8278          rts
                    8279   ; }
                    8280   ; #endif                                           /* OS_MEM_QUERY_EN                                    */
                    8281   ; /*$PAGE*/
                    8282   ; /*
                    8283   ; *********************************************************************************************************
                    8284   ; *                                 INITIALIZE MEMORY PARTITION MANAGER
                    8285   ; *
                    8286   ; * Description : This function is called by uC/OS-II to initialize the memory partition manager.  Your
                    8287   ; *               application MUST NOT call this function.
                    8288   ; *
                    8289   ; * Arguments   : none
                    8290   ; *
                    8291   ; * Returns     : none
                    8292   ; *
                    8293   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    8294   ; *********************************************************************************************************
                    8295   ; */
                    8296   ; void  OS_MemInit (void)
                    8297   ; {
                    8298   _OS_MemInit:
08002586  48E7 3020 8299          movem.l   D2/D3/A2,-(A7)
0800258A  45F9 0800 8300          lea       _OSMemTbl.L,A2
0800258E  0CA4      
                    8301   ; #if OS_MAX_MEM_PART == 1u
                    8302   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
                    8303   ; OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
                    8304   ; #if OS_MEM_NAME_EN > 0u
                    8305   ; OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
                    8306   ; #endif
                    8307   ; #endif
                    8308   ; #if OS_MAX_MEM_PART >= 2u
                    8309   ; OS_MEM  *pmem;
                    8310   ; INT16U   i;
                    8311   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
08002590  4878 0078 8312          pea       120
08002594  2F0A      8313          move.l    A2,-(A7)
08002596  4EB9 0800 8314          jsr       _OS_MemClr
0800259A  0F3E      
0800259C  504F      8315          addq.w    #8,A7
                    8316   ; for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
0800259E  4243      8317          clr.w     D3
                    8318   OS_MemInit_1:
080025A0  0C43 0004 8319          cmp.w     #4,D3
080025A4  6400 003C 8320          bhs       OS_MemInit_3
                    8321   ; pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
080025A8  200A      8322          move.l    A2,D0
080025AA  C6BC 0000 8323          and.l     #65535,D3
080025AE  FFFF      
080025B0  2203      8324          move.l    D3,D1
080025B2  C3FC 0018 8325          muls      #24,D1
080025B6  D081      8326          add.l     D1,D0
080025B8  2400      8327          move.l    D0,D2
                    8328   ; pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
080025BA  200A      8329          move.l    A2,D0
080025BC  C6BC 0000 8330          and.l     #65535,D3
080025C0  FFFF      
080025C2  2203      8331          move.l    D3,D1
080025C4  5281      8332          addq.l    #1,D1
080025C6  C3FC 0018 8333          muls      #24,D1
080025CA  D081      8334          add.l     D1,D0
080025CC  2042      8335          move.l    D2,A0
080025CE  2140 0004 8336          move.l    D0,4(A0)
                    8337   ; #if OS_MEM_NAME_EN > 0u
                    8338   ; pmem->OSMemName  = (INT8U *)(void *)"?";
080025D2  41F9 0800 8339          lea       @ucos_ii_1.L,A0
080025D6  57FE      
080025D8  2242      8340          move.l    D2,A1
080025DA  2348 0014 8341          move.l    A0,20(A1)
080025DE  5243      8342          addq.w    #1,D3
080025E0  60BE      8343          bra       OS_MemInit_1
                    8344   OS_MemInit_3:
                    8345   ; #endif
                    8346   ; }
                    8347   ; pmem                = &OSMemTbl[i];
080025E2  200A      8348          move.l    A2,D0
080025E4  C6BC 0000 8349          and.l     #65535,D3
080025E8  FFFF      
080025EA  2203      8350          move.l    D3,D1
080025EC  C3FC 0018 8351          muls      #24,D1
080025F0  D081      8352          add.l     D1,D0
080025F2  2400      8353          move.l    D0,D2
                    8354   ; pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
080025F4  2042      8355          move.l    D2,A0
080025F6  42A8 0004 8356          clr.l     4(A0)
                    8357   ; #if OS_MEM_NAME_EN > 0u
                    8358   ; pmem->OSMemName = (INT8U *)(void *)"?";
080025FA  41F9 0800 8359          lea       @ucos_ii_1.L,A0
080025FE  57FE      
08002600  2242      8360          move.l    D2,A1
08002602  2348 0014 8361          move.l    A0,20(A1)
                    8362   ; #endif
                    8363   ; OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
08002606  23CA 0800 8364          move.l    A2,_OSMemFreeList.L
0800260A  0CA0      
0800260C  4CDF 040C 8365          movem.l   (A7)+,D2/D3/A2
08002610  4E75      8366          rts
                    8367   ; /*
                    8368   ; *********************************************************************************************************
                    8369   ; *                                                uC/OS-II
                    8370   ; *                                          The Real-Time Kernel
                    8371   ; *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
                    8372   ; *
                    8373   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8374   ; *                                           All Rights Reserved
                    8375   ; *
                    8376   ; * File    : OS_MUTEX.C
                    8377   ; * By      : Jean J. Labrosse
                    8378   ; * Version : V2.92.07
                    8379   ; *
                    8380   ; * LICENSING TERMS:
                    8381   ; * ---------------
                    8382   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    8383   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    8384   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    8385   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    8386   ; * licensing fee.
                    8387   ; *********************************************************************************************************
                    8388   ; */
                    8389   ; #define  MICRIUM_SOURCE
                    8390   ; #ifndef  OS_MASTER_FILE
                    8391   ; #include <ucos_ii.h>
                    8392   ; #endif
                    8393   ; #if OS_MUTEX_EN > 0u
                    8394   ; /*
                    8395   ; *********************************************************************************************************
                    8396   ; *                                           LOCAL CONSTANTS
                    8397   ; *********************************************************************************************************
                    8398   ; */
                    8399   ; #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
                    8400   ; #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
                    8401   ; #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
                    8402   ; /*
                    8403   ; *********************************************************************************************************
                    8404   ; *                                           LOCAL CONSTANTS
                    8405   ; *********************************************************************************************************
                    8406   ; */
                    8407   ; static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
                    8408   ; /*$PAGE*/
                    8409   ; /*
                    8410   ; *********************************************************************************************************
                    8411   ; *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
                    8412   ; *
                    8413   ; * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
                    8414   ; *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
                    8415   ; *              not available or the event did not occur.
                    8416   ; *
                    8417   ; * Arguments  : pevent     is a pointer to the event control block
                    8418   ; *
                    8419   ; *              perr       is a pointer to an error code which will be returned to your application:
                    8420   ; *                            OS_ERR_NONE         if the call was successful.
                    8421   ; *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
                    8422   ; *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
                    8423   ; *                            OS_ERR_PEND_ISR     if you called this function from an ISR
                    8424   ; *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
                    8425   ; *                                                HIGHER (i.e. a lower number) than the PCP.  This error
                    8426   ; *                                                indicates that you did not set the PCP higher (lower
                    8427   ; *                                                number) than ALL the tasks that compete for the Mutex.
                    8428   ; *                                                Unfortunately, this is something that could not be
                    8429   ; *                                                detected when the Mutex is created because we don't know
                    8430   ; *                                                what tasks will be using the Mutex.
                    8431   ; *
                    8432   ; * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
                    8433   ; *              == OS_FALSE   a) if the resource is not available
                    8434   ; *                            b) you didn't pass a pointer to a mutual exclusion semaphore
                    8435   ; *                            c) you called this function from an ISR
                    8436   ; *
                    8437   ; * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
                    8438   ; *              intended to be used by tasks only.
                    8439   ; *********************************************************************************************************
                    8440   ; */
                    8441   ; #if OS_MUTEX_ACCEPT_EN > 0u
                    8442   ; BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
                    8443   ; INT8U     *perr)
                    8444   ; {
                    8445   _OSMutexAccept:
08002612  4E56 0000 8446          link      A6,#0
08002616  48E7 3820 8447          movem.l   D2/D3/D4/A2,-(A7)
0800261A  242E 0008 8448          move.l    8(A6),D2
0800261E  262E 000C 8449          move.l    12(A6),D3
08002622  45F9 0800 8450          lea       _OSTCBCur.L,A2
08002626  042C      
                    8451   ; INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
                    8452   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    8453   ; OS_CPU_SR  cpu_sr = 0u;
                    8454   ; #endif
                    8455   ; #ifdef OS_SAFETY_CRITICAL
                    8456   ; if (perr == (INT8U *)0) {
                    8457   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8458   ; return (OS_FALSE);
                    8459   ; }
                    8460   ; #endif
                    8461   ; #if OS_ARG_CHK_EN > 0u
                    8462   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    8463   ; *perr = OS_ERR_PEVENT_NULL;
                    8464   ; return (OS_FALSE);
                    8465   ; }
                    8466   ; #endif
                    8467   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
08002628  2042      8468          move.l    D2,A0
0800262A  1010      8469          move.b    (A0),D0
0800262C  0C00 0004 8470          cmp.b     #4,D0
08002630  670C      8471          beq.s     OSMutexAccept_1
                    8472   ; *perr = OS_ERR_EVENT_TYPE;
08002632  2043      8473          move.l    D3,A0
08002634  10BC 0001 8474          move.b    #1,(A0)
                    8475   ; return (OS_FALSE);
08002638  4200      8476          clr.b     D0
0800263A  6000 0084 8477          bra       OSMutexAccept_3
                    8478   OSMutexAccept_1:
                    8479   ; }
                    8480   ; if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
0800263E  1039 0800 8481          move.b    _OSIntNesting.L,D0
08002642  0312      
08002644  0C00 0000 8482          cmp.b     #0,D0
08002648  630C      8483          bls.s     OSMutexAccept_4
                    8484   ; *perr = OS_ERR_PEND_ISR;
0800264A  2043      8485          move.l    D3,A0
0800264C  10BC 0002 8486          move.b    #2,(A0)
                    8487   ; return (OS_FALSE);
08002650  4200      8488          clr.b     D0
08002652  6000 006C 8489          bra       OSMutexAccept_3
                    8490   OSMutexAccept_4:
                    8491   ; }
                    8492   ; OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
08002656  40E7      8493          dc.w      16615
08002658  007C      8494          dc.w      124
0800265A  0700      8495          dc.w      1792
                    8496   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
0800265C  2042      8497          move.l    D2,A0
0800265E  3028 0006 8498          move.w    6(A0),D0
08002662  E048      8499          lsr.w     #8,D0
08002664  1800      8500          move.b    D0,D4
                    8501   ; if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
08002666  2042      8502          move.l    D2,A0
08002668  3028 0006 8503          move.w    6(A0),D0
0800266C  C07C 00FF 8504          and.w     #255,D0
08002670  0C40 00FF 8505          cmp.w     #255,D0
08002674  6600 0042 8506          bne       OSMutexAccept_6
                    8507   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
08002678  2042      8508          move.l    D2,A0
0800267A  0268 FF00 8509          and.w     #65280,6(A0)
0800267E  0006      
                    8510   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
08002680  2042      8511          move.l    D2,A0
08002682  2252      8512          move.l    (A2),A1
08002684  1029 0034 8513          move.b    52(A1),D0
08002688  C07C 00FF 8514          and.w     #255,D0
0800268C  8168 0006 8515          or.w      D0,6(A0)
                    8516   ; pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
08002690  2042      8517          move.l    D2,A0
08002692  2152 0002 8518          move.l    (A2),2(A0)
                    8519   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
08002696  0C04 00FF 8520          cmp.b     #255,D4
0800269A  6712      8521          beq.s     OSMutexAccept_8
0800269C  2052      8522          move.l    (A2),A0
0800269E  B828 0034 8523          cmp.b     52(A0),D4
080026A2  650A      8524          blo.s     OSMutexAccept_8
                    8525   ; (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
                    8526   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
080026A4  46DF      8527          dc.w      18143
                    8528   ; *perr = OS_ERR_PCP_LOWER;
080026A6  2043      8529          move.l    D3,A0
080026A8  10BC 0078 8530          move.b    #120,(A0)
080026AC  6006      8531          bra.s     OSMutexAccept_9
                    8532   OSMutexAccept_8:
                    8533   ; } else {
                    8534   ; OS_EXIT_CRITICAL();
080026AE  46DF      8535          dc.w      18143
                    8536   ; *perr = OS_ERR_NONE;
080026B0  2043      8537          move.l    D3,A0
080026B2  4210      8538          clr.b     (A0)
                    8539   OSMutexAccept_9:
                    8540   ; }
                    8541   ; return (OS_TRUE);
080026B4  7001      8542          moveq     #1,D0
080026B6  6008      8543          bra.s     OSMutexAccept_3
                    8544   OSMutexAccept_6:
                    8545   ; }
                    8546   ; OS_EXIT_CRITICAL();
080026B8  46DF      8547          dc.w      18143
                    8548   ; *perr = OS_ERR_NONE;
080026BA  2043      8549          move.l    D3,A0
080026BC  4210      8550          clr.b     (A0)
                    8551   ; return (OS_FALSE);
080026BE  4200      8552          clr.b     D0
                    8553   OSMutexAccept_3:
080026C0  4CDF 041C 8554          movem.l   (A7)+,D2/D3/D4/A2
080026C4  4E5E      8555          unlk      A6
080026C6  4E75      8556          rts
                    8557   ; }
                    8558   ; #endif
                    8559   ; /*$PAGE*/
                    8560   ; /*
                    8561   ; *********************************************************************************************************
                    8562   ; *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
                    8563   ; *
                    8564   ; * Description: This function creates a mutual exclusion semaphore.
                    8565   ; *
                    8566   ; * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
                    8567   ; *                            other words, when the semaphore is acquired and a higher priority task
                    8568   ; *                            attempts to obtain the semaphore then the priority of the task owning the
                    8569   ; *                            semaphore is raised to this priority.  It is assumed that you will specify
                    8570   ; *                            a priority that is LOWER in value than ANY of the tasks competing for the
                    8571   ; *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
                    8572   ; *                            priority ceiling promotion is disabled. This way, the tasks accessing the
                    8573   ; *                            semaphore do not have their priority promoted.
                    8574   ; *
                    8575   ; *              perr          is a pointer to an error code which will be returned to your application:
                    8576   ; *                               OS_ERR_NONE         if the call was successful.
                    8577   ; *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
                    8578   ; *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
                    8579   ; *                                                   already exist.
                    8580   ; *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
                    8581   ; *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
                    8582   ; *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
                    8583   ; *
                    8584   ; * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    8585   ; *                            created mutex.
                    8586   ; *              == (void *)0  if an error is detected.
                    8587   ; *
                    8588   ; * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
                    8589   ; *                 owning the mutex or 0xFF if no task owns the mutex.
                    8590   ; *
                    8591   ; *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
                    8592   ; *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
                    8593   ; *                 promotion is disabled.
                    8594   ; *********************************************************************************************************
                    8595   ; */
                    8596   ; OS_EVENT  *OSMutexCreate (INT8U   prio,
                    8597   ; INT8U  *perr)
                    8598   ; {
                    8599   _OSMutexCreate:
080026C8  4E56 0000 8600          link      A6,#0
080026CC  48E7 3830 8601          movem.l   D2/D3/D4/A2/A3,-(A7)
080026D0  162E 000B 8602          move.b    11(A6),D3
080026D4  C6BC 0000 8603          and.l     #255,D3
080026D8  00FF      
080026DA  282E 000C 8604          move.l    12(A6),D4
080026DE  45F9 0800 8605          lea       _OSEventFreeList.L,A2
080026E2  00E6      
080026E4  47F9 0800 8606          lea       _OSTCBPrioTbl.L,A3
080026E8  043C      
                    8607   ; OS_EVENT  *pevent;
                    8608   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8609   ; OS_CPU_SR  cpu_sr = 0u;
                    8610   ; #endif
                    8611   ; #ifdef OS_SAFETY_CRITICAL
                    8612   ; if (perr == (INT8U *)0) {
                    8613   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8614   ; return ((OS_EVENT *)0);
                    8615   ; }
                    8616   ; #endif
                    8617   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8618   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8619   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8620   ; return ((OS_EVENT *)0);
                    8621   ; }
                    8622   ; #endif
                    8623   ; #if OS_ARG_CHK_EN > 0u
                    8624   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
                    8625   ; if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
                    8626   ; *perr = OS_ERR_PRIO_INVALID;
                    8627   ; return ((OS_EVENT *)0);
                    8628   ; }
                    8629   ; }
                    8630   ; #endif
                    8631   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
080026EA  1039 0800 8632          move.b    _OSIntNesting.L,D0
080026EE  0312      
080026F0  0C00 0000 8633          cmp.b     #0,D0
080026F4  630C      8634          bls.s     OSMutexCreate_1
                    8635   ; *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
080026F6  2044      8636          move.l    D4,A0
080026F8  10BC 0010 8637          move.b    #16,(A0)
                    8638   ; return ((OS_EVENT *)0);
080026FC  4280      8639          clr.l     D0
080026FE  6000 00A8 8640          bra       OSMutexCreate_3
                    8641   OSMutexCreate_1:
                    8642   ; }
                    8643   ; OS_ENTER_CRITICAL();
08002702  40E7      8644          dc.w      16615
08002704  007C      8645          dc.w      124
08002706  0700      8646          dc.w      1792
                    8647   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
08002708  0C03 00FF 8648          cmp.b     #255,D3
0800270C  6730      8649          beq.s     OSMutexCreate_4
                    8650   ; if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
0800270E  C6BC 0000 8651          and.l     #255,D3
08002712  00FF      
08002714  2003      8652          move.l    D3,D0
08002716  E588      8653          lsl.l     #2,D0
08002718  2033 0800 8654          move.l    0(A3,D0.L),D0
0800271C  670E      8655          beq.s     OSMutexCreate_6
                    8656   ; OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
0800271E  46DF      8657          dc.w      18143
                    8658   ; *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
08002720  2044      8659          move.l    D4,A0
08002722  10BC 0028 8660          move.b    #40,(A0)
                    8661   ; return ((OS_EVENT *)0);
08002726  4280      8662          clr.l     D0
08002728  6000 007E 8663          bra       OSMutexCreate_3
                    8664   OSMutexCreate_6:
                    8665   ; }
                    8666   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
0800272C  C6BC 0000 8667          and.l     #255,D3
08002730  00FF      
08002732  2003      8668          move.l    D3,D0
08002734  E588      8669          lsl.l     #2,D0
08002736  27BC 0000 8670          move.l    #1,0(A3,D0.L)
0800273A  0001 0800 
                    8671   OSMutexCreate_4:
                    8672   ; }
                    8673   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
0800273E  2412      8674          move.l    (A2),D2
                    8675   ; if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
08002740  4A82      8676          tst.l     D2
08002742  6622      8677          bne.s     OSMutexCreate_8
                    8678   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
08002744  0C03 00FF 8679          cmp.b     #255,D3
08002748  670E      8680          beq.s     OSMutexCreate_10
                    8681   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
0800274A  C6BC 0000 8682          and.l     #255,D3
0800274E  00FF      
08002750  2003      8683          move.l    D3,D0
08002752  E588      8684          lsl.l     #2,D0
08002754  42B3 0800 8685          clr.l     0(A3,D0.L)
                    8686   OSMutexCreate_10:
                    8687   ; }
                    8688   ; OS_EXIT_CRITICAL();
08002758  46DF      8689          dc.w      18143
                    8690   ; *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
0800275A  2044      8691          move.l    D4,A0
0800275C  10BC 0004 8692          move.b    #4,(A0)
                    8693   ; return (pevent);
08002760  2002      8694          move.l    D2,D0
08002762  6000 0044 8695          bra       OSMutexCreate_3
                    8696   OSMutexCreate_8:
                    8697   ; }
                    8698   ; OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
08002766  2052      8699          move.l    (A2),A0
08002768  24A8 0002 8700          move.l    2(A0),(A2)
                    8701   ; OS_EXIT_CRITICAL();
0800276C  46DF      8702          dc.w      18143
                    8703   ; pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
0800276E  2042      8704          move.l    D2,A0
08002770  10BC 0004 8705          move.b    #4,(A0)
                    8706   ; pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
08002774  1003      8707          move.b    D3,D0
08002776  C07C 00FF 8708          and.w     #255,D0
0800277A  E148      8709          lsl.w     #8,D0
0800277C  807C 00FF 8710          or.w      #255,D0
08002780  2042      8711          move.l    D2,A0
08002782  3140 0006 8712          move.w    D0,6(A0)
                    8713   ; pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
08002786  2042      8714          move.l    D2,A0
08002788  42A8 0002 8715          clr.l     2(A0)
                    8716   ; #if OS_EVENT_NAME_EN > 0u
                    8717   ; pevent->OSEventName = (INT8U *)(void *)"?";
0800278C  41F9 0800 8718          lea       @ucos_ii_1.L,A0
08002790  57FE      
08002792  2242      8719          move.l    D2,A1
08002794  2348 0012 8720          move.l    A0,18(A1)
                    8721   ; #endif
                    8722   ; OS_EventWaitListInit(pevent);
08002798  2F02      8723          move.l    D2,-(A7)
0800279A  4EB9 0800 8724          jsr       _OS_EventWaitListInit
0800279E  0C72      
080027A0  584F      8725          addq.w    #4,A7
                    8726   ; *perr = OS_ERR_NONE;
080027A2  2044      8727          move.l    D4,A0
080027A4  4210      8728          clr.b     (A0)
                    8729   ; return (pevent);
080027A6  2002      8730          move.l    D2,D0
                    8731   OSMutexCreate_3:
080027A8  4CDF 0C1C 8732          movem.l   (A7)+,D2/D3/D4/A2/A3
080027AC  4E5E      8733          unlk      A6
080027AE  4E75      8734          rts
                    8735   ; }
                    8736   ; /*$PAGE*/
                    8737   ; /*
                    8738   ; *********************************************************************************************************
                    8739   ; *                                           DELETE A MUTEX
                    8740   ; *
                    8741   ; * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
                    8742   ; *
                    8743   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
                    8744   ; *
                    8745   ; *              opt           determines delete options as follows:
                    8746   ; *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
                    8747   ; *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
                    8748   ; *                                                    In this case, all the tasks pending will be readied.
                    8749   ; *
                    8750   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    8751   ; *                            OS_ERR_NONE             The call was successful and the mutex was deleted
                    8752   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
                    8753   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    8754   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
                    8755   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    8756   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    8757   ; *
                    8758   ; * Returns    : pevent        upon error
                    8759   ; *              (OS_EVENT *)0 if the mutex was successfully deleted.
                    8760   ; *
                    8761   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    8762   ; *                 the mutex MUST check the return code of OSMutexPend().
                    8763   ; *
                    8764   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    8765   ; *                 time is directly proportional to the number of tasks waiting on the mutex.
                    8766   ; *
                    8767   ; *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
                    8768   ; *                 resource(s) will no longer be guarded by the mutex.
                    8769   ; *
                    8770   ; *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
                    8771   ; *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
                    8772   ; *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
                    8773   ; *                            that task will be made ready-to-run at its original priority.
                    8774   ; *********************************************************************************************************
                    8775   ; */
                    8776   ; #if OS_MUTEX_DEL_EN > 0u
                    8777   ; OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
                    8778   ; INT8U      opt,
                    8779   ; INT8U     *perr)
                    8780   ; {
                    8781   _OSMutexDel:
080027B0  4E56 FFFC 8782          link      A6,#-4
080027B4  48E7 3F20 8783          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
080027B8  242E 0008 8784          move.l    8(A6),D2
080027BC  282E 0010 8785          move.l    16(A6),D4
080027C0  45F9 0800 8786          lea       _OSEventFreeList.L,A2
080027C4  00E6      
                    8787   ; BOOLEAN    tasks_waiting;
                    8788   ; OS_EVENT  *pevent_return;
                    8789   ; INT8U      pcp;                                        /* Priority ceiling priority                */
                    8790   ; INT8U      prio;
                    8791   ; OS_TCB    *ptcb;
                    8792   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8793   ; OS_CPU_SR  cpu_sr = 0u;
                    8794   ; #endif
                    8795   ; #ifdef OS_SAFETY_CRITICAL
                    8796   ; if (perr == (INT8U *)0) {
                    8797   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8798   ; return ((OS_EVENT *)0);
                    8799   ; }
                    8800   ; #endif
                    8801   ; #if OS_ARG_CHK_EN > 0u
                    8802   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    8803   ; *perr = OS_ERR_PEVENT_NULL;
                    8804   ; return (pevent);
                    8805   ; }
                    8806   ; #endif
                    8807   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
080027C6  2042      8808          move.l    D2,A0
080027C8  1010      8809          move.b    (A0),D0
080027CA  0C00 0004 8810          cmp.b     #4,D0
080027CE  670C      8811          beq.s     OSMutexDel_1
                    8812   ; *perr = OS_ERR_EVENT_TYPE;
080027D0  2044      8813          move.l    D4,A0
080027D2  10BC 0001 8814          move.b    #1,(A0)
                    8815   ; return (pevent);
080027D6  2002      8816          move.l    D2,D0
080027D8  6000 0180 8817          bra       OSMutexDel_3
                    8818   OSMutexDel_1:
                    8819   ; }
                    8820   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
080027DC  1039 0800 8821          move.b    _OSIntNesting.L,D0
080027E0  0312      
080027E2  0C00 0000 8822          cmp.b     #0,D0
080027E6  630C      8823          bls.s     OSMutexDel_4
                    8824   ; *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
080027E8  2044      8825          move.l    D4,A0
080027EA  10BC 000F 8826          move.b    #15,(A0)
                    8827   ; return (pevent);
080027EE  2002      8828          move.l    D2,D0
080027F0  6000 0168 8829          bra       OSMutexDel_3
                    8830   OSMutexDel_4:
                    8831   ; }
                    8832   ; OS_ENTER_CRITICAL();
080027F4  40E7      8833          dc.w      16615
080027F6  007C      8834          dc.w      124
080027F8  0700      8835          dc.w      1792
                    8836   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
080027FA  2042      8837          move.l    D2,A0
080027FC  1028 0008 8838          move.b    8(A0),D0
08002800  6704      8839          beq.s     OSMutexDel_6
                    8840   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
08002802  7E01      8841          moveq     #1,D7
08002804  6002      8842          bra.s     OSMutexDel_7
                    8843   OSMutexDel_6:
                    8844   ; } else {
                    8845   ; tasks_waiting = OS_FALSE;                          /* No                                       */
08002806  7E00      8846          moveq     #0,D7
                    8847   OSMutexDel_7:
                    8848   ; }
                    8849   ; switch (opt) {
08002808  102E 000F 8850          move.b    15(A6),D0
0800280C  C0BC 0000 8851          and.l     #255,D0
08002810  00FF      
08002812  0C80 0000 8852          cmp.l     #1,D0
08002816  0001      
08002818  6700 006E 8853          beq       OSMutexDel_11
0800281C  6200 0130 8854          bhi       OSMutexDel_8
08002820  4A80      8855          tst.l     D0
08002822  6704      8856          beq.s     OSMutexDel_10
08002824  6000 0128 8857          bra       OSMutexDel_8
                    8858   OSMutexDel_10:
                    8859   ; case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
                    8860   ; if (tasks_waiting == OS_FALSE) {
08002828  4A07      8861          tst.b     D7
0800282A  6600 004E 8862          bne       OSMutexDel_13
                    8863   ; #if OS_EVENT_NAME_EN > 0u
                    8864   ; pevent->OSEventName   = (INT8U *)(void *)"?";
0800282E  41F9 0800 8865          lea       @ucos_ii_1.L,A0
08002832  57FE      
08002834  2242      8866          move.l    D2,A1
08002836  2348 0012 8867          move.l    A0,18(A1)
                    8868   ; #endif
                    8869   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
0800283A  2042      8870          move.l    D2,A0
0800283C  3028 0006 8871          move.w    6(A0),D0
08002840  E048      8872          lsr.w     #8,D0
08002842  1600      8873          move.b    D0,D3
                    8874   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
08002844  0C03 00FF 8875          cmp.b     #255,D3
08002848  6714      8876          beq.s     OSMutexDel_15
                    8877   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
0800284A  C6BC 0000 8878          and.l     #255,D3
0800284E  00FF      
08002850  2003      8879          move.l    D3,D0
08002852  E588      8880          lsl.l     #2,D0
08002854  41F9 0800 8881          lea       _OSTCBPrioTbl.L,A0
08002858  043C      
0800285A  42B0 0800 8882          clr.l     0(A0,D0.L)
                    8883   OSMutexDel_15:
                    8884   ; }
                    8885   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
0800285E  2042      8886          move.l    D2,A0
08002860  4210      8887          clr.b     (A0)
                    8888   ; pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
08002862  2042      8889          move.l    D2,A0
08002864  2152 0002 8890          move.l    (A2),2(A0)
                    8891   ; pevent->OSEventCnt    = 0u;
08002868  2042      8892          move.l    D2,A0
0800286A  4268 0006 8893          clr.w     6(A0)
                    8894   ; OSEventFreeList       = pevent;
0800286E  2482      8895          move.l    D2,(A2)
                    8896   ; OS_EXIT_CRITICAL();
08002870  46DF      8897          dc.w      18143
                    8898   ; *perr                 = OS_ERR_NONE;
08002872  2044      8899          move.l    D4,A0
08002874  4210      8900          clr.b     (A0)
                    8901   ; pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
08002876  4285      8902          clr.l     D5
08002878  600A      8903          bra.s     OSMutexDel_14
                    8904   OSMutexDel_13:
                    8905   ; } else {
                    8906   ; OS_EXIT_CRITICAL();
0800287A  46DF      8907          dc.w      18143
                    8908   ; *perr                 = OS_ERR_TASK_WAITING;
0800287C  2044      8909          move.l    D4,A0
0800287E  10BC 0049 8910          move.b    #73,(A0)
                    8911   ; pevent_return         = pevent;
08002882  2A02      8912          move.l    D2,D5
                    8913   OSMutexDel_14:
                    8914   ; }
                    8915   ; break;
08002884  6000 00D2 8916          bra       OSMutexDel_9
                    8917   OSMutexDel_11:
                    8918   ; case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
                    8919   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
08002888  2042      8920          move.l    D2,A0
0800288A  3028 0006 8921          move.w    6(A0),D0
0800288E  E048      8922          lsr.w     #8,D0
08002890  1600      8923          move.b    D0,D3
                    8924   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
08002892  0C03 00FF 8925          cmp.b     #255,D3
08002896  6700 0038 8926          beq       OSMutexDel_21
                    8927   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
0800289A  2042      8928          move.l    D2,A0
0800289C  3028 0006 8929          move.w    6(A0),D0
080028A0  C07C 00FF 8930          and.w     #255,D0
080028A4  1D40 FFFF 8931          move.b    D0,-1(A6)
                    8932   ; ptcb = (OS_TCB *)pevent->OSEventPtr;
080028A8  2042      8933          move.l    D2,A0
080028AA  2C28 0002 8934          move.l    2(A0),D6
                    8935   ; if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
080028AE  4A86      8936          tst.l     D6
080028B0  671E      8937          beq.s     OSMutexDel_21
                    8938   ; if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
080028B2  2046      8939          move.l    D6,A0
080028B4  B628 0034 8940          cmp.b     52(A0),D3
080028B8  6616      8941          bne.s     OSMutexDel_21
                    8942   ; OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
080028BA  122E FFFF 8943          move.b    -1(A6),D1
080028BE  C2BC 0000 8944          and.l     #255,D1
080028C2  00FF      
080028C4  2F01      8945          move.l    D1,-(A7)
080028C6  2F06      8946          move.l    D6,-(A7)
080028C8  4EB9 0800 8947          jsr       @ucos_ii_OSMutex_RdyAtPrio
080028CC  2E1C      
080028CE  504F      8948          addq.w    #8,A7
                    8949   OSMutexDel_21:
                    8950   ; }
                    8951   ; }
                    8952   ; }
                    8953   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
                    8954   OSMutexDel_23:
080028D0  2042      8955          move.l    D2,A0
080028D2  1028 0008 8956          move.b    8(A0),D0
080028D6  671E      8957          beq.s     OSMutexDel_25
                    8958   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
080028D8  4878 0002 8959          pea       2
080028DC  4878 0010 8960          pea       16
080028E0  42A7      8961          clr.l     -(A7)
080028E2  2F02      8962          move.l    D2,-(A7)
080028E4  4EB9 0800 8963          jsr       _OS_EventTaskRdy
080028E8  09AA      
080028EA  DEFC 0010 8964          add.w     #16,A7
080028EE  C0BC 0000 8965          and.l     #255,D0
080028F2  00FF      
080028F4  60DA      8966          bra       OSMutexDel_23
                    8967   OSMutexDel_25:
                    8968   ; }
                    8969   ; #if OS_EVENT_NAME_EN > 0u
                    8970   ; pevent->OSEventName   = (INT8U *)(void *)"?";
080028F6  41F9 0800 8971          lea       @ucos_ii_1.L,A0
080028FA  57FE      
080028FC  2242      8972          move.l    D2,A1
080028FE  2348 0012 8973          move.l    A0,18(A1)
                    8974   ; #endif
                    8975   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
08002902  2042      8976          move.l    D2,A0
08002904  3028 0006 8977          move.w    6(A0),D0
08002908  E048      8978          lsr.w     #8,D0
0800290A  1600      8979          move.b    D0,D3
                    8980   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0800290C  0C03 00FF 8981          cmp.b     #255,D3
08002910  6714      8982          beq.s     OSMutexDel_26
                    8983   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
08002912  C6BC 0000 8984          and.l     #255,D3
08002916  00FF      
08002918  2003      8985          move.l    D3,D0
0800291A  E588      8986          lsl.l     #2,D0
0800291C  41F9 0800 8987          lea       _OSTCBPrioTbl.L,A0
08002920  043C      
08002922  42B0 0800 8988          clr.l     0(A0,D0.L)
                    8989   OSMutexDel_26:
                    8990   ; }
                    8991   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
08002926  2042      8992          move.l    D2,A0
08002928  4210      8993          clr.b     (A0)
                    8994   ; pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
0800292A  2042      8995          move.l    D2,A0
0800292C  2152 0002 8996          move.l    (A2),2(A0)
                    8997   ; pevent->OSEventCnt    = 0u;
08002930  2042      8998          move.l    D2,A0
08002932  4268 0006 8999          clr.w     6(A0)
                    9000   ; OSEventFreeList       = pevent;               /* Get next free event control block        */
08002936  2482      9001          move.l    D2,(A2)
                    9002   ; OS_EXIT_CRITICAL();
08002938  46DF      9003          dc.w      18143
                    9004   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0800293A  0C07 0001 9005          cmp.b     #1,D7
0800293E  6606      9006          bne.s     OSMutexDel_28
                    9007   ; OS_Sched();                               /* Find highest priority task ready to run  */
08002940  4EB9 0800 9008          jsr       _OS_Sched
08002944  0F8A      
                    9009   OSMutexDel_28:
                    9010   ; }
                    9011   ; *perr         = OS_ERR_NONE;
08002946  2044      9012          move.l    D4,A0
08002948  4210      9013          clr.b     (A0)
                    9014   ; pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
0800294A  4285      9015          clr.l     D5
                    9016   ; break;
0800294C  600A      9017          bra.s     OSMutexDel_9
                    9018   OSMutexDel_8:
                    9019   ; default:
                    9020   ; OS_EXIT_CRITICAL();
0800294E  46DF      9021          dc.w      18143
                    9022   ; *perr         = OS_ERR_INVALID_OPT;
08002950  2044      9023          move.l    D4,A0
08002952  10BC 0007 9024          move.b    #7,(A0)
                    9025   ; pevent_return = pevent;
08002956  2A02      9026          move.l    D2,D5
                    9027   ; break;
                    9028   OSMutexDel_9:
                    9029   ; }
                    9030   ; return (pevent_return);
08002958  2005      9031          move.l    D5,D0
                    9032   OSMutexDel_3:
0800295A  4CDF 04FC 9033          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
0800295E  4E5E      9034          unlk      A6
08002960  4E75      9035          rts
                    9036   ; }
                    9037   ; #endif
                    9038   ; /*$PAGE*/
                    9039   ; /*
                    9040   ; *********************************************************************************************************
                    9041   ; *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
                    9042   ; *
                    9043   ; * Description: This function waits for a mutual exclusion semaphore.
                    9044   ; *
                    9045   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    9046   ; *                            mutex.
                    9047   ; *
                    9048   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    9049   ; *                            wait for the resource up to the amount of time specified by this argument.
                    9050   ; *                            If you specify 0, however, your task will wait forever at the specified
                    9051   ; *                            mutex or, until the resource becomes available.
                    9052   ; *
                    9053   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9054   ; *                            messages are:
                    9055   ; *                               OS_ERR_NONE        The call was successful and your task owns the mutex
                    9056   ; *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
                    9057   ; *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
                    9058   ; *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
                    9059   ; *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
                    9060   ; *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
                    9061   ; *                                                  would lead to a suspension.
                    9062   ; *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
                    9063   ; *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
                    9064   ; *                                                  indicates that you did not set the PCP higher (lower
                    9065   ; *                                                  number) than ALL the tasks that compete for the Mutex.
                    9066   ; *                                                  Unfortunately, this is something that could not be
                    9067   ; *                                                  detected when the Mutex is created because we don't know
                    9068   ; *                                                  what tasks will be using the Mutex.
                    9069   ; *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
                    9070   ; *
                    9071   ; * Returns    : none
                    9072   ; *
                    9073   ; * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
                    9074   ; *
                    9075   ; *              2) You MUST NOT change the priority of the task that owns the mutex
                    9076   ; *********************************************************************************************************
                    9077   ; */
                    9078   ; void  OSMutexPend (OS_EVENT  *pevent,
                    9079   ; INT32U     timeout,
                    9080   ; INT8U     *perr)
                    9081   ; {
                    9082   _OSMutexPend:
08002962  4E56 FFFC 9083          link      A6,#-4
08002966  48E7 3F30 9084          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
0800296A  45F9 0800 9085          lea       _OSTCBCur.L,A2
0800296E  042C      
08002970  262E 0008 9086          move.l    8(A6),D3
08002974  2A2E 0010 9087          move.l    16(A6),D5
08002978  47F9 0800 9088          lea       _OSRdyTbl.L,A3
0800297C  031C      
                    9089   ; INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
                    9090   ; INT8U      mprio;                                      /* Mutex owner priority                     */
                    9091   ; BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
                    9092   ; OS_TCB    *ptcb;
                    9093   ; OS_EVENT  *pevent2;
                    9094   ; INT8U      y;
                    9095   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9096   ; OS_CPU_SR  cpu_sr = 0u;
                    9097   ; #endif
                    9098   ; #ifdef OS_SAFETY_CRITICAL
                    9099   ; if (perr == (INT8U *)0) {
                    9100   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9101   ; return;
                    9102   ; }
                    9103   ; #endif
                    9104   ; #if OS_ARG_CHK_EN > 0u
                    9105   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9106   ; *perr = OS_ERR_PEVENT_NULL;
                    9107   ; return;
                    9108   ; }
                    9109   ; #endif
                    9110   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
0800297E  2043      9111          move.l    D3,A0
08002980  1010      9112          move.b    (A0),D0
08002982  0C00 0004 9113          cmp.b     #4,D0
08002986  670A      9114          beq.s     OSMutexPend_1
                    9115   ; *perr = OS_ERR_EVENT_TYPE;
08002988  2045      9116          move.l    D5,A0
0800298A  10BC 0001 9117          move.b    #1,(A0)
                    9118   ; return;
0800298E  6000 02B2 9119          bra       OSMutexPend_3
                    9120   OSMutexPend_1:
                    9121   ; }
                    9122   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
08002992  1039 0800 9123          move.b    _OSIntNesting.L,D0
08002996  0312      
08002998  0C00 0000 9124          cmp.b     #0,D0
0800299C  630A      9125          bls.s     OSMutexPend_4
                    9126   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
0800299E  2045      9127          move.l    D5,A0
080029A0  10BC 0002 9128          move.b    #2,(A0)
                    9129   ; return;
080029A4  6000 029C 9130          bra       OSMutexPend_3
                    9131   OSMutexPend_4:
                    9132   ; }
                    9133   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
080029A8  1039 0800 9134          move.b    _OSLockNesting.L,D0
080029AC  0314      
080029AE  0C00 0000 9135          cmp.b     #0,D0
080029B2  630A      9136          bls.s     OSMutexPend_6
                    9137   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
080029B4  2045      9138          move.l    D5,A0
080029B6  10BC 000D 9139          move.b    #13,(A0)
                    9140   ; return;
080029BA  6000 0286 9141          bra       OSMutexPend_3
                    9142   OSMutexPend_6:
                    9143   ; }
                    9144   ; /*$PAGE*/
                    9145   ; OS_ENTER_CRITICAL();
080029BE  40E7      9146          dc.w      16615
080029C0  007C      9147          dc.w      124
080029C2  0700      9148          dc.w      1792
                    9149   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
080029C4  2043      9150          move.l    D3,A0
080029C6  3028 0006 9151          move.w    6(A0),D0
080029CA  E048      9152          lsr.w     #8,D0
080029CC  1E00      9153          move.b    D0,D7
                    9154   ; /* Is Mutex available?                      */
                    9155   ; if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
080029CE  2043      9156          move.l    D3,A0
080029D0  3028 0006 9157          move.w    6(A0),D0
080029D4  C07C 00FF 9158          and.w     #255,D0
080029D8  C07C 00FF 9159          and.w     #255,D0
080029DC  0C40 00FF 9160          cmp.w     #255,D0
080029E0  6600 0042 9161          bne       OSMutexPend_8
                    9162   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
080029E4  2043      9163          move.l    D3,A0
080029E6  0268 FF00 9164          and.w     #65280,6(A0)
080029EA  0006      
                    9165   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
080029EC  2043      9166          move.l    D3,A0
080029EE  2252      9167          move.l    (A2),A1
080029F0  1029 0034 9168          move.b    52(A1),D0
080029F4  C07C 00FF 9169          and.w     #255,D0
080029F8  8168 0006 9170          or.w      D0,6(A0)
                    9171   ; pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
080029FC  2043      9172          move.l    D3,A0
080029FE  2152 0002 9173          move.l    (A2),2(A0)
                    9174   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
08002A02  0C07 00FF 9175          cmp.b     #255,D7
08002A06  6712      9176          beq.s     OSMutexPend_10
08002A08  2052      9177          move.l    (A2),A0
08002A0A  BE28 0034 9178          cmp.b     52(A0),D7
08002A0E  650A      9179          blo.s     OSMutexPend_10
                    9180   ; (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
                    9181   ; OS_EXIT_CRITICAL();                           /*      ... than current task!              */
08002A10  46DF      9182          dc.w      18143
                    9183   ; *perr = OS_ERR_PCP_LOWER;
08002A12  2045      9184          move.l    D5,A0
08002A14  10BC 0078 9185          move.b    #120,(A0)
08002A18  6006      9186          bra.s     OSMutexPend_11
                    9187   OSMutexPend_10:
                    9188   ; } else {
                    9189   ; OS_EXIT_CRITICAL();
08002A1A  46DF      9190          dc.w      18143
                    9191   ; *perr = OS_ERR_NONE;
08002A1C  2045      9192          move.l    D5,A0
08002A1E  4210      9193          clr.b     (A0)
                    9194   OSMutexPend_11:
                    9195   ; }
                    9196   ; return;
08002A20  6000 0220 9197          bra       OSMutexPend_3
                    9198   OSMutexPend_8:
                    9199   ; }
                    9200   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
08002A24  0C07 00FF 9201          cmp.b     #255,D7
08002A28  6700 018A 9202          beq       OSMutexPend_16
                    9203   ; mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
08002A2C  2043      9204          move.l    D3,A0
08002A2E  3028 0006 9205          move.w    6(A0),D0
08002A32  C07C 00FF 9206          and.w     #255,D0
08002A36  1D40 FFFE 9207          move.b    D0,-2(A6)
                    9208   ; ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
08002A3A  2043      9209          move.l    D3,A0
08002A3C  2428 0002 9210          move.l    2(A0),D2
                    9211   ; if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
08002A40  2042      9212          move.l    D2,A0
08002A42  BE28 0034 9213          cmp.b     52(A0),D7
08002A46  6400 016C 9214          bhs       OSMutexPend_16
                    9215   ; if (mprio > OSTCBCur->OSTCBPrio) {
08002A4A  2052      9216          move.l    (A2),A0
08002A4C  102E FFFE 9217          move.b    -2(A6),D0
08002A50  B028 0034 9218          cmp.b     52(A0),D0
08002A54  6300 015E 9219          bls       OSMutexPend_16
                    9220   ; y = ptcb->OSTCBY;
08002A58  2042      9221          move.l    D2,A0
08002A5A  1C28 0036 9222          move.b    54(A0),D6
                    9223   ; if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
08002A5E  CCBC 0000 9224          and.l     #255,D6
08002A62  00FF      
08002A64  1033 6800 9225          move.b    0(A3,D6.L),D0
08002A68  2042      9226          move.l    D2,A0
08002A6A  C028 0037 9227          and.b     55(A0),D0
08002A6E  6736      9228          beq.s     OSMutexPend_18
                    9229   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
08002A70  CCBC 0000 9230          and.l     #255,D6
08002A74  00FF      
08002A76  2042      9231          move.l    D2,A0
08002A78  1028 0037 9232          move.b    55(A0),D0
08002A7C  4600      9233          not.b     D0
08002A7E  C133 6800 9234          and.b     D0,0(A3,D6.L)
                    9235   ; if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
08002A82  CCBC 0000 9236          and.l     #255,D6
08002A86  00FF      
08002A88  1033 6800 9237          move.b    0(A3,D6.L),D0
08002A8C  660E      9238          bne.s     OSMutexPend_20
                    9239   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
08002A8E  2042      9240          move.l    D2,A0
08002A90  1028 0038 9241          move.b    56(A0),D0
08002A94  4600      9242          not.b     D0
08002A96  C139 0800 9243          and.b     D0,_OSRdyGrp.L
08002A9A  031A      
                    9244   OSMutexPend_20:
                    9245   ; }
                    9246   ; rdy = OS_TRUE;
08002A9C  1D7C 0001 9247          move.b    #1,-1(A6)
08002AA0  FFFF      
08002AA2  6000 004C 9248          bra       OSMutexPend_19
                    9249   OSMutexPend_18:
                    9250   ; } else {
                    9251   ; pevent2 = ptcb->OSTCBEventPtr;
08002AA6  2042      9252          move.l    D2,A0
08002AA8  2828 001C 9253          move.l    28(A0),D4
                    9254   ; if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
08002AAC  4A84      9255          tst.l     D4
08002AAE  6700 003C 9256          beq       OSMutexPend_24
                    9257   ; y = ptcb->OSTCBY;
08002AB2  2042      9258          move.l    D2,A0
08002AB4  1C28 0036 9259          move.b    54(A0),D6
                    9260   ; pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
08002AB8  2044      9261          move.l    D4,A0
08002ABA  CCBC 0000 9262          and.l     #255,D6
08002ABE  00FF      
08002AC0  D1C6      9263          add.l     D6,A0
08002AC2  2242      9264          move.l    D2,A1
08002AC4  1029 0037 9265          move.b    55(A1),D0
08002AC8  4600      9266          not.b     D0
08002ACA  C128 000A 9267          and.b     D0,10(A0)
                    9268   ; if (pevent2->OSEventTbl[y] == 0u) {
08002ACE  2044      9269          move.l    D4,A0
08002AD0  CCBC 0000 9270          and.l     #255,D6
08002AD4  00FF      
08002AD6  D1C6      9271          add.l     D6,A0
08002AD8  1028 000A 9272          move.b    10(A0),D0
08002ADC  660E      9273          bne.s     OSMutexPend_24
                    9274   ; pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
08002ADE  2044      9275          move.l    D4,A0
08002AE0  2242      9276          move.l    D2,A1
08002AE2  1029 0038 9277          move.b    56(A1),D0
08002AE6  4600      9278          not.b     D0
08002AE8  C128 0008 9279          and.b     D0,8(A0)
                    9280   OSMutexPend_24:
                    9281   ; }
                    9282   ; }
                    9283   ; rdy = OS_FALSE;                        /* No                                       */
08002AEC  422E FFFF 9284          clr.b     -1(A6)
                    9285   OSMutexPend_19:
                    9286   ; }
                    9287   ; ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
08002AF0  2042      9288          move.l    D2,A0
08002AF2  1147 0034 9289          move.b    D7,52(A0)
                    9290   ; #if OS_LOWEST_PRIO <= 63u
                    9291   ; ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
08002AF6  2042      9292          move.l    D2,A0
08002AF8  1028 0034 9293          move.b    52(A0),D0
08002AFC  E608      9294          lsr.b     #3,D0
08002AFE  2042      9295          move.l    D2,A0
08002B00  1140 0036 9296          move.b    D0,54(A0)
                    9297   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
08002B04  2042      9298          move.l    D2,A0
08002B06  1028 0034 9299          move.b    52(A0),D0
08002B0A  C03C 0007 9300          and.b     #7,D0
08002B0E  2042      9301          move.l    D2,A0
08002B10  1140 0035 9302          move.b    D0,53(A0)
                    9303   ; #else
                    9304   ; ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
                    9305   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
                    9306   ; #endif
                    9307   ; ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
08002B14  7001      9308          moveq     #1,D0
08002B16  2042      9309          move.l    D2,A0
08002B18  1228 0036 9310          move.b    54(A0),D1
08002B1C  C2BC 0000 9311          and.l     #255,D1
08002B20  00FF      
08002B22  E3A8      9312          lsl.l     D1,D0
08002B24  2042      9313          move.l    D2,A0
08002B26  1140 0038 9314          move.b    D0,56(A0)
                    9315   ; ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
08002B2A  7001      9316          moveq     #1,D0
08002B2C  2042      9317          move.l    D2,A0
08002B2E  1228 0035 9318          move.b    53(A0),D1
08002B32  C2BC 0000 9319          and.l     #255,D1
08002B36  00FF      
08002B38  E3A8      9320          lsl.l     D1,D0
08002B3A  2042      9321          move.l    D2,A0
08002B3C  1140 0037 9322          move.b    D0,55(A0)
                    9323   ; if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
08002B40  102E FFFF 9324          move.b    -1(A6),D0
08002B44  0C00 0001 9325          cmp.b     #1,D0
08002B48  6626      9326          bne.s     OSMutexPend_26
                    9327   ; OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
08002B4A  2042      9328          move.l    D2,A0
08002B4C  1028 0038 9329          move.b    56(A0),D0
08002B50  8139 0800 9330          or.b      D0,_OSRdyGrp.L
08002B54  031A      
                    9331   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
08002B56  2042      9332          move.l    D2,A0
08002B58  1028 0036 9333          move.b    54(A0),D0
08002B5C  C0BC 0000 9334          and.l     #255,D0
08002B60  00FF      
08002B62  2042      9335          move.l    D2,A0
08002B64  1228 0037 9336          move.b    55(A0),D1
08002B68  8333 0800 9337          or.b      D1,0(A3,D0.L)
08002B6C  6000 0032 9338          bra       OSMutexPend_28
                    9339   OSMutexPend_26:
                    9340   ; } else {
                    9341   ; pevent2 = ptcb->OSTCBEventPtr;
08002B70  2042      9342          move.l    D2,A0
08002B72  2828 001C 9343          move.l    28(A0),D4
                    9344   ; if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
08002B76  4A84      9345          tst.l     D4
08002B78  6726      9346          beq.s     OSMutexPend_28
                    9347   ; pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
08002B7A  2044      9348          move.l    D4,A0
08002B7C  2242      9349          move.l    D2,A1
08002B7E  1029 0038 9350          move.b    56(A1),D0
08002B82  8128 0008 9351          or.b      D0,8(A0)
                    9352   ; pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
08002B86  2044      9353          move.l    D4,A0
08002B88  2242      9354          move.l    D2,A1
08002B8A  1029 0036 9355          move.b    54(A1),D0
08002B8E  C0BC 0000 9356          and.l     #255,D0
08002B92  00FF      
08002B94  D1C0      9357          add.l     D0,A0
08002B96  2242      9358          move.l    D2,A1
08002B98  1029 0037 9359          move.b    55(A1),D0
08002B9C  8128 000A 9360          or.b      D0,10(A0)
                    9361   OSMutexPend_28:
                    9362   ; }
                    9363   ; }
                    9364   ; OSTCBPrioTbl[pcp] = ptcb;
08002BA0  CEBC 0000 9365          and.l     #255,D7
08002BA4  00FF      
08002BA6  2007      9366          move.l    D7,D0
08002BA8  E588      9367          lsl.l     #2,D0
08002BAA  41F9 0800 9368          lea       _OSTCBPrioTbl.L,A0
08002BAE  043C      
08002BB0  2182 0800 9369          move.l    D2,0(A0,D0.L)
                    9370   OSMutexPend_16:
                    9371   ; }
                    9372   ; }
                    9373   ; }
                    9374   ; OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
08002BB4  2052      9375          move.l    (A2),A0
08002BB6  0028 0010 9376          or.b      #16,50(A0)
08002BBA  0032      
                    9377   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
08002BBC  2052      9378          move.l    (A2),A0
08002BBE  4228 0033 9379          clr.b     51(A0)
                    9380   ; OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
08002BC2  2052      9381          move.l    (A2),A0
08002BC4  216E 000C 9382          move.l    12(A6),46(A0)
08002BC8  002E      
                    9383   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
08002BCA  2F03      9384          move.l    D3,-(A7)
08002BCC  4EB9 0800 9385          jsr       _OS_EventTaskWait
08002BD0  0A8E      
08002BD2  584F      9386          addq.w    #4,A7
                    9387   ; OS_EXIT_CRITICAL();
08002BD4  46DF      9388          dc.w      18143
                    9389   ; OS_Sched();                                       /* Find next highest priority task ready         */
08002BD6  4EB9 0800 9390          jsr       _OS_Sched
08002BDA  0F8A      
                    9391   ; OS_ENTER_CRITICAL();
08002BDC  40E7      9392          dc.w      16615
08002BDE  007C      9393          dc.w      124
08002BE0  0700      9394          dc.w      1792
                    9395   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
08002BE2  2052      9396          move.l    (A2),A0
08002BE4  1028 0033 9397          move.b    51(A0),D0
08002BE8  C0BC 0000 9398          and.l     #255,D0
08002BEC  00FF      
08002BEE  0C80 0000 9399          cmp.l     #1,D0
08002BF2  0001      
08002BF4  6720      9400          beq.s     OSMutexPend_34
08002BF6  6206      9401          bhi.s     OSMutexPend_36
08002BF8  4A80      9402          tst.l     D0
08002BFA  670C      9403          beq.s     OSMutexPend_32
08002BFC  6018      9404          bra.s     OSMutexPend_34
                    9405   OSMutexPend_36:
08002BFE  0C80 0000 9406          cmp.l     #2,D0
08002C02  0002      
08002C04  6708      9407          beq.s     OSMutexPend_33
08002C06  600E      9408          bra.s     OSMutexPend_34
                    9409   OSMutexPend_32:
                    9410   ; case OS_STAT_PEND_OK:
                    9411   ; *perr = OS_ERR_NONE;
08002C08  2045      9412          move.l    D5,A0
08002C0A  4210      9413          clr.b     (A0)
                    9414   ; break;
08002C0C  601A      9415          bra.s     OSMutexPend_31
                    9416   OSMutexPend_33:
                    9417   ; case OS_STAT_PEND_ABORT:
                    9418   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
08002C0E  2045      9419          move.l    D5,A0
08002C10  10BC 000E 9420          move.b    #14,(A0)
                    9421   ; break;
08002C14  6012      9422          bra.s     OSMutexPend_31
                    9423   OSMutexPend_34:
                    9424   ; case OS_STAT_PEND_TO:
                    9425   ; default:
                    9426   ; OS_EventTaskRemove(OSTCBCur, pevent);
08002C16  2F03      9427          move.l    D3,-(A7)
08002C18  2F12      9428          move.l    (A2),-(A7)
08002C1A  4EB9 0800 9429          jsr       _OS_EventTaskRemove
08002C1E  0BB0      
08002C20  504F      9430          addq.w    #8,A7
                    9431   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
08002C22  2045      9432          move.l    D5,A0
08002C24  10BC 000A 9433          move.b    #10,(A0)
                    9434   ; break;
                    9435   OSMutexPend_31:
                    9436   ; }
                    9437   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
08002C28  2052      9438          move.l    (A2),A0
08002C2A  4228 0032 9439          clr.b     50(A0)
                    9440   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
08002C2E  2052      9441          move.l    (A2),A0
08002C30  4228 0033 9442          clr.b     51(A0)
                    9443   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
08002C34  2052      9444          move.l    (A2),A0
08002C36  42A8 001C 9445          clr.l     28(A0)
                    9446   ; #if (OS_EVENT_MULTI_EN > 0u)
                    9447   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
08002C3A  2052      9448          move.l    (A2),A0
08002C3C  42A8 0020 9449          clr.l     32(A0)
                    9450   ; #endif
                    9451   ; OS_EXIT_CRITICAL();
08002C40  46DF      9452          dc.w      18143
                    9453   OSMutexPend_3:
08002C42  4CDF 0CFC 9454          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
08002C46  4E5E      9455          unlk      A6
08002C48  4E75      9456          rts
                    9457   ; }
                    9458   ; /*$PAGE*/
                    9459   ; /*
                    9460   ; *********************************************************************************************************
                    9461   ; *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
                    9462   ; *
                    9463   ; * Description: This function signals a mutual exclusion semaphore
                    9464   ; *
                    9465   ; * Arguments  : pevent              is a pointer to the event control block associated with the desired
                    9466   ; *                                  mutex.
                    9467   ; *
                    9468   ; * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
                    9469   ; *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9470   ; *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
                    9471   ; *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
                    9472   ; *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
                    9473   ; *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
                    9474   ; *                                      HIGHER (i.e. a lower number) than the PCP.  This error
                    9475   ; *                                      indicates that you did not set the PCP higher (lower
                    9476   ; *                                      number) than ALL the tasks that compete for the Mutex.
                    9477   ; *                                      Unfortunately, this is something that could not be
                    9478   ; *                                      detected when the Mutex is created because we don't know
                    9479   ; *                                      what tasks will be using the Mutex.
                    9480   ; *********************************************************************************************************
                    9481   ; */
                    9482   ; INT8U  OSMutexPost (OS_EVENT *pevent)
                    9483   ; {
                    9484   _OSMutexPost:
08002C4A  4E56 0000 9485          link      A6,#0
08002C4E  48E7 3820 9486          movem.l   D2/D3/D4/A2,-(A7)
08002C52  242E 0008 9487          move.l    8(A6),D2
08002C56  45F9 0800 9488          lea       _OSTCBCur.L,A2
08002C5A  042C      
                    9489   ; INT8U      pcp;                                   /* Priority ceiling priority                     */
                    9490   ; INT8U      prio;
                    9491   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    9492   ; OS_CPU_SR  cpu_sr = 0u;
                    9493   ; #endif
                    9494   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
08002C5C  1039 0800 9495          move.b    _OSIntNesting.L,D0
08002C60  0312      
08002C62  0C00 0000 9496          cmp.b     #0,D0
08002C66  6306      9497          bls.s     OSMutexPost_1
                    9498   ; return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
08002C68  7005      9499          moveq     #5,D0
08002C6A  6000 00F6 9500          bra       OSMutexPost_3
                    9501   OSMutexPost_1:
                    9502   ; }
                    9503   ; #if OS_ARG_CHK_EN > 0u
                    9504   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    9505   ; return (OS_ERR_PEVENT_NULL);
                    9506   ; }
                    9507   ; #endif
                    9508   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
08002C6E  2042      9509          move.l    D2,A0
08002C70  1010      9510          move.b    (A0),D0
08002C72  0C00 0004 9511          cmp.b     #4,D0
08002C76  6706      9512          beq.s     OSMutexPost_4
                    9513   ; return (OS_ERR_EVENT_TYPE);
08002C78  7001      9514          moveq     #1,D0
08002C7A  6000 00E6 9515          bra       OSMutexPost_3
                    9516   OSMutexPost_4:
                    9517   ; }
                    9518   ; OS_ENTER_CRITICAL();
08002C7E  40E7      9519          dc.w      16615
08002C80  007C      9520          dc.w      124
08002C82  0700      9521          dc.w      1792
                    9522   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
08002C84  2042      9523          move.l    D2,A0
08002C86  3028 0006 9524          move.w    6(A0),D0
08002C8A  E048      9525          lsr.w     #8,D0
08002C8C  1800      9526          move.b    D0,D4
                    9527   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
08002C8E  2042      9528          move.l    D2,A0
08002C90  3028 0006 9529          move.w    6(A0),D0
08002C94  C07C 00FF 9530          and.w     #255,D0
08002C98  1600      9531          move.b    D0,D3
                    9532   ; if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
08002C9A  2042      9533          move.l    D2,A0
08002C9C  2012      9534          move.l    (A2),D0
08002C9E  B0A8 0002 9535          cmp.l     2(A0),D0
08002CA2  6708      9536          beq.s     OSMutexPost_6
                    9537   ; OS_EXIT_CRITICAL();
08002CA4  46DF      9538          dc.w      18143
                    9539   ; return (OS_ERR_NOT_MUTEX_OWNER);
08002CA6  7064      9540          moveq     #100,D0
08002CA8  6000 00B8 9541          bra       OSMutexPost_3
                    9542   OSMutexPost_6:
                    9543   ; }
                    9544   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
08002CAC  0C04 00FF 9545          cmp.b     #255,D4
08002CB0  6732      9546          beq.s     OSMutexPost_8
                    9547   ; if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
08002CB2  2052      9548          move.l    (A2),A0
08002CB4  B828 0034 9549          cmp.b     52(A0),D4
08002CB8  6612      9550          bne.s     OSMutexPost_10
                    9551   ; OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
08002CBA  C6BC 0000 9552          and.l     #255,D3
08002CBE  00FF      
08002CC0  2F03      9553          move.l    D3,-(A7)
08002CC2  2F12      9554          move.l    (A2),-(A7)
08002CC4  4EB9 0800 9555          jsr       @ucos_ii_OSMutex_RdyAtPrio
08002CC8  2E1C      
08002CCA  504F      9556          addq.w    #8,A7
                    9557   OSMutexPost_10:
                    9558   ; }
                    9559   ; OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
08002CCC  C8BC 0000 9560          and.l     #255,D4
08002CD0  00FF      
08002CD2  2004      9561          move.l    D4,D0
08002CD4  E588      9562          lsl.l     #2,D0
08002CD6  41F9 0800 9563          lea       _OSTCBPrioTbl.L,A0
08002CDA  043C      
08002CDC  21BC 0000 9564          move.l    #1,0(A0,D0.L)
08002CE0  0001 0800 
                    9565   OSMutexPost_8:
                    9566   ; }
                    9567   ; if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
08002CE4  2042      9568          move.l    D2,A0
08002CE6  1028 0008 9569          move.b    8(A0),D0
08002CEA  6700 0064 9570          beq       OSMutexPost_12
                    9571   ; /* Yes, Make HPT waiting for mutex ready         */
                    9572   ; prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
08002CEE  42A7      9573          clr.l     -(A7)
08002CF0  4878 0010 9574          pea       16
08002CF4  42A7      9575          clr.l     -(A7)
08002CF6  2F02      9576          move.l    D2,-(A7)
08002CF8  4EB9 0800 9577          jsr       _OS_EventTaskRdy
08002CFC  09AA      
08002CFE  DEFC 0010 9578          add.w     #16,A7
08002D02  1600      9579          move.b    D0,D3
                    9580   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
08002D04  2042      9581          move.l    D2,A0
08002D06  0268 FF00 9582          and.w     #65280,6(A0)
08002D0A  0006      
                    9583   ; pevent->OSEventCnt |= prio;
08002D0C  2042      9584          move.l    D2,A0
08002D0E  C67C 00FF 9585          and.w     #255,D3
08002D12  8768 0006 9586          or.w      D3,6(A0)
                    9587   ; pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
08002D16  C6BC 0000 9588          and.l     #255,D3
08002D1A  00FF      
08002D1C  2003      9589          move.l    D3,D0
08002D1E  E588      9590          lsl.l     #2,D0
08002D20  41F9 0800 9591          lea       _OSTCBPrioTbl.L,A0
08002D24  043C      
08002D26  2242      9592          move.l    D2,A1
08002D28  2370 0800 9593          move.l    0(A0,D0.L),2(A1)
08002D2C  0002      
                    9594   ; if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
08002D2E  0C04 00FF 9595          cmp.b     #255,D4
08002D32  6710      9596          beq.s     OSMutexPost_14
08002D34  B604      9597          cmp.b     D4,D3
08002D36  620C      9598          bhi.s     OSMutexPost_14
                    9599   ; (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
                    9600   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
08002D38  46DF      9601          dc.w      18143
                    9602   ; OS_Sched();                               /*      Find highest priority task ready to run  */
08002D3A  4EB9 0800 9603          jsr       _OS_Sched
08002D3E  0F8A      
                    9604   ; return (OS_ERR_PCP_LOWER);
08002D40  7078      9605          moveq     #120,D0
08002D42  601E      9606          bra.s     OSMutexPost_3
                    9607   OSMutexPost_14:
                    9608   ; } else {
                    9609   ; OS_EXIT_CRITICAL();
08002D44  46DF      9610          dc.w      18143
                    9611   ; OS_Sched();                               /*      Find highest priority task ready to run  */
08002D46  4EB9 0800 9612          jsr       _OS_Sched
08002D4A  0F8A      
                    9613   ; return (OS_ERR_NONE);
08002D4C  4200      9614          clr.b     D0
08002D4E  6012      9615          bra.s     OSMutexPost_3
                    9616   OSMutexPost_12:
                    9617   ; }
                    9618   ; }
                    9619   ; pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
08002D50  2042      9620          move.l    D2,A0
08002D52  0068 00FF 9621          or.w      #255,6(A0)
08002D56  0006      
                    9622   ; pevent->OSEventPtr  = (void *)0;
08002D58  2042      9623          move.l    D2,A0
08002D5A  42A8 0002 9624          clr.l     2(A0)
                    9625   ; OS_EXIT_CRITICAL();
08002D5E  46DF      9626          dc.w      18143
                    9627   ; return (OS_ERR_NONE);
08002D60  4200      9628          clr.b     D0
                    9629   OSMutexPost_3:
08002D62  4CDF 041C 9630          movem.l   (A7)+,D2/D3/D4/A2
08002D66  4E5E      9631          unlk      A6
08002D68  4E75      9632          rts
                    9633   ; }
                    9634   ; /*$PAGE*/
                    9635   ; /*
                    9636   ; *********************************************************************************************************
                    9637   ; *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
                    9638   ; *
                    9639   ; * Description: This function obtains information about a mutex
                    9640   ; *
                    9641   ; * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
                    9642   ; *
                    9643   ; *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
                    9644   ; *
                    9645   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    9646   ; *              OS_ERR_QUERY_ISR     If you called this function from an ISR
                    9647   ; *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
                    9648   ; *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
                    9649   ; *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
                    9650   ; *********************************************************************************************************
                    9651   ; */
                    9652   ; #if OS_MUTEX_QUERY_EN > 0u
                    9653   ; INT8U  OSMutexQuery (OS_EVENT       *pevent,
                    9654   ; OS_MUTEX_DATA  *p_mutex_data)
                    9655   ; {
                    9656   _OSMutexQuery:
08002D6A  4E56 FFF8 9657          link      A6,#-8
08002D6E  48E7 3800 9658          movem.l   D2/D3/D4,-(A7)
08002D72  242E 000C 9659          move.l    12(A6),D2
08002D76  262E 0008 9660          move.l    8(A6),D3
                    9661   ; INT8U       i;
                    9662   ; OS_PRIO    *psrc;
                    9663   ; OS_PRIO    *pdest;
                    9664   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9665   ; OS_CPU_SR   cpu_sr = 0u;
                    9666   ; #endif
                    9667   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
08002D7A  1039 0800 9668          move.b    _OSIntNesting.L,D0
08002D7E  0312      
08002D80  0C00 0000 9669          cmp.b     #0,D0
08002D84  6306      9670          bls.s     OSMutexQuery_1
                    9671   ; return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
08002D86  7006      9672          moveq     #6,D0
08002D88  6000 008A 9673          bra       OSMutexQuery_3
                    9674   OSMutexQuery_1:
                    9675   ; }
                    9676   ; #if OS_ARG_CHK_EN > 0u
                    9677   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9678   ; return (OS_ERR_PEVENT_NULL);
                    9679   ; }
                    9680   ; if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
                    9681   ; return (OS_ERR_PDATA_NULL);
                    9682   ; }
                    9683   ; #endif
                    9684   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
08002D8C  2043      9685          move.l    D3,A0
08002D8E  1010      9686          move.b    (A0),D0
08002D90  0C00 0004 9687          cmp.b     #4,D0
08002D94  6706      9688          beq.s     OSMutexQuery_4
                    9689   ; return (OS_ERR_EVENT_TYPE);
08002D96  7001      9690          moveq     #1,D0
08002D98  6000 007A 9691          bra       OSMutexQuery_3
                    9692   OSMutexQuery_4:
                    9693   ; }
                    9694   ; OS_ENTER_CRITICAL();
08002D9C  40E7      9695          dc.w      16615
08002D9E  007C      9696          dc.w      124
08002DA0  0700      9697          dc.w      1792
                    9698   ; p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
08002DA2  2043      9699          move.l    D3,A0
08002DA4  3028 0006 9700          move.w    6(A0),D0
08002DA8  E048      9701          lsr.w     #8,D0
08002DAA  2042      9702          move.l    D2,A0
08002DAC  1140 000B 9703          move.b    D0,11(A0)
                    9704   ; p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
08002DB0  2043      9705          move.l    D3,A0
08002DB2  3028 0006 9706          move.w    6(A0),D0
08002DB6  C07C 00FF 9707          and.w     #255,D0
08002DBA  2042      9708          move.l    D2,A0
08002DBC  1140 000A 9709          move.b    D0,10(A0)
                    9710   ; if (p_mutex_data->OSOwnerPrio == 0xFFu) {
08002DC0  2042      9711          move.l    D2,A0
08002DC2  1028 000A 9712          move.b    10(A0),D0
08002DC6  0C00 00FF 9713          cmp.b     #255,D0
08002DCA  660A      9714          bne.s     OSMutexQuery_6
                    9715   ; p_mutex_data->OSValue = OS_TRUE;
08002DCC  2042      9716          move.l    D2,A0
08002DCE  117C 0001 9717          move.b    #1,9(A0)
08002DD2  0009      
08002DD4  6006      9718          bra.s     OSMutexQuery_7
                    9719   OSMutexQuery_6:
                    9720   ; } else {
                    9721   ; p_mutex_data->OSValue = OS_FALSE;
08002DD6  2042      9722          move.l    D2,A0
08002DD8  4228 0009 9723          clr.b     9(A0)
                    9724   OSMutexQuery_7:
                    9725   ; }
                    9726   ; p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
08002DDC  2043      9727          move.l    D3,A0
08002DDE  2242      9728          move.l    D2,A1
08002DE0  1368 0008 9729          move.b    8(A0),8(A1)
08002DE4  0008      
                    9730   ; psrc                      = &pevent->OSEventTbl[0];
08002DE6  700A      9731          moveq     #10,D0
08002DE8  D083      9732          add.l     D3,D0
08002DEA  2D40 FFF8 9733          move.l    D0,-8(A6)
                    9734   ; pdest                     = &p_mutex_data->OSEventTbl[0];
08002DEE  2D42 FFFC 9735          move.l    D2,-4(A6)
                    9736   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
08002DF2  4204      9737          clr.b     D4
                    9738   OSMutexQuery_8:
08002DF4  0C04 0008 9739          cmp.b     #8,D4
08002DF8  6416      9740          bhs.s     OSMutexQuery_10
                    9741   ; *pdest++ = *psrc++;
08002DFA  206E FFF8 9742          move.l    -8(A6),A0
08002DFE  52AE FFF8 9743          addq.l    #1,-8(A6)
08002E02  226E FFFC 9744          move.l    -4(A6),A1
08002E06  52AE FFFC 9745          addq.l    #1,-4(A6)
08002E0A  1290      9746          move.b    (A0),(A1)
08002E0C  5204      9747          addq.b    #1,D4
08002E0E  60E4      9748          bra       OSMutexQuery_8
                    9749   OSMutexQuery_10:
                    9750   ; }
                    9751   ; OS_EXIT_CRITICAL();
08002E10  46DF      9752          dc.w      18143
                    9753   ; return (OS_ERR_NONE);
08002E12  4200      9754          clr.b     D0
                    9755   OSMutexQuery_3:
08002E14  4CDF 001C 9756          movem.l   (A7)+,D2/D3/D4
08002E18  4E5E      9757          unlk      A6
08002E1A  4E75      9758          rts
                    9759   ; }
                    9760   ; #endif                                                     /* OS_MUTEX_QUERY_EN                        */
                    9761   ; /*$PAGE*/
                    9762   ; /*
                    9763   ; *********************************************************************************************************
                    9764   ; *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
                    9765   ; *
                    9766   ; * Description: This function makes a task ready at the specified priority
                    9767   ; *
                    9768   ; * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
                    9769   ; *
                    9770   ; *              prio            is the desired priority
                    9771   ; *
                    9772   ; * Returns    : none
                    9773   ; *********************************************************************************************************
                    9774   ; */
                    9775   ; static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
                    9776   ; INT8U    prio)
                    9777   ; {
                    9778   @ucos_ii_OSMutex_RdyAtPrio:
08002E1C  4E56 0000 9779          link      A6,#0
08002E20  48E7 3820 9780          movem.l   D2/D3/D4/A2,-(A7)
08002E24  242E 0008 9781          move.l    8(A6),D2
08002E28  162E 000F 9782          move.b    15(A6),D3
08002E2C  C6BC 0000 9783          and.l     #255,D3
08002E30  00FF      
08002E32  45F9 0800 9784          lea       _OSRdyTbl.L,A2
08002E36  031C      
                    9785   ; INT8U  y;
                    9786   ; y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
08002E38  2042      9787          move.l    D2,A0
08002E3A  1828 0036 9788          move.b    54(A0),D4
                    9789   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
08002E3E  C8BC 0000 9790          and.l     #255,D4
08002E42  00FF      
08002E44  2042      9791          move.l    D2,A0
08002E46  1028 0037 9792          move.b    55(A0),D0
08002E4A  4600      9793          not.b     D0
08002E4C  C132 4800 9794          and.b     D0,0(A2,D4.L)
                    9795   ; if (OSRdyTbl[y] == 0u) {
08002E50  C8BC 0000 9796          and.l     #255,D4
08002E54  00FF      
08002E56  1032 4800 9797          move.b    0(A2,D4.L),D0
08002E5A  660E      9798          bne.s     @ucos_ii_OSMutex_RdyAtPrio_1
                    9799   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
08002E5C  2042      9800          move.l    D2,A0
08002E5E  1028 0038 9801          move.b    56(A0),D0
08002E62  4600      9802          not.b     D0
08002E64  C139 0800 9803          and.b     D0,_OSRdyGrp.L
08002E68  031A      
                    9804   @ucos_ii_OSMutex_RdyAtPrio_1:
                    9805   ; }
                    9806   ; ptcb->OSTCBPrio         = prio;
08002E6A  2042      9807          move.l    D2,A0
08002E6C  1143 0034 9808          move.b    D3,52(A0)
                    9809   ; OSPrioCur               = prio;                        /* The current task is now at this priority */
08002E70  13C3 0800 9810          move.b    D3,_OSPrioCur.L
08002E74  0316      
                    9811   ; #if OS_LOWEST_PRIO <= 63u
                    9812   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
08002E76  1003      9813          move.b    D3,D0
08002E78  E608      9814          lsr.b     #3,D0
08002E7A  C03C 0007 9815          and.b     #7,D0
08002E7E  2042      9816          move.l    D2,A0
08002E80  1140 0036 9817          move.b    D0,54(A0)
                    9818   ; ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
08002E84  1003      9819          move.b    D3,D0
08002E86  C03C 0007 9820          and.b     #7,D0
08002E8A  2042      9821          move.l    D2,A0
08002E8C  1140 0035 9822          move.b    D0,53(A0)
                    9823   ; #else
                    9824   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
                    9825   ; ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
                    9826   ; #endif
                    9827   ; ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
08002E90  7001      9828          moveq     #1,D0
08002E92  2042      9829          move.l    D2,A0
08002E94  1228 0036 9830          move.b    54(A0),D1
08002E98  C2BC 0000 9831          and.l     #255,D1
08002E9C  00FF      
08002E9E  E3A8      9832          lsl.l     D1,D0
08002EA0  2042      9833          move.l    D2,A0
08002EA2  1140 0038 9834          move.b    D0,56(A0)
                    9835   ; ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
08002EA6  7001      9836          moveq     #1,D0
08002EA8  2042      9837          move.l    D2,A0
08002EAA  1228 0035 9838          move.b    53(A0),D1
08002EAE  C2BC 0000 9839          and.l     #255,D1
08002EB2  00FF      
08002EB4  E3A8      9840          lsl.l     D1,D0
08002EB6  2042      9841          move.l    D2,A0
08002EB8  1140 0037 9842          move.b    D0,55(A0)
                    9843   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
08002EBC  2042      9844          move.l    D2,A0
08002EBE  1028 0038 9845          move.b    56(A0),D0
08002EC2  8139 0800 9846          or.b      D0,_OSRdyGrp.L
08002EC6  031A      
                    9847   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
08002EC8  2042      9848          move.l    D2,A0
08002ECA  1028 0036 9849          move.b    54(A0),D0
08002ECE  C0BC 0000 9850          and.l     #255,D0
08002ED2  00FF      
08002ED4  2042      9851          move.l    D2,A0
08002ED6  1228 0037 9852          move.b    55(A0),D1
08002EDA  8332 0800 9853          or.b      D1,0(A2,D0.L)
                    9854   ; OSTCBPrioTbl[prio]      = ptcb;
08002EDE  C6BC 0000 9855          and.l     #255,D3
08002EE2  00FF      
08002EE4  2003      9856          move.l    D3,D0
08002EE6  E588      9857          lsl.l     #2,D0
08002EE8  41F9 0800 9858          lea       _OSTCBPrioTbl.L,A0
08002EEC  043C      
08002EEE  2182 0800 9859          move.l    D2,0(A0,D0.L)
08002EF2  4CDF 041C 9860          movem.l   (A7)+,D2/D3/D4/A2
08002EF6  4E5E      9861          unlk      A6
08002EF8  4E75      9862          rts
                    9863   ; /*
                    9864   ; *********************************************************************************************************
                    9865   ; *                                                uC/OS-II
                    9866   ; *                                          The Real-Time Kernel
                    9867   ; *                                        MESSAGE QUEUE MANAGEMENT
                    9868   ; *
                    9869   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    9870   ; *                                           All Rights Reserved
                    9871   ; *
                    9872   ; * File    : OS_Q.C
                    9873   ; * By      : Jean J. Labrosse
                    9874   ; * Version : V2.92.07
                    9875   ; *
                    9876   ; * LICENSING TERMS:
                    9877   ; * ---------------
                    9878   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    9879   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    9880   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    9881   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    9882   ; * licensing fee.
                    9883   ; *********************************************************************************************************
                    9884   ; */
                    9885   ; #define  MICRIUM_SOURCE
                    9886   ; #ifndef  OS_MASTER_FILE
                    9887   ; #include <ucos_ii.h>
                    9888   ; #endif
                    9889   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    9890   ; /*
                    9891   ; *********************************************************************************************************
                    9892   ; *                                      ACCEPT MESSAGE FROM QUEUE
                    9893   ; *
                    9894   ; * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
                    9895   ; *              OSQAccept() does not suspend the calling task if a message is not available.
                    9896   ; *
                    9897   ; * Arguments  : pevent        is a pointer to the event control block
                    9898   ; *
                    9899   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9900   ; *                            messages are:
                    9901   ; *
                    9902   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    9903   ; *                                                message.
                    9904   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    9905   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    9906   ; *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
                    9907   ; *
                    9908   ; * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
                    9909   ; *                            from the so the next time OSQAccept() is called, the queue will contain
                    9910   ; *                            one less entry.
                    9911   ; *              == (void *)0  if you received a NULL pointer message
                    9912   ; *                            if the queue is empty or,
                    9913   ; *                            if 'pevent' is a NULL pointer or,
                    9914   ; *                            if you passed an invalid event type
                    9915   ; *
                    9916   ; * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
                    9917   ; *              'perr' has been added to the API to tell you about the outcome of the call.
                    9918   ; *********************************************************************************************************
                    9919   ; */
                    9920   ; #if OS_Q_ACCEPT_EN > 0u
                    9921   ; void  *OSQAccept (OS_EVENT  *pevent,
                    9922   ; INT8U     *perr)
                    9923   ; {
                    9924   _OSQAccept:
08002EFA  4E56 0000 9925          link      A6,#0
08002EFE  48E7 3800 9926          movem.l   D2/D3/D4,-(A7)
08002F02  282E 000C 9927          move.l    12(A6),D4
                    9928   ; void      *pmsg;
                    9929   ; OS_Q      *pq;
                    9930   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9931   ; OS_CPU_SR  cpu_sr = 0u;
                    9932   ; #endif
                    9933   ; #ifdef OS_SAFETY_CRITICAL
                    9934   ; if (perr == (INT8U *)0) {
                    9935   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9936   ; return ((void *)0);
                    9937   ; }
                    9938   ; #endif
                    9939   ; #if OS_ARG_CHK_EN > 0u
                    9940   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    9941   ; *perr = OS_ERR_PEVENT_NULL;
                    9942   ; return ((void *)0);
                    9943   ; }
                    9944   ; #endif
                    9945   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
08002F06  206E 0008 9946          move.l    8(A6),A0
08002F0A  1010      9947          move.b    (A0),D0
08002F0C  0C00 0002 9948          cmp.b     #2,D0
08002F10  670C      9949          beq.s     OSQAccept_1
                    9950   ; *perr = OS_ERR_EVENT_TYPE;
08002F12  2044      9951          move.l    D4,A0
08002F14  10BC 0001 9952          move.b    #1,(A0)
                    9953   ; return ((void *)0);
08002F18  4280      9954          clr.l     D0
08002F1A  6000 0064 9955          bra       OSQAccept_3
                    9956   OSQAccept_1:
                    9957   ; }
                    9958   ; OS_ENTER_CRITICAL();
08002F1E  40E7      9959          dc.w      16615
08002F20  007C      9960          dc.w      124
08002F22  0700      9961          dc.w      1792
                    9962   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
08002F24  206E 0008 9963          move.l    8(A6),A0
08002F28  2428 0002 9964          move.l    2(A0),D2
                    9965   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
08002F2C  2042      9966          move.l    D2,A0
08002F2E  3028 0016 9967          move.w    22(A0),D0
08002F32  0C40 0000 9968          cmp.w     #0,D0
08002F36  6300 003C 9969          bls       OSQAccept_4
                    9970   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
08002F3A  2002      9971          move.l    D2,D0
08002F3C  0680 0000 9972          add.l     #16,D0
08002F40  0010      
08002F42  2040      9973          move.l    D0,A0
08002F44  2250      9974          move.l    (A0),A1
08002F46  5890      9975          addq.l    #4,(A0)
08002F48  2611      9976          move.l    (A1),D3
                    9977   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
08002F4A  2002      9978          move.l    D2,D0
08002F4C  0680 0000 9979          add.l     #22,D0
08002F50  0016      
08002F52  2040      9980          move.l    D0,A0
08002F54  5350      9981          subq.w    #1,(A0)
                    9982   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
08002F56  2042      9983          move.l    D2,A0
08002F58  2242      9984          move.l    D2,A1
08002F5A  2028 0010 9985          move.l    16(A0),D0
08002F5E  B0A9 0008 9986          cmp.l     8(A1),D0
08002F62  660A      9987          bne.s     OSQAccept_6
                    9988   ; pq->OSQOut = pq->OSQStart;
08002F64  2042      9989          move.l    D2,A0
08002F66  2242      9990          move.l    D2,A1
08002F68  2368 0004 9991          move.l    4(A0),16(A1)
08002F6C  0010      
                    9992   OSQAccept_6:
                    9993   ; }
                    9994   ; *perr = OS_ERR_NONE;
08002F6E  2044      9995          move.l    D4,A0
08002F70  4210      9996          clr.b     (A0)
08002F72  6008      9997          bra.s     OSQAccept_5
                    9998   OSQAccept_4:
                    9999   ; } else {
                    10000   ; *perr = OS_ERR_Q_EMPTY;
08002F74  2044      10001          move.l    D4,A0
08002F76  10BC 001F 10002          move.b    #31,(A0)
                    10003   ; pmsg  = (void *)0;                       /* Queue is empty                                     */
08002F7A  4283      10004          clr.l     D3
                    10005   OSQAccept_5:
                    10006   ; }
                    10007   ; OS_EXIT_CRITICAL();
08002F7C  46DF      10008          dc.w      18143
                    10009   ; return (pmsg);                               /* Return message received (or NULL)                  */
08002F7E  2003      10010          move.l    D3,D0
                    10011   OSQAccept_3:
08002F80  4CDF 001C 10012          movem.l   (A7)+,D2/D3/D4
08002F84  4E5E      10013          unlk      A6
08002F86  4E75      10014          rts
                    10015   ; }
                    10016   ; #endif
                    10017   ; /*$PAGE*/
                    10018   ; /*
                    10019   ; *********************************************************************************************************
                    10020   ; *                                       CREATE A MESSAGE QUEUE
                    10021   ; *
                    10022   ; * Description: This function creates a message queue if free event control blocks are available.
                    10023   ; *
                    10024   ; * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
                    10025   ; *                            storage area MUST be declared as an array of pointers to 'void' as follows
                    10026   ; *
                    10027   ; *                            void *MessageStorage[size]
                    10028   ; *
                    10029   ; *              size          is the number of elements in the storage area
                    10030   ; *
                    10031   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    10032   ; *                                created queue
                    10033   ; *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
                    10034   ; *********************************************************************************************************
                    10035   ; */
                    10036   ; OS_EVENT  *OSQCreate (void    **start,
                    10037   ; INT16U    size)
                    10038   ; {
                    10039   _OSQCreate:
08002F88  4E56 0000 10040          link      A6,#0
08002F8C  48E7 3830 10041          movem.l   D2/D3/D4/A2/A3,-(A7)
08002F90  45F9 0800 10042          lea       _OSEventFreeList.L,A2
08002F94  00E6      
08002F96  282E 0008 10043          move.l    8(A6),D4
08002F9A  47F9 0800 10044          lea       _OSQFreeList.L,A3
08002F9E  0D1C      
                    10045   ; OS_EVENT  *pevent;
                    10046   ; OS_Q      *pq;
                    10047   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10048   ; OS_CPU_SR  cpu_sr = 0u;
                    10049   ; #endif
                    10050   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    10051   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    10052   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10053   ; return ((OS_EVENT *)0);
                    10054   ; }
                    10055   ; #endif
                    10056   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
08002FA0  1039 0800 10057          move.b    _OSIntNesting.L,D0
08002FA4  0312      
08002FA6  0C00 0000 10058          cmp.b     #0,D0
08002FAA  6306      10059          bls.s     OSQCreate_1
                    10060   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
08002FAC  4280      10061          clr.l     D0
08002FAE  6000 009E 10062          bra       OSQCreate_3
                    10063   OSQCreate_1:
                    10064   ; }
                    10065   ; OS_ENTER_CRITICAL();
08002FB2  40E7      10066          dc.w      16615
08002FB4  007C      10067          dc.w      124
08002FB6  0700      10068          dc.w      1792
                    10069   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
08002FB8  2412      10070          move.l    (A2),D2
                    10071   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
08002FBA  2012      10072          move.l    (A2),D0
08002FBC  6706      10073          beq.s     OSQCreate_4
                    10074   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
08002FBE  2052      10075          move.l    (A2),A0
08002FC0  24A8 0002 10076          move.l    2(A0),(A2)
                    10077   OSQCreate_4:
                    10078   ; }
                    10079   ; OS_EXIT_CRITICAL();
08002FC4  46DF      10080          dc.w      18143
                    10081   ; if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
08002FC6  4A82      10082          tst.l     D2
08002FC8  6700 0082 10083          beq       OSQCreate_9
                    10084   ; OS_ENTER_CRITICAL();
08002FCC  40E7      10085          dc.w      16615
08002FCE  007C      10086          dc.w      124
08002FD0  0700      10087          dc.w      1792
                    10088   ; pq = OSQFreeList;                        /* Get a free queue control block                     */
08002FD2  2613      10089          move.l    (A3),D3
                    10090   ; if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
08002FD4  4A83      10091          tst.l     D3
08002FD6  6700 0068 10092          beq       OSQCreate_8
                    10093   ; OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
08002FDA  2053      10094          move.l    (A3),A0
08002FDC  2690      10095          move.l    (A0),(A3)
                    10096   ; OS_EXIT_CRITICAL();
08002FDE  46DF      10097          dc.w      18143
                    10098   ; pq->OSQStart           = start;               /*      Initialize the queue                 */
08002FE0  2043      10099          move.l    D3,A0
08002FE2  2144 0004 10100          move.l    D4,4(A0)
                    10101   ; pq->OSQEnd             = &start[size];
08002FE6  2004      10102          move.l    D4,D0
08002FE8  322E 000E 10103          move.w    14(A6),D1
08002FEC  C2BC 0000 10104          and.l     #65535,D1
08002FF0  FFFF      
08002FF2  E589      10105          lsl.l     #2,D1
08002FF4  D081      10106          add.l     D1,D0
08002FF6  2043      10107          move.l    D3,A0
08002FF8  2140 0008 10108          move.l    D0,8(A0)
                    10109   ; pq->OSQIn              = start;
08002FFC  2043      10110          move.l    D3,A0
08002FFE  2144 000C 10111          move.l    D4,12(A0)
                    10112   ; pq->OSQOut             = start;
08003002  2043      10113          move.l    D3,A0
08003004  2144 0010 10114          move.l    D4,16(A0)
                    10115   ; pq->OSQSize            = size;
08003008  2043      10116          move.l    D3,A0
0800300A  316E 000E 10117          move.w    14(A6),20(A0)
0800300E  0014      
                    10118   ; pq->OSQEntries         = 0u;
08003010  2043      10119          move.l    D3,A0
08003012  4268 0016 10120          clr.w     22(A0)
                    10121   ; pevent->OSEventType    = OS_EVENT_TYPE_Q;
08003016  2042      10122          move.l    D2,A0
08003018  10BC 0002 10123          move.b    #2,(A0)
                    10124   ; pevent->OSEventCnt     = 0u;
0800301C  2042      10125          move.l    D2,A0
0800301E  4268 0006 10126          clr.w     6(A0)
                    10127   ; pevent->OSEventPtr     = pq;
08003022  2042      10128          move.l    D2,A0
08003024  2143 0002 10129          move.l    D3,2(A0)
                    10130   ; #if OS_EVENT_NAME_EN > 0u
                    10131   ; pevent->OSEventName    = (INT8U *)(void *)"?";
08003028  41F9 0800 10132          lea       @ucos_ii_1.L,A0
0800302C  57FE      
0800302E  2242      10133          move.l    D2,A1
08003030  2348 0012 10134          move.l    A0,18(A1)
                    10135   ; #endif
                    10136   ; OS_EventWaitListInit(pevent);                 /*      Initialize the wait list             */
08003034  2F02      10137          move.l    D2,-(A7)
08003036  4EB9 0800 10138          jsr       _OS_EventWaitListInit
0800303A  0C72      
0800303C  584F      10139          addq.w    #4,A7
0800303E  600C      10140          bra.s     OSQCreate_9
                    10141   OSQCreate_8:
                    10142   ; } else {
                    10143   ; pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
08003040  2042      10144          move.l    D2,A0
08003042  2152 0002 10145          move.l    (A2),2(A0)
                    10146   ; OSEventFreeList    = pevent;
08003046  2482      10147          move.l    D2,(A2)
                    10148   ; OS_EXIT_CRITICAL();
08003048  46DF      10149          dc.w      18143
                    10150   ; pevent = (OS_EVENT *)0;
0800304A  4282      10151          clr.l     D2
                    10152   OSQCreate_9:
                    10153   ; }
                    10154   ; }
                    10155   ; return (pevent);
0800304C  2002      10156          move.l    D2,D0
                    10157   OSQCreate_3:
0800304E  4CDF 0C1C 10158          movem.l   (A7)+,D2/D3/D4/A2/A3
08003052  4E5E      10159          unlk      A6
08003054  4E75      10160          rts
                    10161   ; }
                    10162   ; /*$PAGE*/
                    10163   ; /*
                    10164   ; *********************************************************************************************************
                    10165   ; *                                       DELETE A MESSAGE QUEUE
                    10166   ; *
                    10167   ; * Description: This function deletes a message queue and readies all tasks pending on the queue.
                    10168   ; *
                    10169   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    10170   ; *                            queue.
                    10171   ; *
                    10172   ; *              opt           determines delete options as follows:
                    10173   ; *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
                    10174   ; *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
                    10175   ; *                                                    In this case, all the tasks pending will be readied.
                    10176   ; *
                    10177   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    10178   ; *                            OS_ERR_NONE             The call was successful and the queue was deleted
                    10179   ; *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
                    10180   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    10181   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
                    10182   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
                    10183   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    10184   ; *
                    10185   ; * Returns    : pevent        upon error
                    10186   ; *              (OS_EVENT *)0 if the queue was successfully deleted.
                    10187   ; *
                    10188   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    10189   ; *                 the queue MUST check the return code of OSQPend().
                    10190   ; *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
                    10191   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    10192   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    10193   ; *                 time is directly proportional to the number of tasks waiting on the queue.
                    10194   ; *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
                    10195   ; *                 applications where the queue is used for mutual exclusion because the resource(s)
                    10196   ; *                 will no longer be guarded by the queue.
                    10197   ; *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
                    10198   ; *                 type call) then your application MUST release the memory storage by call the counterpart
                    10199   ; *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
                    10200   ; *                 then, the storage can be reused.
                    10201   ; *              6) All tasks that were waiting for the queue will be readied and returned an 
                    10202   ; *                 OS_ERR_PEND_ABORT if OSQDel() was called with OS_DEL_ALWAYS
                    10203   ; *********************************************************************************************************
                    10204   ; */
                    10205   ; #if OS_Q_DEL_EN > 0u
                    10206   ; OS_EVENT  *OSQDel (OS_EVENT  *pevent,
                    10207   ; INT8U      opt,
                    10208   ; INT8U     *perr)
                    10209   ; {
                    10210   _OSQDel:
08003056  4E56 0000 10211          link      A6,#0
0800305A  48E7 3E30 10212          movem.l   D2/D3/D4/D5/D6/A2/A3,-(A7)
0800305E  242E 0008 10213          move.l    8(A6),D2
08003062  282E 0010 10214          move.l    16(A6),D4
08003066  45F9 0800 10215          lea       _OSEventFreeList.L,A2
0800306A  00E6      
0800306C  47F9 0800 10216          lea       _OSQFreeList.L,A3
08003070  0D1C      
                    10217   ; BOOLEAN    tasks_waiting;
                    10218   ; OS_EVENT  *pevent_return;
                    10219   ; OS_Q      *pq;
                    10220   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10221   ; OS_CPU_SR  cpu_sr = 0u;
                    10222   ; #endif
                    10223   ; #ifdef OS_SAFETY_CRITICAL
                    10224   ; if (perr == (INT8U *)0) {
                    10225   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10226   ; return ((OS_EVENT *)0);
                    10227   ; }
                    10228   ; #endif
                    10229   ; #if OS_ARG_CHK_EN > 0u
                    10230   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10231   ; *perr = OS_ERR_PEVENT_NULL;
                    10232   ; return (pevent);
                    10233   ; }
                    10234   ; #endif
                    10235   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
08003072  2042      10236          move.l    D2,A0
08003074  1010      10237          move.b    (A0),D0
08003076  0C00 0002 10238          cmp.b     #2,D0
0800307A  670C      10239          beq.s     OSQDel_1
                    10240   ; *perr = OS_ERR_EVENT_TYPE;
0800307C  2044      10241          move.l    D4,A0
0800307E  10BC 0001 10242          move.b    #1,(A0)
                    10243   ; return (pevent);
08003082  2002      10244          move.l    D2,D0
08003084  6000 0108 10245          bra       OSQDel_3
                    10246   OSQDel_1:
                    10247   ; }
                    10248   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
08003088  1039 0800 10249          move.b    _OSIntNesting.L,D0
0800308C  0312      
0800308E  0C00 0000 10250          cmp.b     #0,D0
08003092  630C      10251          bls.s     OSQDel_4
                    10252   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
08003094  2044      10253          move.l    D4,A0
08003096  10BC 000F 10254          move.b    #15,(A0)
                    10255   ; return (pevent);
0800309A  2002      10256          move.l    D2,D0
0800309C  6000 00F0 10257          bra       OSQDel_3
                    10258   OSQDel_4:
                    10259   ; }
                    10260   ; OS_ENTER_CRITICAL();
080030A0  40E7      10261          dc.w      16615
080030A2  007C      10262          dc.w      124
080030A4  0700      10263          dc.w      1792
                    10264   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
080030A6  2042      10265          move.l    D2,A0
080030A8  1028 0008 10266          move.b    8(A0),D0
080030AC  6704      10267          beq.s     OSQDel_6
                    10268   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
080030AE  7C01      10269          moveq     #1,D6
080030B0  6002      10270          bra.s     OSQDel_7
                    10271   OSQDel_6:
                    10272   ; } else {
                    10273   ; tasks_waiting = OS_FALSE;                          /* No                                       */
080030B2  4206      10274          clr.b     D6
                    10275   OSQDel_7:
                    10276   ; }
                    10277   ; switch (opt) {
080030B4  102E 000F 10278          move.b    15(A6),D0
080030B8  C0BC 0000 10279          and.l     #255,D0
080030BC  00FF      
080030BE  0C80 0000 10280          cmp.l     #1,D0
080030C2  0001      
080030C4  6700 0056 10281          beq       OSQDel_11
080030C8  6200 00B8 10282          bhi       OSQDel_8
080030CC  4A80      10283          tst.l     D0
080030CE  6704      10284          beq.s     OSQDel_10
080030D0  6000 00B0 10285          bra       OSQDel_8
                    10286   OSQDel_10:
                    10287   ; case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
                    10288   ; if (tasks_waiting == OS_FALSE) {
080030D4  4A06      10289          tst.b     D6
080030D6  6600 0036 10290          bne       OSQDel_13
                    10291   ; #if OS_EVENT_NAME_EN > 0u
                    10292   ; pevent->OSEventName    = (INT8U *)(void *)"?";
080030DA  41F9 0800 10293          lea       @ucos_ii_1.L,A0
080030DE  57FE      
080030E0  2242      10294          move.l    D2,A1
080030E2  2348 0012 10295          move.l    A0,18(A1)
                    10296   ; #endif
                    10297   ; pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
080030E6  2042      10298          move.l    D2,A0
080030E8  2628 0002 10299          move.l    2(A0),D3
                    10300   ; pq->OSQPtr             = OSQFreeList;
080030EC  2043      10301          move.l    D3,A0
080030EE  2093      10302          move.l    (A3),(A0)
                    10303   ; OSQFreeList            = pq;
080030F0  2683      10304          move.l    D3,(A3)
                    10305   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
080030F2  2042      10306          move.l    D2,A0
080030F4  4210      10307          clr.b     (A0)
                    10308   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
080030F6  2042      10309          move.l    D2,A0
080030F8  2152 0002 10310          move.l    (A2),2(A0)
                    10311   ; pevent->OSEventCnt     = 0u;
080030FC  2042      10312          move.l    D2,A0
080030FE  4268 0006 10313          clr.w     6(A0)
                    10314   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
08003102  2482      10315          move.l    D2,(A2)
                    10316   ; OS_EXIT_CRITICAL();
08003104  46DF      10317          dc.w      18143
                    10318   ; *perr                  = OS_ERR_NONE;
08003106  2044      10319          move.l    D4,A0
08003108  4210      10320          clr.b     (A0)
                    10321   ; pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
0800310A  4285      10322          clr.l     D5
0800310C  600A      10323          bra.s     OSQDel_14
                    10324   OSQDel_13:
                    10325   ; } else {
                    10326   ; OS_EXIT_CRITICAL();
0800310E  46DF      10327          dc.w      18143
                    10328   ; *perr                  = OS_ERR_TASK_WAITING;
08003110  2044      10329          move.l    D4,A0
08003112  10BC 0049 10330          move.b    #73,(A0)
                    10331   ; pevent_return          = pevent;
08003116  2A02      10332          move.l    D2,D5
                    10333   OSQDel_14:
                    10334   ; }
                    10335   ; break;
08003118  6000 0072 10336          bra       OSQDel_9
                    10337   OSQDel_11:
                    10338   ; case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
                    10339   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                    10340   OSQDel_15:
0800311C  2042      10341          move.l    D2,A0
0800311E  1028 0008 10342          move.b    8(A0),D0
08003122  671E      10343          beq.s     OSQDel_17
                    10344   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
08003124  4878 0002 10345          pea       2
08003128  4878 0004 10346          pea       4
0800312C  42A7      10347          clr.l     -(A7)
0800312E  2F02      10348          move.l    D2,-(A7)
08003130  4EB9 0800 10349          jsr       _OS_EventTaskRdy
08003134  09AA      
08003136  DEFC 0010 10350          add.w     #16,A7
0800313A  C0BC 0000 10351          and.l     #255,D0
0800313E  00FF      
08003140  60DA      10352          bra       OSQDel_15
                    10353   OSQDel_17:
                    10354   ; }
                    10355   ; #if OS_EVENT_NAME_EN > 0u
                    10356   ; pevent->OSEventName    = (INT8U *)(void *)"?";
08003142  41F9 0800 10357          lea       @ucos_ii_1.L,A0
08003146  57FE      
08003148  2242      10358          move.l    D2,A1
0800314A  2348 0012 10359          move.l    A0,18(A1)
                    10360   ; #endif
                    10361   ; pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
0800314E  2042      10362          move.l    D2,A0
08003150  2628 0002 10363          move.l    2(A0),D3
                    10364   ; pq->OSQPtr             = OSQFreeList;
08003154  2043      10365          move.l    D3,A0
08003156  2093      10366          move.l    (A3),(A0)
                    10367   ; OSQFreeList            = pq;
08003158  2683      10368          move.l    D3,(A3)
                    10369   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
0800315A  2042      10370          move.l    D2,A0
0800315C  4210      10371          clr.b     (A0)
                    10372   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
0800315E  2042      10373          move.l    D2,A0
08003160  2152 0002 10374          move.l    (A2),2(A0)
                    10375   ; pevent->OSEventCnt     = 0u;
08003164  2042      10376          move.l    D2,A0
08003166  4268 0006 10377          clr.w     6(A0)
                    10378   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
0800316A  2482      10379          move.l    D2,(A2)
                    10380   ; OS_EXIT_CRITICAL();
0800316C  46DF      10381          dc.w      18143
                    10382   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0800316E  0C06 0001 10383          cmp.b     #1,D6
08003172  6606      10384          bne.s     OSQDel_18
                    10385   ; OS_Sched();                               /* Find highest priority task ready to run  */
08003174  4EB9 0800 10386          jsr       _OS_Sched
08003178  0F8A      
                    10387   OSQDel_18:
                    10388   ; }
                    10389   ; *perr                  = OS_ERR_NONE;
0800317A  2044      10390          move.l    D4,A0
0800317C  4210      10391          clr.b     (A0)
                    10392   ; pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
0800317E  4285      10393          clr.l     D5
                    10394   ; break;
08003180  600A      10395          bra.s     OSQDel_9
                    10396   OSQDel_8:
                    10397   ; default:
                    10398   ; OS_EXIT_CRITICAL();
08003182  46DF      10399          dc.w      18143
                    10400   ; *perr                  = OS_ERR_INVALID_OPT;
08003184  2044      10401          move.l    D4,A0
08003186  10BC 0007 10402          move.b    #7,(A0)
                    10403   ; pevent_return          = pevent;
0800318A  2A02      10404          move.l    D2,D5
                    10405   ; break;
                    10406   OSQDel_9:
                    10407   ; }
                    10408   ; return (pevent_return);
0800318C  2005      10409          move.l    D5,D0
                    10410   OSQDel_3:
0800318E  4CDF 0C7C 10411          movem.l   (A7)+,D2/D3/D4/D5/D6/A2/A3
08003192  4E5E      10412          unlk      A6
08003194  4E75      10413          rts
                    10414   ; }
                    10415   ; #endif
                    10416   ; /*$PAGE*/
                    10417   ; /*
                    10418   ; *********************************************************************************************************
                    10419   ; *                                             FLUSH QUEUE
                    10420   ; *
                    10421   ; * Description : This function is used to flush the contents of the message queue.
                    10422   ; *
                    10423   ; * Arguments   : none
                    10424   ; *
                    10425   ; * Returns     : OS_ERR_NONE         upon success
                    10426   ; *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
                    10427   ; *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10428   ; *
                    10429   ; * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
                    10430   ; *               the references to what the queue entries are pointing to and thus, you could cause
                    10431   ; *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
                    10432   ; *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
                    10433   ; *********************************************************************************************************
                    10434   ; */
                    10435   ; #if OS_Q_FLUSH_EN > 0u
                    10436   ; INT8U  OSQFlush (OS_EVENT *pevent)
                    10437   ; {
                    10438   _OSQFlush:
08003196  4E56 0000 10439          link      A6,#0
0800319A  2F02      10440          move.l    D2,-(A7)
                    10441   ; OS_Q      *pq;
                    10442   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10443   ; OS_CPU_SR  cpu_sr = 0u;
                    10444   ; #endif
                    10445   ; #if OS_ARG_CHK_EN > 0u
                    10446   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10447   ; return (OS_ERR_PEVENT_NULL);
                    10448   ; }
                    10449   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                    10450   ; return (OS_ERR_EVENT_TYPE);
                    10451   ; }
                    10452   ; #endif
                    10453   ; OS_ENTER_CRITICAL();
0800319C  40E7      10454          dc.w      16615
0800319E  007C      10455          dc.w      124
080031A0  0700      10456          dc.w      1792
                    10457   ; pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
080031A2  206E 0008 10458          move.l    8(A6),A0
080031A6  2428 0002 10459          move.l    2(A0),D2
                    10460   ; pq->OSQIn      = pq->OSQStart;
080031AA  2042      10461          move.l    D2,A0
080031AC  2242      10462          move.l    D2,A1
080031AE  2368 0004 10463          move.l    4(A0),12(A1)
080031B2  000C      
                    10464   ; pq->OSQOut     = pq->OSQStart;
080031B4  2042      10465          move.l    D2,A0
080031B6  2242      10466          move.l    D2,A1
080031B8  2368 0004 10467          move.l    4(A0),16(A1)
080031BC  0010      
                    10468   ; pq->OSQEntries = 0u;
080031BE  2042      10469          move.l    D2,A0
080031C0  4268 0016 10470          clr.w     22(A0)
                    10471   ; OS_EXIT_CRITICAL();
080031C4  46DF      10472          dc.w      18143
                    10473   ; return (OS_ERR_NONE);
080031C6  4200      10474          clr.b     D0
080031C8  241F      10475          move.l    (A7)+,D2
080031CA  4E5E      10476          unlk      A6
080031CC  4E75      10477          rts
                    10478   ; }
                    10479   ; #endif
                    10480   ; /*$PAGE*/
                    10481   ; /*
                    10482   ; *********************************************************************************************************
                    10483   ; *                                    PEND ON A QUEUE FOR A MESSAGE
                    10484   ; *
                    10485   ; * Description: This function waits for a message to be sent to a queue
                    10486   ; *
                    10487   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10488   ; *
                    10489   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    10490   ; *                            wait for a message to arrive at the queue up to the amount of time
                    10491   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    10492   ; *                            forever at the specified queue or, until a message arrives.
                    10493   ; *
                    10494   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10495   ; *                            messages are:
                    10496   ; *
                    10497   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10498   ; *                                                message.
                    10499   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    10500   ; *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
                    10501   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10502   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10503   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    10504   ; *                                                would lead to a suspension.
                    10505   ; *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
                    10506   ; *
                    10507   ; * Returns    : != (void *)0  is a pointer to the message received
                    10508   ; *              == (void *)0  if you received a NULL pointer message or,
                    10509   ; *                            if no message was received or,
                    10510   ; *                            if 'pevent' is a NULL pointer or,
                    10511   ; *                            if you didn't pass a pointer to a queue.
                    10512   ; *
                    10513   ; * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
                    10514   ; *********************************************************************************************************
                    10515   ; */
                    10516   ; void  *OSQPend (OS_EVENT  *pevent,
                    10517   ; INT32U     timeout,
                    10518   ; INT8U     *perr)
                    10519   ; {
                    10520   _OSQPend:
080031CE  4E56 0000 10521          link      A6,#0
080031D2  48E7 3C20 10522          movem.l   D2/D3/D4/D5/A2,-(A7)
080031D6  45F9 0800 10523          lea       _OSTCBCur.L,A2
080031DA  042C      
080031DC  262E 0010 10524          move.l    16(A6),D3
080031E0  2A2E 0008 10525          move.l    8(A6),D5
                    10526   ; void      *pmsg;
                    10527   ; OS_Q      *pq;
                    10528   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10529   ; OS_CPU_SR  cpu_sr = 0u;
                    10530   ; #endif
                    10531   ; #ifdef OS_SAFETY_CRITICAL
                    10532   ; if (perr == (INT8U *)0) {
                    10533   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10534   ; return ((void *)0);
                    10535   ; }
                    10536   ; #endif
                    10537   ; #if OS_ARG_CHK_EN > 0u
                    10538   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10539   ; *perr = OS_ERR_PEVENT_NULL;
                    10540   ; return ((void *)0);
                    10541   ; }
                    10542   ; #endif
                    10543   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
080031E4  2045      10544          move.l    D5,A0
080031E6  1010      10545          move.b    (A0),D0
080031E8  0C00 0002 10546          cmp.b     #2,D0
080031EC  670C      10547          beq.s     OSQPend_1
                    10548   ; *perr = OS_ERR_EVENT_TYPE;
080031EE  2043      10549          move.l    D3,A0
080031F0  10BC 0001 10550          move.b    #1,(A0)
                    10551   ; return ((void *)0);
080031F4  4280      10552          clr.l     D0
080031F6  6000 012E 10553          bra       OSQPend_3
                    10554   OSQPend_1:
                    10555   ; }
                    10556   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
080031FA  1039 0800 10557          move.b    _OSIntNesting.L,D0
080031FE  0312      
08003200  0C00 0000 10558          cmp.b     #0,D0
08003204  630C      10559          bls.s     OSQPend_4
                    10560   ; *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
08003206  2043      10561          move.l    D3,A0
08003208  10BC 0002 10562          move.b    #2,(A0)
                    10563   ; return ((void *)0);
0800320C  4280      10564          clr.l     D0
0800320E  6000 0116 10565          bra       OSQPend_3
                    10566   OSQPend_4:
                    10567   ; }
                    10568   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
08003212  1039 0800 10569          move.b    _OSLockNesting.L,D0
08003216  0314      
08003218  0C00 0000 10570          cmp.b     #0,D0
0800321C  630C      10571          bls.s     OSQPend_6
                    10572   ; *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
0800321E  2043      10573          move.l    D3,A0
08003220  10BC 000D 10574          move.b    #13,(A0)
                    10575   ; return ((void *)0);
08003224  4280      10576          clr.l     D0
08003226  6000 00FE 10577          bra       OSQPend_3
                    10578   OSQPend_6:
                    10579   ; }
                    10580   ; OS_ENTER_CRITICAL();
0800322A  40E7      10581          dc.w      16615
0800322C  007C      10582          dc.w      124
0800322E  0700      10583          dc.w      1792
                    10584   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
08003230  2045      10585          move.l    D5,A0
08003232  2428 0002 10586          move.l    2(A0),D2
                    10587   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
08003236  2042      10588          move.l    D2,A0
08003238  3028 0016 10589          move.w    22(A0),D0
0800323C  0C40 0000 10590          cmp.w     #0,D0
08003240  6300 0042 10591          bls       OSQPend_8
                    10592   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
08003244  2002      10593          move.l    D2,D0
08003246  0680 0000 10594          add.l     #16,D0
0800324A  0010      
0800324C  2040      10595          move.l    D0,A0
0800324E  2250      10596          move.l    (A0),A1
08003250  5890      10597          addq.l    #4,(A0)
08003252  2811      10598          move.l    (A1),D4
                    10599   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
08003254  2002      10600          move.l    D2,D0
08003256  0680 0000 10601          add.l     #22,D0
0800325A  0016      
0800325C  2040      10602          move.l    D0,A0
0800325E  5350      10603          subq.w    #1,(A0)
                    10604   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
08003260  2042      10605          move.l    D2,A0
08003262  2242      10606          move.l    D2,A1
08003264  2028 0010 10607          move.l    16(A0),D0
08003268  B0A9 0008 10608          cmp.l     8(A1),D0
0800326C  660A      10609          bne.s     OSQPend_10
                    10610   ; pq->OSQOut = pq->OSQStart;
0800326E  2042      10611          move.l    D2,A0
08003270  2242      10612          move.l    D2,A1
08003272  2368 0004 10613          move.l    4(A0),16(A1)
08003276  0010      
                    10614   OSQPend_10:
                    10615   ; }
                    10616   ; OS_EXIT_CRITICAL();
08003278  46DF      10617          dc.w      18143
                    10618   ; *perr = OS_ERR_NONE;
0800327A  2043      10619          move.l    D3,A0
0800327C  4210      10620          clr.b     (A0)
                    10621   ; return (pmsg);                           /* Return message received                            */
0800327E  2004      10622          move.l    D4,D0
08003280  6000 00A4 10623          bra       OSQPend_3
                    10624   OSQPend_8:
                    10625   ; }
                    10626   ; OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
08003284  2052      10627          move.l    (A2),A0
08003286  0028 0004 10628          or.b      #4,50(A0)
0800328A  0032      
                    10629   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
0800328C  2052      10630          move.l    (A2),A0
0800328E  4228 0033 10631          clr.b     51(A0)
                    10632   ; OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
08003292  2052      10633          move.l    (A2),A0
08003294  216E 000C 10634          move.l    12(A6),46(A0)
08003298  002E      
                    10635   ; OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
0800329A  2F05      10636          move.l    D5,-(A7)
0800329C  4EB9 0800 10637          jsr       _OS_EventTaskWait
080032A0  0A8E      
080032A2  584F      10638          addq.w    #4,A7
                    10639   ; OS_EXIT_CRITICAL();
080032A4  46DF      10640          dc.w      18143
                    10641   ; OS_Sched();                                  /* Find next highest priority task ready to run       */
080032A6  4EB9 0800 10642          jsr       _OS_Sched
080032AA  0F8A      
                    10643   ; OS_ENTER_CRITICAL();
080032AC  40E7      10644          dc.w      16615
080032AE  007C      10645          dc.w      124
080032B0  0700      10646          dc.w      1792
                    10647   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
080032B2  2052      10648          move.l    (A2),A0
080032B4  1028 0033 10649          move.b    51(A0),D0
080032B8  C0BC 0000 10650          and.l     #255,D0
080032BC  00FF      
080032BE  0C80 0000 10651          cmp.l     #1,D0
080032C2  0001      
080032C4  6700 002A 10652          beq       OSQPend_16
080032C8  6206      10653          bhi.s     OSQPend_18
080032CA  4A80      10654          tst.l     D0
080032CC  670C      10655          beq.s     OSQPend_14
080032CE  6020      10656          bra.s     OSQPend_16
                    10657   OSQPend_18:
080032D0  0C80 0000 10658          cmp.l     #2,D0
080032D4  0002      
080032D6  670E      10659          beq.s     OSQPend_15
080032D8  6016      10660          bra.s     OSQPend_16
                    10661   OSQPend_14:
                    10662   ; case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
                    10663   ; pmsg =  OSTCBCur->OSTCBMsg;
080032DA  2052      10664          move.l    (A2),A0
080032DC  2828 0024 10665          move.l    36(A0),D4
                    10666   ; *perr =  OS_ERR_NONE;
080032E0  2043      10667          move.l    D3,A0
080032E2  4210      10668          clr.b     (A0)
                    10669   ; break;
080032E4  601E      10670          bra.s     OSQPend_13
                    10671   OSQPend_15:
                    10672   ; case OS_STAT_PEND_ABORT:
                    10673   ; pmsg = (void *)0;
080032E6  4284      10674          clr.l     D4
                    10675   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
080032E8  2043      10676          move.l    D3,A0
080032EA  10BC 000E 10677          move.b    #14,(A0)
                    10678   ; break;
080032EE  6014      10679          bra.s     OSQPend_13
                    10680   OSQPend_16:
                    10681   ; case OS_STAT_PEND_TO:
                    10682   ; default:
                    10683   ; OS_EventTaskRemove(OSTCBCur, pevent);
080032F0  2F05      10684          move.l    D5,-(A7)
080032F2  2F12      10685          move.l    (A2),-(A7)
080032F4  4EB9 0800 10686          jsr       _OS_EventTaskRemove
080032F8  0BB0      
080032FA  504F      10687          addq.w    #8,A7
                    10688   ; pmsg = (void *)0;
080032FC  4284      10689          clr.l     D4
                    10690   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
080032FE  2043      10691          move.l    D3,A0
08003300  10BC 000A 10692          move.b    #10,(A0)
                    10693   ; break;
                    10694   OSQPend_13:
                    10695   ; }
                    10696   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
08003304  2052      10697          move.l    (A2),A0
08003306  4228 0032 10698          clr.b     50(A0)
                    10699   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0800330A  2052      10700          move.l    (A2),A0
0800330C  4228 0033 10701          clr.b     51(A0)
                    10702   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
08003310  2052      10703          move.l    (A2),A0
08003312  42A8 001C 10704          clr.l     28(A0)
                    10705   ; #if (OS_EVENT_MULTI_EN > 0u)
                    10706   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
08003316  2052      10707          move.l    (A2),A0
08003318  42A8 0020 10708          clr.l     32(A0)
                    10709   ; #endif
                    10710   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
0800331C  2052      10711          move.l    (A2),A0
0800331E  42A8 0024 10712          clr.l     36(A0)
                    10713   ; OS_EXIT_CRITICAL();
08003322  46DF      10714          dc.w      18143
                    10715   ; return (pmsg);                                    /* Return received message                       */
08003324  2004      10716          move.l    D4,D0
                    10717   OSQPend_3:
08003326  4CDF 043C 10718          movem.l   (A7)+,D2/D3/D4/D5/A2
0800332A  4E5E      10719          unlk      A6
0800332C  4E75      10720          rts
                    10721   ; }
                    10722   ; /*$PAGE*/
                    10723   ; /*
                    10724   ; *********************************************************************************************************
                    10725   ; *                                  ABORT WAITING ON A MESSAGE QUEUE
                    10726   ; *
                    10727   ; * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
                    10728   ; *              should be used to fault-abort the wait on the queue, rather than to normally signal
                    10729   ; *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
                    10730   ; *
                    10731   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
                    10732   ; *
                    10733   ; *              opt           determines the type of ABORT performed:
                    10734   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    10735   ; *                                                     queue
                    10736   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    10737   ; *                                                     queue
                    10738   ; *
                    10739   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10740   ; *                            messages are:
                    10741   ; *
                    10742   ; *                            OS_ERR_NONE         No tasks were     waiting on the queue.
                    10743   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
                    10744   ; *                                                and informed of the aborted wait; check return value
                    10745   ; *                                                for the number of tasks whose wait on the queue
                    10746   ; *                                                was aborted.
                    10747   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
                    10748   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    10749   ; *
                    10750   ; * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
                    10751   ; *              >  0          if one or more tasks waiting on the queue are now readied and informed.
                    10752   ; *********************************************************************************************************
                    10753   ; */
                    10754   ; #if OS_Q_PEND_ABORT_EN > 0u
                    10755   ; INT8U  OSQPendAbort (OS_EVENT  *pevent,
                    10756   ; INT8U      opt,
                    10757   ; INT8U     *perr)
                    10758   ; {
                    10759   _OSQPendAbort:
0800332E  4E56 0000 10760          link      A6,#0
08003332  48E7 3800 10761          movem.l   D2/D3/D4,-(A7)
08003336  242E 0008 10762          move.l    8(A6),D2
0800333A  282E 0010 10763          move.l    16(A6),D4
                    10764   ; INT8U      nbr_tasks;
                    10765   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10766   ; OS_CPU_SR  cpu_sr = 0u;
                    10767   ; #endif
                    10768   ; #ifdef OS_SAFETY_CRITICAL
                    10769   ; if (perr == (INT8U *)0) {
                    10770   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10771   ; return (0u);
                    10772   ; }
                    10773   ; #endif
                    10774   ; #if OS_ARG_CHK_EN > 0u
                    10775   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10776   ; *perr = OS_ERR_PEVENT_NULL;
                    10777   ; return (0u);
                    10778   ; }
                    10779   ; #endif
                    10780   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
0800333E  2042      10781          move.l    D2,A0
08003340  1010      10782          move.b    (A0),D0
08003342  0C00 0002 10783          cmp.b     #2,D0
08003346  670C      10784          beq.s     OSQPendAbort_1
                    10785   ; *perr = OS_ERR_EVENT_TYPE;
08003348  2044      10786          move.l    D4,A0
0800334A  10BC 0001 10787          move.b    #1,(A0)
                    10788   ; return (0u);
0800334E  4200      10789          clr.b     D0
08003350  6000 0092 10790          bra       OSQPendAbort_3
                    10791   OSQPendAbort_1:
                    10792   ; }
                    10793   ; OS_ENTER_CRITICAL();
08003354  40E7      10794          dc.w      16615
08003356  007C      10795          dc.w      124
08003358  0700      10796          dc.w      1792
                    10797   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
0800335A  2042      10798          move.l    D2,A0
0800335C  1028 0008 10799          move.b    8(A0),D0
08003360  6700 007A 10800          beq       OSQPendAbort_4
                    10801   ; nbr_tasks = 0u;
08003364  4203      10802          clr.b     D3
                    10803   ; switch (opt) {
08003366  102E 000F 10804          move.b    15(A6),D0
0800336A  C0BC 0000 10805          and.l     #255,D0
0800336E  00FF      
08003370  0C80 0000 10806          cmp.l     #1,D0
08003374  0001      
08003376  670A      10807          beq.s     OSQPendAbort_8
08003378  6200 0032 10808          bhi       OSQPendAbort_9
0800337C  4A80      10809          tst.l     D0
0800337E  672C      10810          beq.s     OSQPendAbort_9
08003380  602A      10811          bra.s     OSQPendAbort_9
                    10812   OSQPendAbort_8:
                    10813   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    10814   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
                    10815   OSQPendAbort_11:
08003382  2042      10816          move.l    D2,A0
08003384  1028 0008 10817          move.b    8(A0),D0
08003388  6720      10818          beq.s     OSQPendAbort_13
                    10819   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
0800338A  4878 0002 10820          pea       2
0800338E  4878 0004 10821          pea       4
08003392  42A7      10822          clr.l     -(A7)
08003394  2F02      10823          move.l    D2,-(A7)
08003396  4EB9 0800 10824          jsr       _OS_EventTaskRdy
0800339A  09AA      
0800339C  DEFC 0010 10825          add.w     #16,A7
080033A0  C0BC 0000 10826          and.l     #255,D0
080033A4  00FF      
                    10827   ; nbr_tasks++;
080033A6  5203      10828          addq.b    #1,D3
080033A8  60D8      10829          bra       OSQPendAbort_11
                    10830   OSQPendAbort_13:
                    10831   ; }
                    10832   ; break;
080033AA  601E      10833          bra.s     OSQPendAbort_7
                    10834   OSQPendAbort_9:
                    10835   ; case OS_PEND_OPT_NONE:
                    10836   ; default:                                       /* No,  ready HPT       waiting on queue    */
                    10837   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
080033AC  4878 0002 10838          pea       2
080033B0  4878 0004 10839          pea       4
080033B4  42A7      10840          clr.l     -(A7)
080033B6  2F02      10841          move.l    D2,-(A7)
080033B8  4EB9 0800 10842          jsr       _OS_EventTaskRdy
080033BC  09AA      
080033BE  DEFC 0010 10843          add.w     #16,A7
080033C2  C0BC 0000 10844          and.l     #255,D0
080033C6  00FF      
                    10845   ; nbr_tasks++;
080033C8  5203      10846          addq.b    #1,D3
                    10847   ; break;
                    10848   OSQPendAbort_7:
                    10849   ; }
                    10850   ; OS_EXIT_CRITICAL();
080033CA  46DF      10851          dc.w      18143
                    10852   ; OS_Sched();                                        /* Find HPT ready to run                    */
080033CC  4EB9 0800 10853          jsr       _OS_Sched
080033D0  0F8A      
                    10854   ; *perr = OS_ERR_PEND_ABORT;
080033D2  2044      10855          move.l    D4,A0
080033D4  10BC 000E 10856          move.b    #14,(A0)
                    10857   ; return (nbr_tasks);
080033D8  1003      10858          move.b    D3,D0
080033DA  6008      10859          bra.s     OSQPendAbort_3
                    10860   OSQPendAbort_4:
                    10861   ; }
                    10862   ; OS_EXIT_CRITICAL();
080033DC  46DF      10863          dc.w      18143
                    10864   ; *perr = OS_ERR_NONE;
080033DE  2044      10865          move.l    D4,A0
080033E0  4210      10866          clr.b     (A0)
                    10867   ; return (0u);                                           /* No tasks waiting on queue                */
080033E2  4200      10868          clr.b     D0
                    10869   OSQPendAbort_3:
080033E4  4CDF 001C 10870          movem.l   (A7)+,D2/D3/D4
080033E8  4E5E      10871          unlk      A6
080033EA  4E75      10872          rts
                    10873   ; }
                    10874   ; #endif
                    10875   ; /*$PAGE*/
                    10876   ; /*
                    10877   ; *********************************************************************************************************
                    10878   ; *                                       POST MESSAGE TO A QUEUE
                    10879   ; *
                    10880   ; * Description: This function sends a message to a queue
                    10881   ; *
                    10882   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10883   ; *
                    10884   ; *              pmsg          is a pointer to the message to send.
                    10885   ; *
                    10886   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    10887   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    10888   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    10889   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    10890   ; *
                    10891   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    10892   ; *********************************************************************************************************
                    10893   ; */
                    10894   ; #if OS_Q_POST_EN > 0u
                    10895   ; INT8U  OSQPost (OS_EVENT  *pevent,
                    10896   ; void      *pmsg)
                    10897   ; {
                    10898   _OSQPost:
080033EC  4E56 0000 10899          link      A6,#0
080033F0  48E7 3000 10900          movem.l   D2/D3,-(A7)
080033F4  262E 0008 10901          move.l    8(A6),D3
                    10902   ; OS_Q      *pq;
                    10903   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    10904   ; OS_CPU_SR  cpu_sr = 0u;
                    10905   ; #endif
                    10906   ; #if OS_ARG_CHK_EN > 0u
                    10907   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    10908   ; return (OS_ERR_PEVENT_NULL);
                    10909   ; }
                    10910   ; #endif
                    10911   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
080033F8  2043      10912          move.l    D3,A0
080033FA  1010      10913          move.b    (A0),D0
080033FC  0C00 0002 10914          cmp.b     #2,D0
08003400  6706      10915          beq.s     OSQPost_1
                    10916   ; return (OS_ERR_EVENT_TYPE);
08003402  7001      10917          moveq     #1,D0
08003404  6000 0090 10918          bra       OSQPost_3
                    10919   OSQPost_1:
                    10920   ; }
                    10921   ; OS_ENTER_CRITICAL();
08003408  40E7      10922          dc.w      16615
0800340A  007C      10923          dc.w      124
0800340C  0700      10924          dc.w      1792
                    10925   ; if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
0800340E  2043      10926          move.l    D3,A0
08003410  1028 0008 10927          move.b    8(A0),D0
08003414  672A      10928          beq.s     OSQPost_4
                    10929   ; /* Ready highest priority task waiting on event */
                    10930   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
08003416  42A7      10931          clr.l     -(A7)
08003418  4878 0004 10932          pea       4
0800341C  2F2E 000C 10933          move.l    12(A6),-(A7)
08003420  2F03      10934          move.l    D3,-(A7)
08003422  4EB9 0800 10935          jsr       _OS_EventTaskRdy
08003426  09AA      
08003428  DEFC 0010 10936          add.w     #16,A7
0800342C  C0BC 0000 10937          and.l     #255,D0
08003430  00FF      
                    10938   ; OS_EXIT_CRITICAL();
08003432  46DF      10939          dc.w      18143
                    10940   ; OS_Sched();                                    /* Find highest priority task ready to run      */
08003434  4EB9 0800 10941          jsr       _OS_Sched
08003438  0F8A      
                    10942   ; return (OS_ERR_NONE);
0800343A  4200      10943          clr.b     D0
0800343C  6000 0058 10944          bra       OSQPost_3
                    10945   OSQPost_4:
                    10946   ; }
                    10947   ; pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
08003440  2043      10948          move.l    D3,A0
08003442  2428 0002 10949          move.l    2(A0),D2
                    10950   ; if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
08003446  2042      10951          move.l    D2,A0
08003448  2242      10952          move.l    D2,A1
0800344A  3028 0016 10953          move.w    22(A0),D0
0800344E  B069 0014 10954          cmp.w     20(A1),D0
08003452  6508      10955          blo.s     OSQPost_6
                    10956   ; OS_EXIT_CRITICAL();
08003454  46DF      10957          dc.w      18143
                    10958   ; return (OS_ERR_Q_FULL);
08003456  701E      10959          moveq     #30,D0
08003458  6000 003C 10960          bra       OSQPost_3
                    10961   OSQPost_6:
                    10962   ; }
                    10963   ; *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
0800345C  2002      10964          move.l    D2,D0
0800345E  0680 0000 10965          add.l     #12,D0
08003462  000C      
08003464  2040      10966          move.l    D0,A0
08003466  2250      10967          move.l    (A0),A1
08003468  5890      10968          addq.l    #4,(A0)
0800346A  22AE 000C 10969          move.l    12(A6),(A1)
                    10970   ; pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
0800346E  2002      10971          move.l    D2,D0
08003470  0680 0000 10972          add.l     #22,D0
08003474  0016      
08003476  2040      10973          move.l    D0,A0
08003478  5250      10974          addq.w    #1,(A0)
                    10975   ; if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
0800347A  2042      10976          move.l    D2,A0
0800347C  2242      10977          move.l    D2,A1
0800347E  2028 000C 10978          move.l    12(A0),D0
08003482  B0A9 0008 10979          cmp.l     8(A1),D0
08003486  660A      10980          bne.s     OSQPost_8
                    10981   ; pq->OSQIn = pq->OSQStart;
08003488  2042      10982          move.l    D2,A0
0800348A  2242      10983          move.l    D2,A1
0800348C  2368 0004 10984          move.l    4(A0),12(A1)
08003490  000C      
                    10985   OSQPost_8:
                    10986   ; }
                    10987   ; OS_EXIT_CRITICAL();
08003492  46DF      10988          dc.w      18143
                    10989   ; return (OS_ERR_NONE);
08003494  4200      10990          clr.b     D0
                    10991   OSQPost_3:
08003496  4CDF 000C 10992          movem.l   (A7)+,D2/D3
0800349A  4E5E      10993          unlk      A6
0800349C  4E75      10994          rts
                    10995   ; }
                    10996   ; #endif
                    10997   ; /*$PAGE*/
                    10998   ; /*
                    10999   ; *********************************************************************************************************
                    11000   ; *                                POST MESSAGE TO THE FRONT OF A QUEUE
                    11001   ; *
                    11002   ; * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
                    11003   ; *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
                    11004   ; *              'priority' messages.
                    11005   ; *
                    11006   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11007   ; *
                    11008   ; *              pmsg          is a pointer to the message to send.
                    11009   ; *
                    11010   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11011   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11012   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11013   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11014   ; *
                    11015   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    11016   ; *********************************************************************************************************
                    11017   ; */
                    11018   ; #if OS_Q_POST_FRONT_EN > 0u
                    11019   ; INT8U  OSQPostFront (OS_EVENT  *pevent,
                    11020   ; void      *pmsg)
                    11021   ; {
                    11022   _OSQPostFront:
0800349E  4E56 0000 11023          link      A6,#0
080034A2  48E7 3000 11024          movem.l   D2/D3,-(A7)
080034A6  262E 0008 11025          move.l    8(A6),D3
                    11026   ; OS_Q      *pq;
                    11027   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11028   ; OS_CPU_SR  cpu_sr = 0u;
                    11029   ; #endif
                    11030   ; #if OS_ARG_CHK_EN > 0u
                    11031   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11032   ; return (OS_ERR_PEVENT_NULL);
                    11033   ; }
                    11034   ; #endif
                    11035   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
080034AA  2043      11036          move.l    D3,A0
080034AC  1010      11037          move.b    (A0),D0
080034AE  0C00 0002 11038          cmp.b     #2,D0
080034B2  6706      11039          beq.s     OSQPostFront_1
                    11040   ; return (OS_ERR_EVENT_TYPE);
080034B4  7001      11041          moveq     #1,D0
080034B6  6000 0094 11042          bra       OSQPostFront_3
                    11043   OSQPostFront_1:
                    11044   ; }
                    11045   ; OS_ENTER_CRITICAL();
080034BA  40E7      11046          dc.w      16615
080034BC  007C      11047          dc.w      124
080034BE  0700      11048          dc.w      1792
                    11049   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
080034C0  2043      11050          move.l    D3,A0
080034C2  1028 0008 11051          move.b    8(A0),D0
080034C6  672A      11052          beq.s     OSQPostFront_4
                    11053   ; /* Ready highest priority task waiting on event  */
                    11054   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
080034C8  42A7      11055          clr.l     -(A7)
080034CA  4878 0004 11056          pea       4
080034CE  2F2E 000C 11057          move.l    12(A6),-(A7)
080034D2  2F03      11058          move.l    D3,-(A7)
080034D4  4EB9 0800 11059          jsr       _OS_EventTaskRdy
080034D8  09AA      
080034DA  DEFC 0010 11060          add.w     #16,A7
080034DE  C0BC 0000 11061          and.l     #255,D0
080034E2  00FF      
                    11062   ; OS_EXIT_CRITICAL();
080034E4  46DF      11063          dc.w      18143
                    11064   ; OS_Sched();                                   /* Find highest priority task ready to run       */
080034E6  4EB9 0800 11065          jsr       _OS_Sched
080034EA  0F8A      
                    11066   ; return (OS_ERR_NONE);
080034EC  4200      11067          clr.b     D0
080034EE  6000 005C 11068          bra       OSQPostFront_3
                    11069   OSQPostFront_4:
                    11070   ; }
                    11071   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
080034F2  2043      11072          move.l    D3,A0
080034F4  2428 0002 11073          move.l    2(A0),D2
                    11074   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
080034F8  2042      11075          move.l    D2,A0
080034FA  2242      11076          move.l    D2,A1
080034FC  3028 0016 11077          move.w    22(A0),D0
08003500  B069 0014 11078          cmp.w     20(A1),D0
08003504  6508      11079          blo.s     OSQPostFront_6
                    11080   ; OS_EXIT_CRITICAL();
08003506  46DF      11081          dc.w      18143
                    11082   ; return (OS_ERR_Q_FULL);
08003508  701E      11083          moveq     #30,D0
0800350A  6000 0040 11084          bra       OSQPostFront_3
                    11085   OSQPostFront_6:
                    11086   ; }
                    11087   ; if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
0800350E  2042      11088          move.l    D2,A0
08003510  2242      11089          move.l    D2,A1
08003512  2028 0010 11090          move.l    16(A0),D0
08003516  B0A9 0004 11091          cmp.l     4(A1),D0
0800351A  660A      11092          bne.s     OSQPostFront_8
                    11093   ; pq->OSQOut = pq->OSQEnd;
0800351C  2042      11094          move.l    D2,A0
0800351E  2242      11095          move.l    D2,A1
08003520  2368 0008 11096          move.l    8(A0),16(A1)
08003524  0010      
                    11097   OSQPostFront_8:
                    11098   ; }
                    11099   ; pq->OSQOut--;
08003526  2002      11100          move.l    D2,D0
08003528  0680 0000 11101          add.l     #16,D0
0800352C  0010      
0800352E  2040      11102          move.l    D0,A0
08003530  5990      11103          subq.l    #4,(A0)
                    11104   ; *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
08003532  2042      11105          move.l    D2,A0
08003534  2068 0010 11106          move.l    16(A0),A0
08003538  20AE 000C 11107          move.l    12(A6),(A0)
                    11108   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
0800353C  2002      11109          move.l    D2,D0
0800353E  0680 0000 11110          add.l     #22,D0
08003542  0016      
08003544  2040      11111          move.l    D0,A0
08003546  5250      11112          addq.w    #1,(A0)
                    11113   ; OS_EXIT_CRITICAL();
08003548  46DF      11114          dc.w      18143
                    11115   ; return (OS_ERR_NONE);
0800354A  4200      11116          clr.b     D0
                    11117   OSQPostFront_3:
0800354C  4CDF 000C 11118          movem.l   (A7)+,D2/D3
08003550  4E5E      11119          unlk      A6
08003552  4E75      11120          rts
                    11121   ; }
                    11122   ; #endif
                    11123   ; /*$PAGE*/
                    11124   ; /*
                    11125   ; *********************************************************************************************************
                    11126   ; *                                       POST MESSAGE TO A QUEUE
                    11127   ; *
                    11128   ; * Description: This function sends a message to a queue.  This call has been added to reduce code size
                    11129   ; *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
                    11130   ; *              capability to broadcast a message to ALL tasks waiting on the message queue.
                    11131   ; *
                    11132   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11133   ; *
                    11134   ; *              pmsg          is a pointer to the message to send.
                    11135   ; *
                    11136   ; *              opt           determines the type of POST performed:
                    11137   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    11138   ; *                                                     (Identical to OSQPost())
                    11139   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
                    11140   ; *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
                    11141   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    11142   ; *
                    11143   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11144   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11145   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11146   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11147   ; *
                    11148   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    11149   ; *              interrupt disable time is proportional to the number of tasks waiting on the queue.
                    11150   ; *********************************************************************************************************
                    11151   ; */
                    11152   ; #if OS_Q_POST_OPT_EN > 0u
                    11153   ; INT8U  OSQPostOpt (OS_EVENT  *pevent,
                    11154   ; void      *pmsg,
                    11155   ; INT8U      opt)
                    11156   ; {
                    11157   _OSQPostOpt:
08003554  4E56 0000 11158          link      A6,#0
08003558  48E7 3C00 11159          movem.l   D2/D3/D4/D5,-(A7)
0800355C  262E 0008 11160          move.l    8(A6),D3
08003560  282E 000C 11161          move.l    12(A6),D4
08003564  1A2E 0013 11162          move.b    19(A6),D5
08003568  CABC 0000 11163          and.l     #255,D5
0800356C  00FF      
                    11164   ; OS_Q      *pq;
                    11165   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11166   ; OS_CPU_SR  cpu_sr = 0u;
                    11167   ; #endif
                    11168   ; #if OS_ARG_CHK_EN > 0u
                    11169   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11170   ; return (OS_ERR_PEVENT_NULL);
                    11171   ; }
                    11172   ; #endif
                    11173   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
0800356E  2043      11174          move.l    D3,A0
08003570  1010      11175          move.b    (A0),D0
08003572  0C00 0002 11176          cmp.b     #2,D0
08003576  6706      11177          beq.s     OSQPostOpt_1
                    11178   ; return (OS_ERR_EVENT_TYPE);
08003578  7001      11179          moveq     #1,D0
0800357A  6000 00FC 11180          bra       OSQPostOpt_3
                    11181   OSQPostOpt_1:
                    11182   ; }
                    11183   ; OS_ENTER_CRITICAL();
0800357E  40E7      11184          dc.w      16615
08003580  007C      11185          dc.w      124
08003582  0700      11186          dc.w      1792
                    11187   ; if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
08003584  2043      11188          move.l    D3,A0
08003586  1028 0008 11189          move.b    8(A0),D0
0800358A  6700 0060 11190          beq       OSQPostOpt_4
                    11191   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
0800358E  1005      11192          move.b    D5,D0
08003590  C03C 0001 11193          and.b     #1,D0
08003594  6726      11194          beq.s     OSQPostOpt_6
                    11195   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                    11196   OSQPostOpt_8:
08003596  2043      11197          move.l    D3,A0
08003598  1028 0008 11198          move.b    8(A0),D0
0800359C  671C      11199          beq.s     OSQPostOpt_10
                    11200   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
0800359E  42A7      11201          clr.l     -(A7)
080035A0  4878 0004 11202          pea       4
080035A4  2F04      11203          move.l    D4,-(A7)
080035A6  2F03      11204          move.l    D3,-(A7)
080035A8  4EB9 0800 11205          jsr       _OS_EventTaskRdy
080035AC  09AA      
080035AE  DEFC 0010 11206          add.w     #16,A7
080035B2  C0BC 0000 11207          and.l     #255,D0
080035B6  00FF      
080035B8  60DC      11208          bra       OSQPostOpt_8
                    11209   OSQPostOpt_10:
080035BA  601A      11210          bra.s     OSQPostOpt_7
                    11211   OSQPostOpt_6:
                    11212   ; }
                    11213   ; } else {                                      /* No,  Post to HPT waiting on queue             */
                    11214   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
080035BC  42A7      11215          clr.l     -(A7)
080035BE  4878 0004 11216          pea       4
080035C2  2F04      11217          move.l    D4,-(A7)
080035C4  2F03      11218          move.l    D3,-(A7)
080035C6  4EB9 0800 11219          jsr       _OS_EventTaskRdy
080035CA  09AA      
080035CC  DEFC 0010 11220          add.w     #16,A7
080035D0  C0BC 0000 11221          and.l     #255,D0
080035D4  00FF      
                    11222   OSQPostOpt_7:
                    11223   ; }
                    11224   ; OS_EXIT_CRITICAL();
080035D6  46DF      11225          dc.w      18143
                    11226   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
080035D8  1005      11227          move.b    D5,D0
080035DA  C03C 0004 11228          and.b     #4,D0
080035DE  6606      11229          bne.s     OSQPostOpt_11
                    11230   ; OS_Sched();                               /* Find highest priority task ready to run       */
080035E0  4EB9 0800 11231          jsr       _OS_Sched
080035E4  0F8A      
                    11232   OSQPostOpt_11:
                    11233   ; }
                    11234   ; return (OS_ERR_NONE);
080035E6  4200      11235          clr.b     D0
080035E8  6000 008E 11236          bra       OSQPostOpt_3
                    11237   OSQPostOpt_4:
                    11238   ; }
                    11239   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
080035EC  2043      11240          move.l    D3,A0
080035EE  2428 0002 11241          move.l    2(A0),D2
                    11242   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
080035F2  2042      11243          move.l    D2,A0
080035F4  2242      11244          move.l    D2,A1
080035F6  3028 0016 11245          move.w    22(A0),D0
080035FA  B069 0014 11246          cmp.w     20(A1),D0
080035FE  6508      11247          blo.s     OSQPostOpt_13
                    11248   ; OS_EXIT_CRITICAL();
08003600  46DF      11249          dc.w      18143
                    11250   ; return (OS_ERR_Q_FULL);
08003602  701E      11251          moveq     #30,D0
08003604  6000 0072 11252          bra       OSQPostOpt_3
                    11253   OSQPostOpt_13:
                    11254   ; }
                    11255   ; if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
08003608  1005      11256          move.b    D5,D0
0800360A  C03C 0002 11257          and.b     #2,D0
0800360E  6700 0030 11258          beq       OSQPostOpt_15
                    11259   ; if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
08003612  2042      11260          move.l    D2,A0
08003614  2242      11261          move.l    D2,A1
08003616  2028 0010 11262          move.l    16(A0),D0
0800361A  B0A9 0004 11263          cmp.l     4(A1),D0
0800361E  660A      11264          bne.s     OSQPostOpt_17
                    11265   ; pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
08003620  2042      11266          move.l    D2,A0
08003622  2242      11267          move.l    D2,A1
08003624  2368 0008 11268          move.l    8(A0),16(A1)
08003628  0010      
                    11269   OSQPostOpt_17:
                    11270   ; }
                    11271   ; pq->OSQOut--;
0800362A  2002      11272          move.l    D2,D0
0800362C  0680 0000 11273          add.l     #16,D0
08003630  0010      
08003632  2040      11274          move.l    D0,A0
08003634  5990      11275          subq.l    #4,(A0)
                    11276   ; *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
08003636  2042      11277          move.l    D2,A0
08003638  2068 0010 11278          move.l    16(A0),A0
0800363C  2084      11279          move.l    D4,(A0)
0800363E  6028      11280          bra.s     OSQPostOpt_19
                    11281   OSQPostOpt_15:
                    11282   ; } else {                                          /* No,  Post as FIFO                             */
                    11283   ; *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
08003640  2002      11284          move.l    D2,D0
08003642  0680 0000 11285          add.l     #12,D0
08003646  000C      
08003648  2040      11286          move.l    D0,A0
0800364A  2250      11287          move.l    (A0),A1
0800364C  5890      11288          addq.l    #4,(A0)
0800364E  2284      11289          move.l    D4,(A1)
                    11290   ; if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
08003650  2042      11291          move.l    D2,A0
08003652  2242      11292          move.l    D2,A1
08003654  2028 000C 11293          move.l    12(A0),D0
08003658  B0A9 0008 11294          cmp.l     8(A1),D0
0800365C  660A      11295          bne.s     OSQPostOpt_19
                    11296   ; pq->OSQIn = pq->OSQStart;
0800365E  2042      11297          move.l    D2,A0
08003660  2242      11298          move.l    D2,A1
08003662  2368 0004 11299          move.l    4(A0),12(A1)
08003666  000C      
                    11300   OSQPostOpt_19:
                    11301   ; }
                    11302   ; }
                    11303   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
08003668  2002      11304          move.l    D2,D0
0800366A  0680 0000 11305          add.l     #22,D0
0800366E  0016      
08003670  2040      11306          move.l    D0,A0
08003672  5250      11307          addq.w    #1,(A0)
                    11308   ; OS_EXIT_CRITICAL();
08003674  46DF      11309          dc.w      18143
                    11310   ; return (OS_ERR_NONE);
08003676  4200      11311          clr.b     D0
                    11312   OSQPostOpt_3:
08003678  4CDF 003C 11313          movem.l   (A7)+,D2/D3/D4/D5
0800367C  4E5E      11314          unlk      A6
0800367E  4E75      11315          rts
                    11316   ; }
                    11317   ; #endif
                    11318   ; /*$PAGE*/
                    11319   ; /*
                    11320   ; *********************************************************************************************************
                    11321   ; *                                        QUERY A MESSAGE QUEUE
                    11322   ; *
                    11323   ; * Description: This function obtains information about a message queue.
                    11324   ; *
                    11325   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11326   ; *
                    11327   ; *              p_q_data      is a pointer to a structure that will contain information about the message
                    11328   ; *                            queue.
                    11329   ; *
                    11330   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    11331   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
                    11332   ; *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
                    11333   ; *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
                    11334   ; *********************************************************************************************************
                    11335   ; */
                    11336   ; #if OS_Q_QUERY_EN > 0u
                    11337   ; INT8U  OSQQuery (OS_EVENT  *pevent,
                    11338   ; OS_Q_DATA *p_q_data)
                    11339   ; {
                    11340   _OSQQuery:
08003680  4E56 FFF8 11341          link      A6,#-8
08003684  48E7 3C00 11342          movem.l   D2/D3/D4/D5,-(A7)
08003688  242E 000C 11343          move.l    12(A6),D2
0800368C  282E 0008 11344          move.l    8(A6),D4
                    11345   ; OS_Q       *pq;
                    11346   ; INT8U       i;
                    11347   ; OS_PRIO    *psrc;
                    11348   ; OS_PRIO    *pdest;
                    11349   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11350   ; OS_CPU_SR   cpu_sr = 0u;
                    11351   ; #endif
                    11352   ; #if OS_ARG_CHK_EN > 0u
                    11353   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11354   ; return (OS_ERR_PEVENT_NULL);
                    11355   ; }
                    11356   ; if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
                    11357   ; return (OS_ERR_PDATA_NULL);
                    11358   ; }
                    11359   ; #endif
                    11360   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
08003690  2044      11361          move.l    D4,A0
08003692  1010      11362          move.b    (A0),D0
08003694  0C00 0002 11363          cmp.b     #2,D0
08003698  6706      11364          beq.s     OSQQuery_1
                    11365   ; return (OS_ERR_EVENT_TYPE);
0800369A  7001      11366          moveq     #1,D0
0800369C  6000 007A 11367          bra       OSQQuery_3
                    11368   OSQQuery_1:
                    11369   ; }
                    11370   ; OS_ENTER_CRITICAL();
080036A0  40E7      11371          dc.w      16615
080036A2  007C      11372          dc.w      124
080036A4  0700      11373          dc.w      1792
                    11374   ; p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
080036A6  2044      11375          move.l    D4,A0
080036A8  2242      11376          move.l    D2,A1
080036AA  1368 0008 11377          move.b    8(A0),16(A1)
080036AE  0010      
                    11378   ; psrc                 = &pevent->OSEventTbl[0];
080036B0  700A      11379          moveq     #10,D0
080036B2  D084      11380          add.l     D4,D0
080036B4  2D40 FFF8 11381          move.l    D0,-8(A6)
                    11382   ; pdest                = &p_q_data->OSEventTbl[0];
080036B8  7008      11383          moveq     #8,D0
080036BA  D082      11384          add.l     D2,D0
080036BC  2D40 FFFC 11385          move.l    D0,-4(A6)
                    11386   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
080036C0  4205      11387          clr.b     D5
                    11388   OSQQuery_4:
080036C2  0C05 0008 11389          cmp.b     #8,D5
080036C6  6416      11390          bhs.s     OSQQuery_6
                    11391   ; *pdest++ = *psrc++;
080036C8  206E FFF8 11392          move.l    -8(A6),A0
080036CC  52AE FFF8 11393          addq.l    #1,-8(A6)
080036D0  226E FFFC 11394          move.l    -4(A6),A1
080036D4  52AE FFFC 11395          addq.l    #1,-4(A6)
080036D8  1290      11396          move.b    (A0),(A1)
080036DA  5205      11397          addq.b    #1,D5
080036DC  60E4      11398          bra       OSQQuery_4
                    11399   OSQQuery_6:
                    11400   ; }
                    11401   ; pq = (OS_Q *)pevent->OSEventPtr;
080036DE  2044      11402          move.l    D4,A0
080036E0  2628 0002 11403          move.l    2(A0),D3
                    11404   ; if (pq->OSQEntries > 0u) {
080036E4  2043      11405          move.l    D3,A0
080036E6  3028 0016 11406          move.w    22(A0),D0
080036EA  0C40 0000 11407          cmp.w     #0,D0
080036EE  630C      11408          bls.s     OSQQuery_7
                    11409   ; p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
080036F0  2043      11410          move.l    D3,A0
080036F2  2068 0010 11411          move.l    16(A0),A0
080036F6  2242      11412          move.l    D2,A1
080036F8  2290      11413          move.l    (A0),(A1)
080036FA  6004      11414          bra.s     OSQQuery_8
                    11415   OSQQuery_7:
                    11416   ; } else {
                    11417   ; p_q_data->OSMsg = (void *)0;
080036FC  2042      11418          move.l    D2,A0
080036FE  4290      11419          clr.l     (A0)
                    11420   OSQQuery_8:
                    11421   ; }
                    11422   ; p_q_data->OSNMsgs = pq->OSQEntries;
08003700  2043      11423          move.l    D3,A0
08003702  2242      11424          move.l    D2,A1
08003704  3368 0016 11425          move.w    22(A0),4(A1)
08003708  0004      
                    11426   ; p_q_data->OSQSize = pq->OSQSize;
0800370A  2043      11427          move.l    D3,A0
0800370C  2242      11428          move.l    D2,A1
0800370E  3368 0014 11429          move.w    20(A0),6(A1)
08003712  0006      
                    11430   ; OS_EXIT_CRITICAL();
08003714  46DF      11431          dc.w      18143
                    11432   ; return (OS_ERR_NONE);
08003716  4200      11433          clr.b     D0
                    11434   OSQQuery_3:
08003718  4CDF 003C 11435          movem.l   (A7)+,D2/D3/D4/D5
0800371C  4E5E      11436          unlk      A6
0800371E  4E75      11437          rts
                    11438   ; }
                    11439   ; #endif                                                 /* OS_Q_QUERY_EN                                */
                    11440   ; /*$PAGE*/
                    11441   ; /*
                    11442   ; *********************************************************************************************************
                    11443   ; *                                     QUEUE MODULE INITIALIZATION
                    11444   ; *
                    11445   ; * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
                    11446   ; *               application MUST NOT call this function.
                    11447   ; *
                    11448   ; * Arguments   :  none
                    11449   ; *
                    11450   ; * Returns     : none
                    11451   ; *
                    11452   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    11453   ; *********************************************************************************************************
                    11454   ; */
                    11455   ; void  OS_QInit (void)
                    11456   ; {
                    11457   _OS_QInit:
08003720  4E56 FFF8 11458          link      A6,#-8
08003724  48E7 3020 11459          movem.l   D2/D3/A2,-(A7)
08003728  45F9 0800 11460          lea       _OSQTbl.L,A2
0800372C  0D20      
                    11461   ; #if OS_MAX_QS == 1u
                    11462   ; OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
                    11463   ; OSQFreeList->OSQPtr = (OS_Q *)0;
                    11464   ; #endif
                    11465   ; #if OS_MAX_QS >= 2u
                    11466   ; INT16U   ix;
                    11467   ; INT16U   ix_next;
                    11468   ; OS_Q    *pq1;
                    11469   ; OS_Q    *pq2;
                    11470   ; OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
0800372E  4878 0060 11471          pea       96
08003732  2F0A      11472          move.l    A2,-(A7)
08003734  4EB9 0800 11473          jsr       _OS_MemClr
08003738  0F3E      
0800373A  504F      11474          addq.w    #8,A7
                    11475   ; for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
0800373C  4242      11476          clr.w     D2
                    11477   OS_QInit_1:
0800373E  0C42 0003 11478          cmp.w     #3,D2
08003742  6400 003C 11479          bhs       OS_QInit_3
                    11480   ; ix_next = ix + 1u;
08003746  3002      11481          move.w    D2,D0
08003748  5240      11482          addq.w    #1,D0
0800374A  3D40 FFFA 11483          move.w    D0,-6(A6)
                    11484   ; pq1 = &OSQTbl[ix];
0800374E  200A      11485          move.l    A2,D0
08003750  C4BC 0000 11486          and.l     #65535,D2
08003754  FFFF      
08003756  2202      11487          move.l    D2,D1
08003758  C3FC 0018 11488          muls      #24,D1
0800375C  D081      11489          add.l     D1,D0
0800375E  2600      11490          move.l    D0,D3
                    11491   ; pq2 = &OSQTbl[ix_next];
08003760  200A      11492          move.l    A2,D0
08003762  322E FFFA 11493          move.w    -6(A6),D1
08003766  C2BC 0000 11494          and.l     #65535,D1
0800376A  FFFF      
0800376C  C3FC 0018 11495          muls      #24,D1
08003770  D081      11496          add.l     D1,D0
08003772  2D40 FFFC 11497          move.l    D0,-4(A6)
                    11498   ; pq1->OSQPtr = pq2;
08003776  2043      11499          move.l    D3,A0
08003778  20AE FFFC 11500          move.l    -4(A6),(A0)
0800377C  5242      11501          addq.w    #1,D2
0800377E  60BE      11502          bra       OS_QInit_1
                    11503   OS_QInit_3:
                    11504   ; }
                    11505   ; pq1         = &OSQTbl[ix];
08003780  200A      11506          move.l    A2,D0
08003782  C4BC 0000 11507          and.l     #65535,D2
08003786  FFFF      
08003788  2202      11508          move.l    D2,D1
0800378A  C3FC 0018 11509          muls      #24,D1
0800378E  D081      11510          add.l     D1,D0
08003790  2600      11511          move.l    D0,D3
                    11512   ; pq1->OSQPtr = (OS_Q *)0;
08003792  2043      11513          move.l    D3,A0
08003794  4290      11514          clr.l     (A0)
                    11515   ; OSQFreeList = &OSQTbl[0];
08003796  23CA 0800 11516          move.l    A2,_OSQFreeList.L
0800379A  0D1C      
0800379C  4CDF 040C 11517          movem.l   (A7)+,D2/D3/A2
080037A0  4E5E      11518          unlk      A6
080037A2  4E75      11519          rts
                    11520   ; /*
                    11521   ; *********************************************************************************************************
                    11522   ; *                                                uC/OS-II
                    11523   ; *                                          The Real-Time Kernel
                    11524   ; *                                          SEMAPHORE MANAGEMENT
                    11525   ; *
                    11526   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    11527   ; *                                           All Rights Reserved
                    11528   ; *
                    11529   ; * File    : OS_SEM.C
                    11530   ; * By      : Jean J. Labrosse
                    11531   ; * Version : V2.92.07
                    11532   ; *
                    11533   ; * LICENSING TERMS:
                    11534   ; * ---------------
                    11535   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    11536   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    11537   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    11538   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    11539   ; * licensing fee.
                    11540   ; *********************************************************************************************************
                    11541   ; */
                    11542   ; #define  MICRIUM_SOURCE
                    11543   ; #ifndef  OS_MASTER_FILE
                    11544   ; #include <ucos_ii.h>
                    11545   ; #endif
                    11546   ; #if OS_SEM_EN > 0u
                    11547   ; /*$PAGE*/
                    11548   ; /*
                    11549   ; *********************************************************************************************************
                    11550   ; *                                          ACCEPT SEMAPHORE
                    11551   ; *
                    11552   ; * Description: This function checks the semaphore to see if a resource is available or, if an event
                    11553   ; *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
                    11554   ; *              resource is not available or the event did not occur.
                    11555   ; *
                    11556   ; * Arguments  : pevent     is a pointer to the event control block
                    11557   ; *
                    11558   ; * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
                    11559   ; *                         decremented to obtain the resource.
                    11560   ; *              == 0       if the resource is not available or the event did not occur or,
                    11561   ; *                         if 'pevent' is a NULL pointer or,
                    11562   ; *                         if you didn't pass a pointer to a semaphore
                    11563   ; *********************************************************************************************************
                    11564   ; */
                    11565   ; #if OS_SEM_ACCEPT_EN > 0u
                    11566   ; INT16U  OSSemAccept (OS_EVENT *pevent)
                    11567   ; {
                    11568   _OSSemAccept:
080037A4  4E56 0000 11569          link      A6,#0
080037A8  48E7 3000 11570          movem.l   D2/D3,-(A7)
080037AC  262E 0008 11571          move.l    8(A6),D3
                    11572   ; INT16U     cnt;
                    11573   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11574   ; OS_CPU_SR  cpu_sr = 0u;
                    11575   ; #endif
                    11576   ; #if OS_ARG_CHK_EN > 0u
                    11577   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11578   ; return (0u);
                    11579   ; }
                    11580   ; #endif
                    11581   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
080037B0  2043      11582          move.l    D3,A0
080037B2  1010      11583          move.b    (A0),D0
080037B4  0C00 0003 11584          cmp.b     #3,D0
080037B8  6704      11585          beq.s     OSSemAccept_1
                    11586   ; return (0u);
080037BA  4240      11587          clr.w     D0
080037BC  601E      11588          bra.s     OSSemAccept_3
                    11589   OSSemAccept_1:
                    11590   ; }
                    11591   ; OS_ENTER_CRITICAL();
080037BE  40E7      11592          dc.w      16615
080037C0  007C      11593          dc.w      124
080037C2  0700      11594          dc.w      1792
                    11595   ; cnt = pevent->OSEventCnt;
080037C4  2043      11596          move.l    D3,A0
080037C6  3428 0006 11597          move.w    6(A0),D2
                    11598   ; if (cnt > 0u) {                                   /* See if resource is available                  */
080037CA  0C42 0000 11599          cmp.w     #0,D2
080037CE  6308      11600          bls.s     OSSemAccept_4
                    11601   ; pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
080037D0  2003      11602          move.l    D3,D0
080037D2  5C80      11603          addq.l    #6,D0
080037D4  2040      11604          move.l    D0,A0
080037D6  5350      11605          subq.w    #1,(A0)
                    11606   OSSemAccept_4:
                    11607   ; }
                    11608   ; OS_EXIT_CRITICAL();
080037D8  46DF      11609          dc.w      18143
                    11610   ; return (cnt);                                     /* Return semaphore count                        */
080037DA  3002      11611          move.w    D2,D0
                    11612   OSSemAccept_3:
080037DC  4CDF 000C 11613          movem.l   (A7)+,D2/D3
080037E0  4E5E      11614          unlk      A6
080037E2  4E75      11615          rts
                    11616   ; }
                    11617   ; #endif
                    11618   ; /*$PAGE*/
                    11619   ; /*
                    11620   ; *********************************************************************************************************
                    11621   ; *                                         CREATE A SEMAPHORE
                    11622   ; *
                    11623   ; * Description: This function creates a semaphore.
                    11624   ; *
                    11625   ; * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
                    11626   ; *                            available (or no event has occurred).  You initialize the semaphore to a
                    11627   ; *                            non-zero value to specify how many resources are available (e.g. if you have
                    11628   ; *                            10 resources, you would initialize the semaphore to 10).
                    11629   ; *
                    11630   ; * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
                    11631   ; *                            created semaphore
                    11632   ; *              == (void *)0  if no event control blocks were available
                    11633   ; *********************************************************************************************************
                    11634   ; */
                    11635   ; OS_EVENT  *OSSemCreate (INT16U cnt)
                    11636   ; {
                    11637   _OSSemCreate:
080037E4  4E56 0000 11638          link      A6,#0
080037E8  48E7 2020 11639          movem.l   D2/A2,-(A7)
080037EC  45F9 0800 11640          lea       _OSEventFreeList.L,A2
080037F0  00E6      
                    11641   ; OS_EVENT  *pevent;
                    11642   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11643   ; OS_CPU_SR  cpu_sr = 0u;
                    11644   ; #endif
                    11645   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    11646   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    11647   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11648   ; return ((OS_EVENT *)0);
                    11649   ; }
                    11650   ; #endif
                    11651   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
080037F2  1039 0800 11652          move.b    _OSIntNesting.L,D0
080037F6  0312      
080037F8  0C00 0000 11653          cmp.b     #0,D0
080037FC  6306      11654          bls.s     OSSemCreate_1
                    11655   ; return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
080037FE  4280      11656          clr.l     D0
08003800  6000 0046 11657          bra       OSSemCreate_3
                    11658   OSSemCreate_1:
                    11659   ; }
                    11660   ; OS_ENTER_CRITICAL();
08003804  40E7      11661          dc.w      16615
08003806  007C      11662          dc.w      124
08003808  0700      11663          dc.w      1792
                    11664   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
0800380A  2412      11665          move.l    (A2),D2
                    11666   ; if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
0800380C  2012      11667          move.l    (A2),D0
0800380E  6706      11668          beq.s     OSSemCreate_4
                    11669   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
08003810  2052      11670          move.l    (A2),A0
08003812  24A8 0002 11671          move.l    2(A0),(A2)
                    11672   OSSemCreate_4:
                    11673   ; }
                    11674   ; OS_EXIT_CRITICAL();
08003816  46DF      11675          dc.w      18143
                    11676   ; if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
08003818  4A82      11677          tst.l     D2
0800381A  672A      11678          beq.s     OSSemCreate_6
                    11679   ; pevent->OSEventType    = OS_EVENT_TYPE_SEM;
0800381C  2042      11680          move.l    D2,A0
0800381E  10BC 0003 11681          move.b    #3,(A0)
                    11682   ; pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
08003822  2042      11683          move.l    D2,A0
08003824  316E 000A 11684          move.w    10(A6),6(A0)
08003828  0006      
                    11685   ; pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
0800382A  2042      11686          move.l    D2,A0
0800382C  42A8 0002 11687          clr.l     2(A0)
                    11688   ; #if OS_EVENT_NAME_EN > 0u
                    11689   ; pevent->OSEventName    = (INT8U *)(void *)"?";
08003830  41F9 0800 11690          lea       @ucos_ii_1.L,A0
08003834  57FE      
08003836  2242      11691          move.l    D2,A1
08003838  2348 0012 11692          move.l    A0,18(A1)
                    11693   ; #endif
                    11694   ; OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
0800383C  2F02      11695          move.l    D2,-(A7)
0800383E  4EB9 0800 11696          jsr       _OS_EventWaitListInit
08003842  0C72      
08003844  584F      11697          addq.w    #4,A7
                    11698   OSSemCreate_6:
                    11699   ; }
                    11700   ; return (pevent);
08003846  2002      11701          move.l    D2,D0
                    11702   OSSemCreate_3:
08003848  4CDF 0404 11703          movem.l   (A7)+,D2/A2
0800384C  4E5E      11704          unlk      A6
0800384E  4E75      11705          rts
                    11706   ; }
                    11707   ; /*$PAGE*/
                    11708   ; /*
                    11709   ; *********************************************************************************************************
                    11710   ; *                                         DELETE A SEMAPHORE
                    11711   ; *
                    11712   ; * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
                    11713   ; *
                    11714   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    11715   ; *                            semaphore.
                    11716   ; *
                    11717   ; *              opt           determines delete options as follows:
                    11718   ; *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
                    11719   ; *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
                    11720   ; *                                                    In this case, all the tasks pending will be readied.
                    11721   ; *
                    11722   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    11723   ; *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
                    11724   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
                    11725   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    11726   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
                    11727   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
                    11728   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    11729   ; *
                    11730   ; * Returns    : pevent        upon error
                    11731   ; *              (OS_EVENT *)0 if the semaphore was successfully deleted.
                    11732   ; *
                    11733   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    11734   ; *                 the semaphore MUST check the return code of OSSemPend().
                    11735   ; *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
                    11736   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    11737   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    11738   ; *                 time is directly proportional to the number of tasks waiting on the semaphore.
                    11739   ; *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
                    11740   ; *                 applications where the semaphore is used for mutual exclusion because the resource(s)
                    11741   ; *                 will no longer be guarded by the semaphore.
                    11742   ; *              5) All tasks that were waiting for the semaphore will be readied and returned an 
                    11743   ; *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
                    11744   ; *********************************************************************************************************
                    11745   ; */
                    11746   ; #if OS_SEM_DEL_EN > 0u
                    11747   ; OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
                    11748   ; INT8U      opt,
                    11749   ; INT8U     *perr)
                    11750   ; {
                    11751   _OSSemDel:
08003850  4E56 0000 11752          link      A6,#0
08003854  48E7 3C20 11753          movem.l   D2/D3/D4/D5/A2,-(A7)
08003858  242E 0008 11754          move.l    8(A6),D2
0800385C  262E 0010 11755          move.l    16(A6),D3
08003860  45F9 0800 11756          lea       _OSEventFreeList.L,A2
08003864  00E6      
                    11757   ; BOOLEAN    tasks_waiting;
                    11758   ; OS_EVENT  *pevent_return;
                    11759   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11760   ; OS_CPU_SR  cpu_sr = 0u;
                    11761   ; #endif
                    11762   ; #ifdef OS_SAFETY_CRITICAL
                    11763   ; if (perr == (INT8U *)0) {
                    11764   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11765   ; return ((OS_EVENT *)0);
                    11766   ; }
                    11767   ; #endif
                    11768   ; #if OS_ARG_CHK_EN > 0u
                    11769   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    11770   ; *perr = OS_ERR_PEVENT_NULL;
                    11771   ; return (pevent);
                    11772   ; }
                    11773   ; #endif
                    11774   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
08003866  2042      11775          move.l    D2,A0
08003868  1010      11776          move.b    (A0),D0
0800386A  0C00 0003 11777          cmp.b     #3,D0
0800386E  670C      11778          beq.s     OSSemDel_1
                    11779   ; *perr = OS_ERR_EVENT_TYPE;
08003870  2043      11780          move.l    D3,A0
08003872  10BC 0001 11781          move.b    #1,(A0)
                    11782   ; return (pevent);
08003876  2002      11783          move.l    D2,D0
08003878  6000 00EE 11784          bra       OSSemDel_3
                    11785   OSSemDel_1:
                    11786   ; }
                    11787   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0800387C  1039 0800 11788          move.b    _OSIntNesting.L,D0
08003880  0312      
08003882  0C00 0000 11789          cmp.b     #0,D0
08003886  630C      11790          bls.s     OSSemDel_4
                    11791   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
08003888  2043      11792          move.l    D3,A0
0800388A  10BC 000F 11793          move.b    #15,(A0)
                    11794   ; return (pevent);
0800388E  2002      11795          move.l    D2,D0
08003890  6000 00D6 11796          bra       OSSemDel_3
                    11797   OSSemDel_4:
                    11798   ; }
                    11799   ; OS_ENTER_CRITICAL();
08003894  40E7      11800          dc.w      16615
08003896  007C      11801          dc.w      124
08003898  0700      11802          dc.w      1792
                    11803   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
0800389A  2042      11804          move.l    D2,A0
0800389C  1028 0008 11805          move.b    8(A0),D0
080038A0  6704      11806          beq.s     OSSemDel_6
                    11807   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
080038A2  7A01      11808          moveq     #1,D5
080038A4  6002      11809          bra.s     OSSemDel_7
                    11810   OSSemDel_6:
                    11811   ; } else {
                    11812   ; tasks_waiting = OS_FALSE;                          /* No                                       */
080038A6  4205      11813          clr.b     D5
                    11814   OSSemDel_7:
                    11815   ; }
                    11816   ; switch (opt) {
080038A8  102E 000F 11817          move.b    15(A6),D0
080038AC  C0BC 0000 11818          and.l     #255,D0
080038B0  00FF      
080038B2  0C80 0000 11819          cmp.l     #1,D0
080038B6  0001      
080038B8  6700 0048 11820          beq       OSSemDel_11
080038BC  6200 009E 11821          bhi       OSSemDel_8
080038C0  4A80      11822          tst.l     D0
080038C2  6704      11823          beq.s     OSSemDel_10
080038C4  6000 0096 11824          bra       OSSemDel_8
                    11825   OSSemDel_10:
                    11826   ; case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
                    11827   ; if (tasks_waiting == OS_FALSE) {
080038C8  4A05      11828          tst.b     D5
080038CA  6628      11829          bne.s     OSSemDel_13
                    11830   ; #if OS_EVENT_NAME_EN > 0u
                    11831   ; pevent->OSEventName    = (INT8U *)(void *)"?";
080038CC  41F9 0800 11832          lea       @ucos_ii_1.L,A0
080038D0  57FE      
080038D2  2242      11833          move.l    D2,A1
080038D4  2348 0012 11834          move.l    A0,18(A1)
                    11835   ; #endif
                    11836   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
080038D8  2042      11837          move.l    D2,A0
080038DA  4210      11838          clr.b     (A0)
                    11839   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
080038DC  2042      11840          move.l    D2,A0
080038DE  2152 0002 11841          move.l    (A2),2(A0)
                    11842   ; pevent->OSEventCnt     = 0u;
080038E2  2042      11843          move.l    D2,A0
080038E4  4268 0006 11844          clr.w     6(A0)
                    11845   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
080038E8  2482      11846          move.l    D2,(A2)
                    11847   ; OS_EXIT_CRITICAL();
080038EA  46DF      11848          dc.w      18143
                    11849   ; *perr                  = OS_ERR_NONE;
080038EC  2043      11850          move.l    D3,A0
080038EE  4210      11851          clr.b     (A0)
                    11852   ; pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
080038F0  4284      11853          clr.l     D4
080038F2  600A      11854          bra.s     OSSemDel_14
                    11855   OSSemDel_13:
                    11856   ; } else {
                    11857   ; OS_EXIT_CRITICAL();
080038F4  46DF      11858          dc.w      18143
                    11859   ; *perr                  = OS_ERR_TASK_WAITING;
080038F6  2043      11860          move.l    D3,A0
080038F8  10BC 0049 11861          move.b    #73,(A0)
                    11862   ; pevent_return          = pevent;
080038FC  2802      11863          move.l    D2,D4
                    11864   OSSemDel_14:
                    11865   ; }
                    11866   ; break;
080038FE  6000 0066 11867          bra       OSSemDel_9
                    11868   OSSemDel_11:
                    11869   ; case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
                    11870   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                    11871   OSSemDel_15:
08003902  2042      11872          move.l    D2,A0
08003904  1028 0008 11873          move.b    8(A0),D0
08003908  671E      11874          beq.s     OSSemDel_17
                    11875   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
0800390A  4878 0002 11876          pea       2
0800390E  4878 0001 11877          pea       1
08003912  42A7      11878          clr.l     -(A7)
08003914  2F02      11879          move.l    D2,-(A7)
08003916  4EB9 0800 11880          jsr       _OS_EventTaskRdy
0800391A  09AA      
0800391C  DEFC 0010 11881          add.w     #16,A7
08003920  C0BC 0000 11882          and.l     #255,D0
08003924  00FF      
08003926  60DA      11883          bra       OSSemDel_15
                    11884   OSSemDel_17:
                    11885   ; }
                    11886   ; #if OS_EVENT_NAME_EN > 0u
                    11887   ; pevent->OSEventName    = (INT8U *)(void *)"?";
08003928  41F9 0800 11888          lea       @ucos_ii_1.L,A0
0800392C  57FE      
0800392E  2242      11889          move.l    D2,A1
08003930  2348 0012 11890          move.l    A0,18(A1)
                    11891   ; #endif
                    11892   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
08003934  2042      11893          move.l    D2,A0
08003936  4210      11894          clr.b     (A0)
                    11895   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
08003938  2042      11896          move.l    D2,A0
0800393A  2152 0002 11897          move.l    (A2),2(A0)
                    11898   ; pevent->OSEventCnt     = 0u;
0800393E  2042      11899          move.l    D2,A0
08003940  4268 0006 11900          clr.w     6(A0)
                    11901   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
08003944  2482      11902          move.l    D2,(A2)
                    11903   ; OS_EXIT_CRITICAL();
08003946  46DF      11904          dc.w      18143
                    11905   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
08003948  0C05 0001 11906          cmp.b     #1,D5
0800394C  6606      11907          bne.s     OSSemDel_18
                    11908   ; OS_Sched();                               /* Find highest priority task ready to run  */
0800394E  4EB9 0800 11909          jsr       _OS_Sched
08003952  0F8A      
                    11910   OSSemDel_18:
                    11911   ; }
                    11912   ; *perr                  = OS_ERR_NONE;
08003954  2043      11913          move.l    D3,A0
08003956  4210      11914          clr.b     (A0)
                    11915   ; pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
08003958  4284      11916          clr.l     D4
                    11917   ; break;
0800395A  600A      11918          bra.s     OSSemDel_9
                    11919   OSSemDel_8:
                    11920   ; default:
                    11921   ; OS_EXIT_CRITICAL();
0800395C  46DF      11922          dc.w      18143
                    11923   ; *perr                  = OS_ERR_INVALID_OPT;
0800395E  2043      11924          move.l    D3,A0
08003960  10BC 0007 11925          move.b    #7,(A0)
                    11926   ; pevent_return          = pevent;
08003964  2802      11927          move.l    D2,D4
                    11928   ; break;
                    11929   OSSemDel_9:
                    11930   ; }
                    11931   ; return (pevent_return);
08003966  2004      11932          move.l    D4,D0
                    11933   OSSemDel_3:
08003968  4CDF 043C 11934          movem.l   (A7)+,D2/D3/D4/D5/A2
0800396C  4E5E      11935          unlk      A6
0800396E  4E75      11936          rts
                    11937   ; }
                    11938   ; #endif
                    11939   ; /*$PAGE*/
                    11940   ; /*
                    11941   ; *********************************************************************************************************
                    11942   ; *                                          PEND ON SEMAPHORE
                    11943   ; *
                    11944   ; * Description: This function waits for a semaphore.
                    11945   ; *
                    11946   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    11947   ; *                            semaphore.
                    11948   ; *
                    11949   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    11950   ; *                            wait for the resource up to the amount of time specified by this argument.
                    11951   ; *                            If you specify 0, however, your task will wait forever at the specified
                    11952   ; *                            semaphore or, until the resource becomes available (or the event occurs).
                    11953   ; *
                    11954   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    11955   ; *                            messages are:
                    11956   ; *
                    11957   ; *                            OS_ERR_NONE         The call was successful and your task owns the resource
                    11958   ; *                                                or, the event you are waiting for occurred.
                    11959   ; *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
                    11960   ; *                                                'timeout'.
                    11961   ; *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
                    11962   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    11963   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    11964   ; *                                                would lead to a suspension.
                    11965   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    11966   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    11967   ; *
                    11968   ; * Returns    : none
                    11969   ; *********************************************************************************************************
                    11970   ; */
                    11971   ; /*$PAGE*/
                    11972   ; void  OSSemPend (OS_EVENT  *pevent,
                    11973   ; INT32U     timeout,
                    11974   ; INT8U     *perr)
                    11975   ; {
                    11976   _OSSemPend:
08003970  4E56 0000 11977          link      A6,#0
08003974  48E7 3020 11978          movem.l   D2/D3/A2,-(A7)
08003978  45F9 0800 11979          lea       _OSTCBCur.L,A2
0800397C  042C      
0800397E  242E 0010 11980          move.l    16(A6),D2
08003982  262E 0008 11981          move.l    8(A6),D3
                    11982   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11983   ; OS_CPU_SR  cpu_sr = 0u;
                    11984   ; #endif
                    11985   ; #ifdef OS_SAFETY_CRITICAL
                    11986   ; if (perr == (INT8U *)0) {
                    11987   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11988   ; return;
                    11989   ; }
                    11990   ; #endif
                    11991   ; #if OS_ARG_CHK_EN > 0u
                    11992   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11993   ; *perr = OS_ERR_PEVENT_NULL;
                    11994   ; return;
                    11995   ; }
                    11996   ; #endif
                    11997   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
08003986  2043      11998          move.l    D3,A0
08003988  1010      11999          move.b    (A0),D0
0800398A  0C00 0003 12000          cmp.b     #3,D0
0800398E  670A      12001          beq.s     OSSemPend_1
                    12002   ; *perr = OS_ERR_EVENT_TYPE;
08003990  2042      12003          move.l    D2,A0
08003992  10BC 0001 12004          move.b    #1,(A0)
                    12005   ; return;
08003996  6000 00E0 12006          bra       OSSemPend_3
                    12007   OSSemPend_1:
                    12008   ; }
                    12009   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0800399A  1039 0800 12010          move.b    _OSIntNesting.L,D0
0800399E  0312      
080039A0  0C00 0000 12011          cmp.b     #0,D0
080039A4  630A      12012          bls.s     OSSemPend_4
                    12013   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
080039A6  2042      12014          move.l    D2,A0
080039A8  10BC 0002 12015          move.b    #2,(A0)
                    12016   ; return;
080039AC  6000 00CA 12017          bra       OSSemPend_3
                    12018   OSSemPend_4:
                    12019   ; }
                    12020   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
080039B0  1039 0800 12021          move.b    _OSLockNesting.L,D0
080039B4  0314      
080039B6  0C00 0000 12022          cmp.b     #0,D0
080039BA  630A      12023          bls.s     OSSemPend_6
                    12024   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
080039BC  2042      12025          move.l    D2,A0
080039BE  10BC 000D 12026          move.b    #13,(A0)
                    12027   ; return;
080039C2  6000 00B4 12028          bra       OSSemPend_3
                    12029   OSSemPend_6:
                    12030   ; }
                    12031   ; OS_ENTER_CRITICAL();
080039C6  40E7      12032          dc.w      16615
080039C8  007C      12033          dc.w      124
080039CA  0700      12034          dc.w      1792
                    12035   ; if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
080039CC  2043      12036          move.l    D3,A0
080039CE  3028 0006 12037          move.w    6(A0),D0
080039D2  0C40 0000 12038          cmp.w     #0,D0
080039D6  6312      12039          bls.s     OSSemPend_8
                    12040   ; pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
080039D8  2003      12041          move.l    D3,D0
080039DA  5C80      12042          addq.l    #6,D0
080039DC  2040      12043          move.l    D0,A0
080039DE  5350      12044          subq.w    #1,(A0)
                    12045   ; OS_EXIT_CRITICAL();
080039E0  46DF      12046          dc.w      18143
                    12047   ; *perr = OS_ERR_NONE;
080039E2  2042      12048          move.l    D2,A0
080039E4  4210      12049          clr.b     (A0)
                    12050   ; return;
080039E6  6000 0090 12051          bra       OSSemPend_3
                    12052   OSSemPend_8:
                    12053   ; }
                    12054   ; /* Otherwise, must wait until event occurs       */
                    12055   ; OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
080039EA  2052      12056          move.l    (A2),A0
080039EC  0028 0001 12057          or.b      #1,50(A0)
080039F0  0032      
                    12058   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
080039F2  2052      12059          move.l    (A2),A0
080039F4  4228 0033 12060          clr.b     51(A0)
                    12061   ; OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
080039F8  2052      12062          move.l    (A2),A0
080039FA  216E 000C 12063          move.l    12(A6),46(A0)
080039FE  002E      
                    12064   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
08003A00  2F03      12065          move.l    D3,-(A7)
08003A02  4EB9 0800 12066          jsr       _OS_EventTaskWait
08003A06  0A8E      
08003A08  584F      12067          addq.w    #4,A7
                    12068   ; OS_EXIT_CRITICAL();
08003A0A  46DF      12069          dc.w      18143
                    12070   ; OS_Sched();                                       /* Find next highest priority task ready         */
08003A0C  4EB9 0800 12071          jsr       _OS_Sched
08003A10  0F8A      
                    12072   ; OS_ENTER_CRITICAL();
08003A12  40E7      12073          dc.w      16615
08003A14  007C      12074          dc.w      124
08003A16  0700      12075          dc.w      1792
                    12076   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
08003A18  2052      12077          move.l    (A2),A0
08003A1A  1028 0033 12078          move.b    51(A0),D0
08003A1E  C0BC 0000 12079          and.l     #255,D0
08003A22  00FF      
08003A24  0C80 0000 12080          cmp.l     #1,D0
08003A28  0001      
08003A2A  6720      12081          beq.s     OSSemPend_14
08003A2C  6206      12082          bhi.s     OSSemPend_16
08003A2E  4A80      12083          tst.l     D0
08003A30  670C      12084          beq.s     OSSemPend_12
08003A32  6018      12085          bra.s     OSSemPend_14
                    12086   OSSemPend_16:
08003A34  0C80 0000 12087          cmp.l     #2,D0
08003A38  0002      
08003A3A  6708      12088          beq.s     OSSemPend_13
08003A3C  600E      12089          bra.s     OSSemPend_14
                    12090   OSSemPend_12:
                    12091   ; case OS_STAT_PEND_OK:
                    12092   ; *perr = OS_ERR_NONE;
08003A3E  2042      12093          move.l    D2,A0
08003A40  4210      12094          clr.b     (A0)
                    12095   ; break;
08003A42  601A      12096          bra.s     OSSemPend_11
                    12097   OSSemPend_13:
                    12098   ; case OS_STAT_PEND_ABORT:
                    12099   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
08003A44  2042      12100          move.l    D2,A0
08003A46  10BC 000E 12101          move.b    #14,(A0)
                    12102   ; break;
08003A4A  6012      12103          bra.s     OSSemPend_11
                    12104   OSSemPend_14:
                    12105   ; case OS_STAT_PEND_TO:
                    12106   ; default:
                    12107   ; OS_EventTaskRemove(OSTCBCur, pevent);
08003A4C  2F03      12108          move.l    D3,-(A7)
08003A4E  2F12      12109          move.l    (A2),-(A7)
08003A50  4EB9 0800 12110          jsr       _OS_EventTaskRemove
08003A54  0BB0      
08003A56  504F      12111          addq.w    #8,A7
                    12112   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
08003A58  2042      12113          move.l    D2,A0
08003A5A  10BC 000A 12114          move.b    #10,(A0)
                    12115   ; break;
                    12116   OSSemPend_11:
                    12117   ; }
                    12118   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
08003A5E  2052      12119          move.l    (A2),A0
08003A60  4228 0032 12120          clr.b     50(A0)
                    12121   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
08003A64  2052      12122          move.l    (A2),A0
08003A66  4228 0033 12123          clr.b     51(A0)
                    12124   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
08003A6A  2052      12125          move.l    (A2),A0
08003A6C  42A8 001C 12126          clr.l     28(A0)
                    12127   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12128   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
08003A70  2052      12129          move.l    (A2),A0
08003A72  42A8 0020 12130          clr.l     32(A0)
                    12131   ; #endif
                    12132   ; OS_EXIT_CRITICAL();
08003A76  46DF      12133          dc.w      18143
                    12134   OSSemPend_3:
08003A78  4CDF 040C 12135          movem.l   (A7)+,D2/D3/A2
08003A7C  4E5E      12136          unlk      A6
08003A7E  4E75      12137          rts
                    12138   ; }
                    12139   ; /*$PAGE*/
                    12140   ; /*
                    12141   ; *********************************************************************************************************
                    12142   ; *                                    ABORT WAITING ON A SEMAPHORE
                    12143   ; *
                    12144   ; * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
                    12145   ; *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
                    12146   ; *              the semaphore via OSSemPost().
                    12147   ; *
                    12148   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12149   ; *                            semaphore.
                    12150   ; *
                    12151   ; *              opt           determines the type of ABORT performed:
                    12152   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    12153   ; *                                                     semaphore
                    12154   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    12155   ; *                                                     semaphore
                    12156   ; *
                    12157   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12158   ; *                            messages are:
                    12159   ; *
                    12160   ; *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
                    12161   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
                    12162   ; *                                                and informed of the aborted wait; check return value
                    12163   ; *                                                for the number of tasks whose wait on the semaphore
                    12164   ; *                                                was aborted.
                    12165   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12166   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12167   ; *
                    12168   ; * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
                    12169   ; *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
                    12170   ; *********************************************************************************************************
                    12171   ; */
                    12172   ; #if OS_SEM_PEND_ABORT_EN > 0u
                    12173   ; INT8U  OSSemPendAbort (OS_EVENT  *pevent,
                    12174   ; INT8U      opt,
                    12175   ; INT8U     *perr)
                    12176   ; {
                    12177   _OSSemPendAbort:
08003A80  4E56 0000 12178          link      A6,#0
08003A84  48E7 3800 12179          movem.l   D2/D3/D4,-(A7)
08003A88  242E 0008 12180          move.l    8(A6),D2
08003A8C  282E 0010 12181          move.l    16(A6),D4
                    12182   ; INT8U      nbr_tasks;
                    12183   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12184   ; OS_CPU_SR  cpu_sr = 0u;
                    12185   ; #endif
                    12186   ; #ifdef OS_SAFETY_CRITICAL
                    12187   ; if (perr == (INT8U *)0) {
                    12188   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12189   ; return (0u);
                    12190   ; }
                    12191   ; #endif
                    12192   ; #if OS_ARG_CHK_EN > 0u
                    12193   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12194   ; *perr = OS_ERR_PEVENT_NULL;
                    12195   ; return (0u);
                    12196   ; }
                    12197   ; #endif
                    12198   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
08003A90  2042      12199          move.l    D2,A0
08003A92  1010      12200          move.b    (A0),D0
08003A94  0C00 0003 12201          cmp.b     #3,D0
08003A98  670C      12202          beq.s     OSSemPendAbort_1
                    12203   ; *perr = OS_ERR_EVENT_TYPE;
08003A9A  2044      12204          move.l    D4,A0
08003A9C  10BC 0001 12205          move.b    #1,(A0)
                    12206   ; return (0u);
08003AA0  4200      12207          clr.b     D0
08003AA2  6000 0092 12208          bra       OSSemPendAbort_3
                    12209   OSSemPendAbort_1:
                    12210   ; }
                    12211   ; OS_ENTER_CRITICAL();
08003AA6  40E7      12212          dc.w      16615
08003AA8  007C      12213          dc.w      124
08003AAA  0700      12214          dc.w      1792
                    12215   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
08003AAC  2042      12216          move.l    D2,A0
08003AAE  1028 0008 12217          move.b    8(A0),D0
08003AB2  6700 007A 12218          beq       OSSemPendAbort_4
                    12219   ; nbr_tasks = 0u;
08003AB6  4203      12220          clr.b     D3
                    12221   ; switch (opt) {
08003AB8  102E 000F 12222          move.b    15(A6),D0
08003ABC  C0BC 0000 12223          and.l     #255,D0
08003AC0  00FF      
08003AC2  0C80 0000 12224          cmp.l     #1,D0
08003AC6  0001      
08003AC8  670A      12225          beq.s     OSSemPendAbort_8
08003ACA  6200 0032 12226          bhi       OSSemPendAbort_9
08003ACE  4A80      12227          tst.l     D0
08003AD0  672C      12228          beq.s     OSSemPendAbort_9
08003AD2  602A      12229          bra.s     OSSemPendAbort_9
                    12230   OSSemPendAbort_8:
                    12231   ; case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                    12232   ; while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
                    12233   OSSemPendAbort_11:
08003AD4  2042      12234          move.l    D2,A0
08003AD6  1028 0008 12235          move.b    8(A0),D0
08003ADA  6720      12236          beq.s     OSSemPendAbort_13
                    12237   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
08003ADC  4878 0002 12238          pea       2
08003AE0  4878 0001 12239          pea       1
08003AE4  42A7      12240          clr.l     -(A7)
08003AE6  2F02      12241          move.l    D2,-(A7)
08003AE8  4EB9 0800 12242          jsr       _OS_EventTaskRdy
08003AEC  09AA      
08003AEE  DEFC 0010 12243          add.w     #16,A7
08003AF2  C0BC 0000 12244          and.l     #255,D0
08003AF6  00FF      
                    12245   ; nbr_tasks++;
08003AF8  5203      12246          addq.b    #1,D3
08003AFA  60D8      12247          bra       OSSemPendAbort_11
                    12248   OSSemPendAbort_13:
                    12249   ; }
                    12250   ; break;
08003AFC  601E      12251          bra.s     OSSemPendAbort_7
                    12252   OSSemPendAbort_9:
                    12253   ; case OS_PEND_OPT_NONE:
                    12254   ; default:                                  /* No,  ready HPT       waiting on semaphore     */
                    12255   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
08003AFE  4878 0002 12256          pea       2
08003B02  4878 0001 12257          pea       1
08003B06  42A7      12258          clr.l     -(A7)
08003B08  2F02      12259          move.l    D2,-(A7)
08003B0A  4EB9 0800 12260          jsr       _OS_EventTaskRdy
08003B0E  09AA      
08003B10  DEFC 0010 12261          add.w     #16,A7
08003B14  C0BC 0000 12262          and.l     #255,D0
08003B18  00FF      
                    12263   ; nbr_tasks++;
08003B1A  5203      12264          addq.b    #1,D3
                    12265   ; break;
                    12266   OSSemPendAbort_7:
                    12267   ; }
                    12268   ; OS_EXIT_CRITICAL();
08003B1C  46DF      12269          dc.w      18143
                    12270   ; OS_Sched();                                   /* Find HPT ready to run                         */
08003B1E  4EB9 0800 12271          jsr       _OS_Sched
08003B22  0F8A      
                    12272   ; *perr = OS_ERR_PEND_ABORT;
08003B24  2044      12273          move.l    D4,A0
08003B26  10BC 000E 12274          move.b    #14,(A0)
                    12275   ; return (nbr_tasks);
08003B2A  1003      12276          move.b    D3,D0
08003B2C  6008      12277          bra.s     OSSemPendAbort_3
                    12278   OSSemPendAbort_4:
                    12279   ; }
                    12280   ; OS_EXIT_CRITICAL();
08003B2E  46DF      12281          dc.w      18143
                    12282   ; *perr = OS_ERR_NONE;
08003B30  2044      12283          move.l    D4,A0
08003B32  4210      12284          clr.b     (A0)
                    12285   ; return (0u);                                      /* No tasks waiting on semaphore                 */
08003B34  4200      12286          clr.b     D0
                    12287   OSSemPendAbort_3:
08003B36  4CDF 001C 12288          movem.l   (A7)+,D2/D3/D4
08003B3A  4E5E      12289          unlk      A6
08003B3C  4E75      12290          rts
                    12291   ; }
                    12292   ; #endif
                    12293   ; /*$PAGE*/
                    12294   ; /*
                    12295   ; *********************************************************************************************************
                    12296   ; *                                         POST TO A SEMAPHORE
                    12297   ; *
                    12298   ; * Description: This function signals a semaphore
                    12299   ; *
                    12300   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12301   ; *                            semaphore.
                    12302   ; *
                    12303   ; * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
                    12304   ; *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
                    12305   ; *                                  signaled the semaphore more often than you waited on it with either
                    12306   ; *                                  OSSemAccept() or OSSemPend().
                    12307   ; *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
                    12308   ; *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12309   ; *********************************************************************************************************
                    12310   ; */
                    12311   ; INT8U  OSSemPost (OS_EVENT *pevent)
                    12312   ; {
                    12313   _OSSemPost:
08003B3E  4E56 0000 12314          link      A6,#0
08003B42  2F02      12315          move.l    D2,-(A7)
08003B44  242E 0008 12316          move.l    8(A6),D2
                    12317   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12318   ; OS_CPU_SR  cpu_sr = 0u;
                    12319   ; #endif
                    12320   ; #if OS_ARG_CHK_EN > 0u
                    12321   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12322   ; return (OS_ERR_PEVENT_NULL);
                    12323   ; }
                    12324   ; #endif
                    12325   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
08003B48  2042      12326          move.l    D2,A0
08003B4A  1010      12327          move.b    (A0),D0
08003B4C  0C00 0003 12328          cmp.b     #3,D0
08003B50  6706      12329          beq.s     OSSemPost_1
                    12330   ; return (OS_ERR_EVENT_TYPE);
08003B52  7001      12331          moveq     #1,D0
08003B54  6000 0054 12332          bra       OSSemPost_3
                    12333   OSSemPost_1:
                    12334   ; }
                    12335   ; OS_ENTER_CRITICAL();
08003B58  40E7      12336          dc.w      16615
08003B5A  007C      12337          dc.w      124
08003B5C  0700      12338          dc.w      1792
                    12339   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
08003B5E  2042      12340          move.l    D2,A0
08003B60  1028 0008 12341          move.b    8(A0),D0
08003B64  6726      12342          beq.s     OSSemPost_4
                    12343   ; /* Ready HPT waiting on event                    */
                    12344   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
08003B66  42A7      12345          clr.l     -(A7)
08003B68  4878 0001 12346          pea       1
08003B6C  42A7      12347          clr.l     -(A7)
08003B6E  2F02      12348          move.l    D2,-(A7)
08003B70  4EB9 0800 12349          jsr       _OS_EventTaskRdy
08003B74  09AA      
08003B76  DEFC 0010 12350          add.w     #16,A7
08003B7A  C0BC 0000 12351          and.l     #255,D0
08003B7E  00FF      
                    12352   ; OS_EXIT_CRITICAL();
08003B80  46DF      12353          dc.w      18143
                    12354   ; OS_Sched();                                   /* Find HPT ready to run                         */
08003B82  4EB9 0800 12355          jsr       _OS_Sched
08003B86  0F8A      
                    12356   ; return (OS_ERR_NONE);
08003B88  4200      12357          clr.b     D0
08003B8A  601E      12358          bra.s     OSSemPost_3
                    12359   OSSemPost_4:
                    12360   ; }
                    12361   ; if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
08003B8C  2042      12362          move.l    D2,A0
08003B8E  3028 0006 12363          move.w    6(A0),D0
08003B92  0C40 FFFF 12364          cmp.w     #65535,D0
08003B96  640E      12365          bhs.s     OSSemPost_6
                    12366   ; pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
08003B98  2002      12367          move.l    D2,D0
08003B9A  5C80      12368          addq.l    #6,D0
08003B9C  2040      12369          move.l    D0,A0
08003B9E  5250      12370          addq.w    #1,(A0)
                    12371   ; OS_EXIT_CRITICAL();
08003BA0  46DF      12372          dc.w      18143
                    12373   ; return (OS_ERR_NONE);
08003BA2  4200      12374          clr.b     D0
08003BA4  6004      12375          bra.s     OSSemPost_3
                    12376   OSSemPost_6:
                    12377   ; }
                    12378   ; OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
08003BA6  46DF      12379          dc.w      18143
                    12380   ; return (OS_ERR_SEM_OVF);
08003BA8  7033      12381          moveq     #51,D0
                    12382   OSSemPost_3:
08003BAA  241F      12383          move.l    (A7)+,D2
08003BAC  4E5E      12384          unlk      A6
08003BAE  4E75      12385          rts
                    12386   ; }
                    12387   ; /*$PAGE*/
                    12388   ; /*
                    12389   ; *********************************************************************************************************
                    12390   ; *                                          QUERY A SEMAPHORE
                    12391   ; *
                    12392   ; * Description: This function obtains information about a semaphore
                    12393   ; *
                    12394   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12395   ; *                            semaphore
                    12396   ; *
                    12397   ; *              p_sem_data    is a pointer to a structure that will contain information about the
                    12398   ; *                            semaphore.
                    12399   ; *
                    12400   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    12401   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
                    12402   ; *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
                    12403   ; *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
                    12404   ; *********************************************************************************************************
                    12405   ; */
                    12406   ; #if OS_SEM_QUERY_EN > 0u
                    12407   ; INT8U  OSSemQuery (OS_EVENT     *pevent,
                    12408   ; OS_SEM_DATA  *p_sem_data)
                    12409   ; {
                    12410   _OSSemQuery:
08003BB0  4E56 FFF8 12411          link      A6,#-8
08003BB4  48E7 3800 12412          movem.l   D2/D3/D4,-(A7)
08003BB8  242E 0008 12413          move.l    8(A6),D2
08003BBC  282E 000C 12414          move.l    12(A6),D4
                    12415   ; INT8U       i;
                    12416   ; OS_PRIO    *psrc;
                    12417   ; OS_PRIO    *pdest;
                    12418   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12419   ; OS_CPU_SR   cpu_sr = 0u;
                    12420   ; #endif
                    12421   ; #if OS_ARG_CHK_EN > 0u
                    12422   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12423   ; return (OS_ERR_PEVENT_NULL);
                    12424   ; }
                    12425   ; if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
                    12426   ; return (OS_ERR_PDATA_NULL);
                    12427   ; }
                    12428   ; #endif
                    12429   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
08003BC0  2042      12430          move.l    D2,A0
08003BC2  1010      12431          move.b    (A0),D0
08003BC4  0C00 0003 12432          cmp.b     #3,D0
08003BC8  6706      12433          beq.s     OSSemQuery_1
                    12434   ; return (OS_ERR_EVENT_TYPE);
08003BCA  7001      12435          moveq     #1,D0
08003BCC  6000 004C 12436          bra       OSSemQuery_3
                    12437   OSSemQuery_1:
                    12438   ; }
                    12439   ; OS_ENTER_CRITICAL();
08003BD0  40E7      12440          dc.w      16615
08003BD2  007C      12441          dc.w      124
08003BD4  0700      12442          dc.w      1792
                    12443   ; p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
08003BD6  2042      12444          move.l    D2,A0
08003BD8  2244      12445          move.l    D4,A1
08003BDA  1368 0008 12446          move.b    8(A0),10(A1)
08003BDE  000A      
                    12447   ; psrc                   = &pevent->OSEventTbl[0];
08003BE0  700A      12448          moveq     #10,D0
08003BE2  D082      12449          add.l     D2,D0
08003BE4  2D40 FFF8 12450          move.l    D0,-8(A6)
                    12451   ; pdest                  = &p_sem_data->OSEventTbl[0];
08003BE8  7002      12452          moveq     #2,D0
08003BEA  D084      12453          add.l     D4,D0
08003BEC  2D40 FFFC 12454          move.l    D0,-4(A6)
                    12455   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
08003BF0  4203      12456          clr.b     D3
                    12457   OSSemQuery_4:
08003BF2  0C03 0008 12458          cmp.b     #8,D3
08003BF6  6416      12459          bhs.s     OSSemQuery_6
                    12460   ; *pdest++ = *psrc++;
08003BF8  206E FFF8 12461          move.l    -8(A6),A0
08003BFC  52AE FFF8 12462          addq.l    #1,-8(A6)
08003C00  226E FFFC 12463          move.l    -4(A6),A1
08003C04  52AE FFFC 12464          addq.l    #1,-4(A6)
08003C08  1290      12465          move.b    (A0),(A1)
08003C0A  5203      12466          addq.b    #1,D3
08003C0C  60E4      12467          bra       OSSemQuery_4
                    12468   OSSemQuery_6:
                    12469   ; }
                    12470   ; p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
08003C0E  2042      12471          move.l    D2,A0
08003C10  2244      12472          move.l    D4,A1
08003C12  32A8 0006 12473          move.w    6(A0),(A1)
                    12474   ; OS_EXIT_CRITICAL();
08003C16  46DF      12475          dc.w      18143
                    12476   ; return (OS_ERR_NONE);
08003C18  4200      12477          clr.b     D0
                    12478   OSSemQuery_3:
08003C1A  4CDF 001C 12479          movem.l   (A7)+,D2/D3/D4
08003C1E  4E5E      12480          unlk      A6
08003C20  4E75      12481          rts
                    12482   ; }
                    12483   ; #endif                                                     /* OS_SEM_QUERY_EN                          */
                    12484   ; /*$PAGE*/
                    12485   ; /*
                    12486   ; *********************************************************************************************************
                    12487   ; *                                            SET SEMAPHORE
                    12488   ; *
                    12489   ; * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
                    12490   ; *              this value would be 0.
                    12491   ; *
                    12492   ; *              You would typically use this function when a semaphore is used as a signaling mechanism
                    12493   ; *              and, you want to reset the count value.
                    12494   ; *
                    12495   ; * Arguments  : pevent     is a pointer to the event control block
                    12496   ; *
                    12497   ; *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
                    12498   ; *                         semaphore count.
                    12499   ; *
                    12500   ; *              perr       is a pointer to an error code returned by the function as follows:
                    12501   ; *
                    12502   ; *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
                    12503   ; *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
                    12504   ; *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
                    12505   ; *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
                    12506   ; *********************************************************************************************************
                    12507   ; */
                    12508   ; #if OS_SEM_SET_EN > 0u
                    12509   ; void  OSSemSet (OS_EVENT  *pevent,
                    12510   ; INT16U     cnt,
                    12511   ; INT8U     *perr)
                    12512   ; {
                    12513   _OSSemSet:
08003C22  4E56 0000 12514          link      A6,#0
08003C26  48E7 3000 12515          movem.l   D2/D3,-(A7)
08003C2A  242E 0008 12516          move.l    8(A6),D2
08003C2E  262E 0010 12517          move.l    16(A6),D3
                    12518   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12519   ; OS_CPU_SR  cpu_sr = 0u;
                    12520   ; #endif
                    12521   ; #ifdef OS_SAFETY_CRITICAL
                    12522   ; if (perr == (INT8U *)0) {
                    12523   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12524   ; return;
                    12525   ; }
                    12526   ; #endif
                    12527   ; #if OS_ARG_CHK_EN > 0u
                    12528   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12529   ; *perr = OS_ERR_PEVENT_NULL;
                    12530   ; return;
                    12531   ; }
                    12532   ; #endif
                    12533   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
08003C32  2042      12534          move.l    D2,A0
08003C34  1010      12535          move.b    (A0),D0
08003C36  0C00 0003 12536          cmp.b     #3,D0
08003C3A  670A      12537          beq.s     OSSemSet_1
                    12538   ; *perr = OS_ERR_EVENT_TYPE;
08003C3C  2043      12539          move.l    D3,A0
08003C3E  10BC 0001 12540          move.b    #1,(A0)
                    12541   ; return;
08003C42  6000 003C 12542          bra       OSSemSet_3
                    12543   OSSemSet_1:
                    12544   ; }
                    12545   ; OS_ENTER_CRITICAL();
08003C46  40E7      12546          dc.w      16615
08003C48  007C      12547          dc.w      124
08003C4A  0700      12548          dc.w      1792
                    12549   ; *perr = OS_ERR_NONE;
08003C4C  2043      12550          move.l    D3,A0
08003C4E  4210      12551          clr.b     (A0)
                    12552   ; if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
08003C50  2042      12553          move.l    D2,A0
08003C52  3028 0006 12554          move.w    6(A0),D0
08003C56  0C40 0000 12555          cmp.w     #0,D0
08003C5A  630A      12556          bls.s     OSSemSet_4
                    12557   ; pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
08003C5C  2042      12558          move.l    D2,A0
08003C5E  316E 000E 12559          move.w    14(A6),6(A0)
08003C62  0006      
08003C64  6018      12560          bra.s     OSSemSet_7
                    12561   OSSemSet_4:
                    12562   ; } else {                                          /* No                                            */
                    12563   ; if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
08003C66  2042      12564          move.l    D2,A0
08003C68  1028 0008 12565          move.b    8(A0),D0
08003C6C  660A      12566          bne.s     OSSemSet_6
                    12567   ; pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
08003C6E  2042      12568          move.l    D2,A0
08003C70  316E 000E 12569          move.w    14(A6),6(A0)
08003C74  0006      
08003C76  6006      12570          bra.s     OSSemSet_7
                    12571   OSSemSet_6:
                    12572   ; } else {
                    12573   ; *perr              = OS_ERR_TASK_WAITING;
08003C78  2043      12574          move.l    D3,A0
08003C7A  10BC 0049 12575          move.b    #73,(A0)
                    12576   OSSemSet_7:
                    12577   ; }
                    12578   ; }
                    12579   ; OS_EXIT_CRITICAL();
08003C7E  46DF      12580          dc.w      18143
                    12581   OSSemSet_3:
08003C80  4CDF 000C 12582          movem.l   (A7)+,D2/D3
08003C84  4E5E      12583          unlk      A6
08003C86  4E75      12584          rts
                    12585   ; /*
                    12586   ; *********************************************************************************************************
                    12587   ; *                                                uC/OS-II
                    12588   ; *                                          The Real-Time Kernel
                    12589   ; *                                            TASK MANAGEMENT
                    12590   ; *
                    12591   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    12592   ; *                                           All Rights Reserved
                    12593   ; *
                    12594   ; * File    : OS_TASK.C
                    12595   ; * By      : Jean J. Labrosse
                    12596   ; * Version : V2.92.07
                    12597   ; *
                    12598   ; * LICENSING TERMS:
                    12599   ; * ---------------
                    12600   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    12601   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    12602   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    12603   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    12604   ; * licensing fee.
                    12605   ; *********************************************************************************************************
                    12606   ; */
                    12607   ; #define  MICRIUM_SOURCE
                    12608   ; #ifndef  OS_MASTER_FILE
                    12609   ; #include <ucos_ii.h>
                    12610   ; #endif
                    12611   ; /*$PAGE*/
                    12612   ; /*
                    12613   ; *********************************************************************************************************
                    12614   ; *                                      CHANGE PRIORITY OF A TASK
                    12615   ; *
                    12616   ; * Description: This function allows you to change the priority of a task dynamically.  Note that the new
                    12617   ; *              priority MUST be available.
                    12618   ; *
                    12619   ; * Arguments  : oldp     is the old priority
                    12620   ; *
                    12621   ; *              newp     is the new priority
                    12622   ; *
                    12623   ; * Returns    : OS_ERR_NONE            is the call was successful
                    12624   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    12625   ; *                                     (i.e. >= OS_LOWEST_PRIO)
                    12626   ; *              OS_ERR_PRIO_EXIST      if the new priority already exist.
                    12627   ; *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
                    12628   ; *                                     not exist.
                    12629   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
                    12630   ; *********************************************************************************************************
                    12631   ; */
                    12632   ; #if OS_TASK_CHANGE_PRIO_EN > 0u
                    12633   ; INT8U  OSTaskChangePrio (INT8U  oldprio,
                    12634   ; INT8U  newprio)
                    12635   ; {
                    12636   _OSTaskChangePrio:
08003C88  4E56 FFFC 12637          link      A6,#-4
08003C8C  48E7 3F38 12638          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
08003C90  47F9 0800 12639          lea       _OSRdyTbl.L,A3
08003C94  031C      
08003C96  49F9 0800 12640          lea       _OSTCBPrioTbl.L,A4
08003C9A  043C      
                    12641   ; #if (OS_EVENT_EN)
                    12642   ; OS_EVENT  *pevent;
                    12643   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12644   ; OS_EVENT **pevents;
                    12645   ; #endif
                    12646   ; #endif
                    12647   ; OS_TCB    *ptcb;
                    12648   ; INT8U      y_new;
                    12649   ; INT8U      x_new;
                    12650   ; INT8U      y_old;
                    12651   ; OS_PRIO    bity_new;
                    12652   ; OS_PRIO    bitx_new;
                    12653   ; OS_PRIO    bity_old;
                    12654   ; OS_PRIO    bitx_old;
                    12655   ; #if OS_CRITICAL_METHOD == 3u
                    12656   ; OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
                    12657   ; #endif
                    12658   ; /*$PAGE*/
                    12659   ; #if OS_ARG_CHK_EN > 0u
                    12660   ; if (oldprio >= OS_LOWEST_PRIO) {
                    12661   ; if (oldprio != OS_PRIO_SELF) {
                    12662   ; return (OS_ERR_PRIO_INVALID);
                    12663   ; }
                    12664   ; }
                    12665   ; if (newprio >= OS_LOWEST_PRIO) {
                    12666   ; return (OS_ERR_PRIO_INVALID);
                    12667   ; }
                    12668   ; #endif
                    12669   ; OS_ENTER_CRITICAL();
08003C9C  40E7      12670          dc.w      16615
08003C9E  007C      12671          dc.w      124
08003CA0  0700      12672          dc.w      1792
                    12673   ; if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
08003CA2  102E 000F 12674          move.b    15(A6),D0
08003CA6  C0BC 0000 12675          and.l     #255,D0
08003CAA  00FF      
08003CAC  E588      12676          lsl.l     #2,D0
08003CAE  2034 0800 12677          move.l    0(A4,D0.L),D0
08003CB2  6708      12678          beq.s     OSTaskChangePrio_1
                    12679   ; OS_EXIT_CRITICAL();
08003CB4  46DF      12680          dc.w      18143
                    12681   ; return (OS_ERR_PRIO_EXIST);
08003CB6  7028      12682          moveq     #40,D0
08003CB8  6000 01E2 12683          bra       OSTaskChangePrio_3
                    12684   OSTaskChangePrio_1:
                    12685   ; }
                    12686   ; if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
08003CBC  102E 000B 12687          move.b    11(A6),D0
08003CC0  0C00 00FF 12688          cmp.b     #255,D0
08003CC4  660C      12689          bne.s     OSTaskChangePrio_4
                    12690   ; oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
08003CC6  2079 0800 12691          move.l    _OSTCBCur.L,A0
08003CCA  042C      
08003CCC  1D68 0034 12692          move.b    52(A0),11(A6)
08003CD0  000B      
                    12693   OSTaskChangePrio_4:
                    12694   ; }
                    12695   ; ptcb = OSTCBPrioTbl[oldprio];
08003CD2  102E 000B 12696          move.b    11(A6),D0
08003CD6  C0BC 0000 12697          and.l     #255,D0
08003CDA  00FF      
08003CDC  E588      12698          lsl.l     #2,D0
08003CDE  2634 0800 12699          move.l    0(A4,D0.L),D3
                    12700   ; if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
08003CE2  4A83      12701          tst.l     D3
08003CE4  6608      12702          bne.s     OSTaskChangePrio_6
                    12703   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
08003CE6  46DF      12704          dc.w      18143
                    12705   ; return (OS_ERR_PRIO);
08003CE8  7029      12706          moveq     #41,D0
08003CEA  6000 01B0 12707          bra       OSTaskChangePrio_3
                    12708   OSTaskChangePrio_6:
                    12709   ; }
                    12710   ; if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
08003CEE  0C83 0000 12711          cmp.l     #1,D3
08003CF2  0001      
08003CF4  6608      12712          bne.s     OSTaskChangePrio_8
                    12713   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
08003CF6  46DF      12714          dc.w      18143
                    12715   ; return (OS_ERR_TASK_NOT_EXIST);
08003CF8  7043      12716          moveq     #67,D0
08003CFA  6000 01A0 12717          bra       OSTaskChangePrio_3
                    12718   OSTaskChangePrio_8:
                    12719   ; }
                    12720   ; #if OS_LOWEST_PRIO <= 63u
                    12721   ; y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
08003CFE  102E 000F 12722          move.b    15(A6),D0
08003D02  E608      12723          lsr.b     #3,D0
08003D04  1A00      12724          move.b    D0,D5
                    12725   ; x_new                 = (INT8U)(newprio & 0x07u);
08003D06  102E 000F 12726          move.b    15(A6),D0
08003D0A  C03C 0007 12727          and.b     #7,D0
08003D0E  1D40 FFFD 12728          move.b    D0,-3(A6)
                    12729   ; #else
                    12730   ; y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
                    12731   ; x_new                 = (INT8U)(newprio & 0x0Fu);
                    12732   ; #endif
                    12733   ; bity_new              = (OS_PRIO)(1uL << y_new);
08003D12  7001      12734          moveq     #1,D0
08003D14  CABC 0000 12735          and.l     #255,D5
08003D18  00FF      
08003D1A  EBA8      12736          lsl.l     D5,D0
08003D1C  1D40 FFFE 12737          move.b    D0,-2(A6)
                    12738   ; bitx_new              = (OS_PRIO)(1uL << x_new);
08003D20  7001      12739          moveq     #1,D0
08003D22  122E FFFD 12740          move.b    -3(A6),D1
08003D26  C2BC 0000 12741          and.l     #255,D1
08003D2A  00FF      
08003D2C  E3A8      12742          lsl.l     D1,D0
08003D2E  1E00      12743          move.b    D0,D7
                    12744   ; OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
08003D30  102E 000B 12745          move.b    11(A6),D0
08003D34  C0BC 0000 12746          and.l     #255,D0
08003D38  00FF      
08003D3A  E588      12747          lsl.l     #2,D0
08003D3C  42B4 0800 12748          clr.l     0(A4,D0.L)
                    12749   ; OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
08003D40  102E 000F 12750          move.b    15(A6),D0
08003D44  C0BC 0000 12751          and.l     #255,D0
08003D48  00FF      
08003D4A  E588      12752          lsl.l     #2,D0
08003D4C  2983 0800 12753          move.l    D3,0(A4,D0.L)
                    12754   ; y_old                 =  ptcb->OSTCBY;
08003D50  2043      12755          move.l    D3,A0
08003D52  1828 0036 12756          move.b    54(A0),D4
                    12757   ; bity_old              =  ptcb->OSTCBBitY;
08003D56  2043      12758          move.l    D3,A0
08003D58  1D68 0038 12759          move.b    56(A0),-1(A6)
08003D5C  FFFF      
                    12760   ; bitx_old              =  ptcb->OSTCBBitX;
08003D5E  2043      12761          move.l    D3,A0
08003D60  1C28 0037 12762          move.b    55(A0),D6
                    12763   ; if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
08003D64  C8BC 0000 12764          and.l     #255,D4
08003D68  00FF      
08003D6A  1033 4800 12765          move.b    0(A3,D4.L),D0
08003D6E  C006      12766          and.b     D6,D0
08003D70  673A      12767          beq.s     OSTaskChangePrio_10
                    12768   ; OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
08003D72  C8BC 0000 12769          and.l     #255,D4
08003D76  00FF      
08003D78  1006      12770          move.b    D6,D0
08003D7A  4600      12771          not.b     D0
08003D7C  C133 4800 12772          and.b     D0,0(A3,D4.L)
                    12773   ; if (OSRdyTbl[y_old] == 0u) {
08003D80  C8BC 0000 12774          and.l     #255,D4
08003D84  00FF      
08003D86  1033 4800 12775          move.b    0(A3,D4.L),D0
08003D8A  660C      12776          bne.s     OSTaskChangePrio_12
                    12777   ; OSRdyGrp &= (OS_PRIO)~bity_old;
08003D8C  102E FFFF 12778          move.b    -1(A6),D0
08003D90  4600      12779          not.b     D0
08003D92  C139 0800 12780          and.b     D0,_OSRdyGrp.L
08003D96  031A      
                    12781   OSTaskChangePrio_12:
                    12782   ; }
                    12783   ; OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
08003D98  102E FFFE 12784          move.b    -2(A6),D0
08003D9C  8139 0800 12785          or.b      D0,_OSRdyGrp.L
08003DA0  031A      
                    12786   ; OSRdyTbl[y_new] |= bitx_new;
08003DA2  CABC 0000 12787          and.l     #255,D5
08003DA6  00FF      
08003DA8  8F33 5800 12788          or.b      D7,0(A3,D5.L)
                    12789   OSTaskChangePrio_10:
                    12790   ; }
                    12791   ; #if (OS_EVENT_EN)
                    12792   ; pevent = ptcb->OSTCBEventPtr;
08003DAC  2043      12793          move.l    D3,A0
08003DAE  2428 001C 12794          move.l    28(A0),D2
                    12795   ; if (pevent != (OS_EVENT *)0) {
08003DB2  4A82      12796          tst.l     D2
08003DB4  6700 0048 12797          beq       OSTaskChangePrio_14
                    12798   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
08003DB8  2042      12799          move.l    D2,A0
08003DBA  C8BC 0000 12800          and.l     #255,D4
08003DBE  00FF      
08003DC0  D1C4      12801          add.l     D4,A0
08003DC2  1006      12802          move.b    D6,D0
08003DC4  4600      12803          not.b     D0
08003DC6  C128 000A 12804          and.b     D0,10(A0)
                    12805   ; if (pevent->OSEventTbl[y_old] == 0u) {
08003DCA  2042      12806          move.l    D2,A0
08003DCC  C8BC 0000 12807          and.l     #255,D4
08003DD0  00FF      
08003DD2  D1C4      12808          add.l     D4,A0
08003DD4  1028 000A 12809          move.b    10(A0),D0
08003DD8  660C      12810          bne.s     OSTaskChangePrio_16
                    12811   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
08003DDA  2042      12812          move.l    D2,A0
08003DDC  102E FFFF 12813          move.b    -1(A6),D0
08003DE0  4600      12814          not.b     D0
08003DE2  C128 0008 12815          and.b     D0,8(A0)
                    12816   OSTaskChangePrio_16:
                    12817   ; }
                    12818   ; pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
08003DE6  2042      12819          move.l    D2,A0
08003DE8  102E FFFE 12820          move.b    -2(A6),D0
08003DEC  8128 0008 12821          or.b      D0,8(A0)
                    12822   ; pevent->OSEventTbl[y_new] |= bitx_new;
08003DF0  2042      12823          move.l    D2,A0
08003DF2  CABC 0000 12824          and.l     #255,D5
08003DF6  00FF      
08003DF8  D1C5      12825          add.l     D5,A0
08003DFA  8F28 000A 12826          or.b      D7,10(A0)
                    12827   OSTaskChangePrio_14:
                    12828   ; }
                    12829   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12830   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
08003DFE  2043      12831          move.l    D3,A0
08003E00  2028 0020 12832          move.l    32(A0),D0
08003E04  6700 005C 12833          beq       OSTaskChangePrio_22
                    12834   ; pevents =  ptcb->OSTCBEventMultiPtr;
08003E08  2043      12835          move.l    D3,A0
08003E0A  2468 0020 12836          move.l    32(A0),A2
                    12837   ; pevent  = *pevents;
08003E0E  2412      12838          move.l    (A2),D2
                    12839   ; while (pevent != (OS_EVENT *)0) {
                    12840   OSTaskChangePrio_20:
08003E10  4A82      12841          tst.l     D2
08003E12  6700 004E 12842          beq       OSTaskChangePrio_22
                    12843   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
08003E16  2042      12844          move.l    D2,A0
08003E18  C8BC 0000 12845          and.l     #255,D4
08003E1C  00FF      
08003E1E  D1C4      12846          add.l     D4,A0
08003E20  1006      12847          move.b    D6,D0
08003E22  4600      12848          not.b     D0
08003E24  C128 000A 12849          and.b     D0,10(A0)
                    12850   ; if (pevent->OSEventTbl[y_old] == 0u) {
08003E28  2042      12851          move.l    D2,A0
08003E2A  C8BC 0000 12852          and.l     #255,D4
08003E2E  00FF      
08003E30  D1C4      12853          add.l     D4,A0
08003E32  1028 000A 12854          move.b    10(A0),D0
08003E36  660C      12855          bne.s     OSTaskChangePrio_23
                    12856   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
08003E38  2042      12857          move.l    D2,A0
08003E3A  102E FFFF 12858          move.b    -1(A6),D0
08003E3E  4600      12859          not.b     D0
08003E40  C128 0008 12860          and.b     D0,8(A0)
                    12861   OSTaskChangePrio_23:
                    12862   ; }
                    12863   ; pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
08003E44  2042      12864          move.l    D2,A0
08003E46  102E FFFE 12865          move.b    -2(A6),D0
08003E4A  8128 0008 12866          or.b      D0,8(A0)
                    12867   ; pevent->OSEventTbl[y_new] |= bitx_new;
08003E4E  2042      12868          move.l    D2,A0
08003E50  CABC 0000 12869          and.l     #255,D5
08003E54  00FF      
08003E56  D1C5      12870          add.l     D5,A0
08003E58  8F28 000A 12871          or.b      D7,10(A0)
                    12872   ; pevents++;
08003E5C  584A      12873          addq.w    #4,A2
                    12874   ; pevent                     = *pevents;
08003E5E  2412      12875          move.l    (A2),D2
08003E60  60AE      12876          bra       OSTaskChangePrio_20
                    12877   OSTaskChangePrio_22:
                    12878   ; }
                    12879   ; }
                    12880   ; #endif
                    12881   ; #endif
                    12882   ; ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
08003E62  2043      12883          move.l    D3,A0
08003E64  116E 000F 12884          move.b    15(A6),52(A0)
08003E68  0034      
                    12885   ; ptcb->OSTCBY    = y_new;
08003E6A  2043      12886          move.l    D3,A0
08003E6C  1145 0036 12887          move.b    D5,54(A0)
                    12888   ; ptcb->OSTCBX    = x_new;
08003E70  2043      12889          move.l    D3,A0
08003E72  116E FFFD 12890          move.b    -3(A6),53(A0)
08003E76  0035      
                    12891   ; ptcb->OSTCBBitY = bity_new;
08003E78  2043      12892          move.l    D3,A0
08003E7A  116E FFFE 12893          move.b    -2(A6),56(A0)
08003E7E  0038      
                    12894   ; ptcb->OSTCBBitX = bitx_new;
08003E80  2043      12895          move.l    D3,A0
08003E82  1147 0037 12896          move.b    D7,55(A0)
                    12897   ; OS_EXIT_CRITICAL();
08003E86  46DF      12898          dc.w      18143
                    12899   ; if (OSRunning == OS_TRUE) {
08003E88  1039 0800 12900          move.b    _OSRunning.L,D0
08003E8C  0324      
08003E8E  0C00 0001 12901          cmp.b     #1,D0
08003E92  6606      12902          bne.s     OSTaskChangePrio_25
                    12903   ; OS_Sched();                                         /* Find new highest priority task          */
08003E94  4EB9 0800 12904          jsr       _OS_Sched
08003E98  0F8A      
                    12905   OSTaskChangePrio_25:
                    12906   ; }
                    12907   ; return (OS_ERR_NONE);
08003E9A  4200      12908          clr.b     D0
                    12909   OSTaskChangePrio_3:
08003E9C  4CDF 1CFC 12910          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
08003EA0  4E5E      12911          unlk      A6
08003EA2  4E75      12912          rts
                    12913   ; }
                    12914   ; #endif
                    12915   ; /*$PAGE*/
                    12916   ; /*
                    12917   ; *********************************************************************************************************
                    12918   ; *                                            CREATE A TASK
                    12919   ; *
                    12920   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    12921   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    12922   ; *              created by an ISR.
                    12923   ; *
                    12924   ; * Arguments  : task     is a pointer to the task's code
                    12925   ; *
                    12926   ; *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
                    12927   ; *                       the task when the task first executes.  Where the task is concerned it thinks
                    12928   ; *                       it was invoked and passed the argument 'p_arg' as follows:
                    12929   ; *
                    12930   ; *                           void Task (void *p_arg)
                    12931   ; *                           {
                    12932   ; *                               for (;;) {
                    12933   ; *                                   Task code;
                    12934   ; *                               }
                    12935   ; *                           }
                    12936   ; *
                    12937   ; *              ptos     is a pointer to the task's top of stack.  If the configuration constant
                    12938   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    12939   ; *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
                    12940   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
                    12941   ; *                       lowest memory location of the stack and the stack will grow with increasing
                    12942   ; *                       memory locations.
                    12943   ; *
                    12944   ; *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
                    12945   ; *                       lower the number, the higher the priority.
                    12946   ; *
                    12947   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    12948   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    12949   ; *                                               (each task MUST have a unique priority).
                    12950   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    12951   ; *                                               allowed (i.e. >= OS_LOWEST_PRIO)
                    12952   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    12953   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    12954   ; *                                               operation started.
                    12955   ; *********************************************************************************************************
                    12956   ; */
                    12957   ; #if OS_TASK_CREATE_EN > 0u
                    12958   ; INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                    12959   ; void    *p_arg,
                    12960   ; OS_STK  *ptos,
                    12961   ; INT8U    prio)
                    12962   ; {
                    12963   _OSTaskCreate:
08003EA4  4E56 FFFC 12964          link      A6,#-4
08003EA8  48E7 3020 12965          movem.l   D2/D3/A2,-(A7)
08003EAC  142E 0017 12966          move.b    23(A6),D2
08003EB0  C4BC 0000 12967          and.l     #255,D2
08003EB4  00FF      
08003EB6  45F9 0800 12968          lea       _OSTCBPrioTbl.L,A2
08003EBA  043C      
                    12969   ; OS_STK     *psp;
                    12970   ; INT8U       err;
                    12971   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    12972   ; OS_CPU_SR   cpu_sr = 0u;
                    12973   ; #endif
                    12974   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    12975   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    12976   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12977   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    12978   ; }
                    12979   ; #endif
                    12980   ; #if OS_ARG_CHK_EN > 0u
                    12981   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    12982   ; return (OS_ERR_PRIO_INVALID);
                    12983   ; }
                    12984   ; #endif
                    12985   ; OS_ENTER_CRITICAL();
08003EBC  40E7      12986          dc.w      16615
08003EBE  007C      12987          dc.w      124
08003EC0  0700      12988          dc.w      1792
                    12989   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
08003EC2  1039 0800 12990          move.b    _OSIntNesting.L,D0
08003EC6  0312      
08003EC8  0C00 0000 12991          cmp.b     #0,D0
08003ECC  6308      12992          bls.s     OSTaskCreate_1
                    12993   ; OS_EXIT_CRITICAL();
08003ECE  46DF      12994          dc.w      18143
                    12995   ; return (OS_ERR_TASK_CREATE_ISR);
08003ED0  703C      12996          moveq     #60,D0
08003ED2  6000 009C 12997          bra       OSTaskCreate_3
                    12998   OSTaskCreate_1:
                    12999   ; }
                    13000   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
08003ED6  C4BC 0000 13001          and.l     #255,D2
08003EDA  00FF      
08003EDC  2002      13002          move.l    D2,D0
08003EDE  E588      13003          lsl.l     #2,D0
08003EE0  2032 0800 13004          move.l    0(A2,D0.L),D0
08003EE4  6600 0086 13005          bne       OSTaskCreate_4
                    13006   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
08003EE8  C4BC 0000 13007          and.l     #255,D2
08003EEC  00FF      
08003EEE  2002      13008          move.l    D2,D0
08003EF0  E588      13009          lsl.l     #2,D0
08003EF2  25BC 0000 13010          move.l    #1,0(A2,D0.L)
08003EF6  0001 0800 
                    13011   ; /* ... the same thing until task is created.              */
                    13012   ; OS_EXIT_CRITICAL();
08003EFA  46DF      13013          dc.w      18143
                    13014   ; psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
08003EFC  42A7      13015          clr.l     -(A7)
08003EFE  2F2E 0010 13016          move.l    16(A6),-(A7)
08003F02  2F2E 000C 13017          move.l    12(A6),-(A7)
08003F06  2F2E 0008 13018          move.l    8(A6),-(A7)
08003F0A  4EB9 0800 13019          jsr       _OSTaskStkInit
08003F0E  0182      
08003F10  DEFC 0010 13020          add.w     #16,A7
08003F14  2D40 FFFC 13021          move.l    D0,-4(A6)
                    13022   ; err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
08003F18  42A7      13023          clr.l     -(A7)
08003F1A  42A7      13024          clr.l     -(A7)
08003F1C  42A7      13025          clr.l     -(A7)
08003F1E  42A7      13026          clr.l     -(A7)
08003F20  42A7      13027          clr.l     -(A7)
08003F22  2F2E FFFC 13028          move.l    -4(A6),-(A7)
08003F26  C4BC 0000 13029          and.l     #255,D2
08003F2A  00FF      
08003F2C  2F02      13030          move.l    D2,-(A7)
08003F2E  4EB9 0800 13031          jsr       _OS_TCBInit
08003F32  11A8      
08003F34  DEFC 001C 13032          add.w     #28,A7
08003F38  1600      13033          move.b    D0,D3
                    13034   ; if (err == OS_ERR_NONE) {
08003F3A  4A03      13035          tst.b     D3
08003F3C  6614      13036          bne.s     OSTaskCreate_6
                    13037   ; if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
08003F3E  1039 0800 13038          move.b    _OSRunning.L,D0
08003F42  0324      
08003F44  0C00 0001 13039          cmp.b     #1,D0
08003F48  6606      13040          bne.s     OSTaskCreate_8
                    13041   ; OS_Sched();
08003F4A  4EB9 0800 13042          jsr       _OS_Sched
08003F4E  0F8A      
                    13043   OSTaskCreate_8:
08003F50  6016      13044          bra.s     OSTaskCreate_7
                    13045   OSTaskCreate_6:
                    13046   ; }
                    13047   ; } else {
                    13048   ; OS_ENTER_CRITICAL();
08003F52  40E7      13049          dc.w      16615
08003F54  007C      13050          dc.w      124
08003F56  0700      13051          dc.w      1792
                    13052   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
08003F58  C4BC 0000 13053          and.l     #255,D2
08003F5C  00FF      
08003F5E  2002      13054          move.l    D2,D0
08003F60  E588      13055          lsl.l     #2,D0
08003F62  42B2 0800 13056          clr.l     0(A2,D0.L)
                    13057   ; OS_EXIT_CRITICAL();
08003F66  46DF      13058          dc.w      18143
                    13059   OSTaskCreate_7:
                    13060   ; }
                    13061   ; return (err);
08003F68  1003      13062          move.b    D3,D0
08003F6A  6004      13063          bra.s     OSTaskCreate_3
                    13064   OSTaskCreate_4:
                    13065   ; }
                    13066   ; OS_EXIT_CRITICAL();
08003F6C  46DF      13067          dc.w      18143
                    13068   ; return (OS_ERR_PRIO_EXIST);
08003F6E  7028      13069          moveq     #40,D0
                    13070   OSTaskCreate_3:
08003F70  4CDF 040C 13071          movem.l   (A7)+,D2/D3/A2
08003F74  4E5E      13072          unlk      A6
08003F76  4E75      13073          rts
                    13074   ; }
                    13075   ; #endif
                    13076   ; /*$PAGE*/
                    13077   ; /*
                    13078   ; *********************************************************************************************************
                    13079   ; *                                  CREATE A TASK (Extended Version)
                    13080   ; *
                    13081   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13082   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13083   ; *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
                    13084   ; *              additional information about a task to be specified.
                    13085   ; *
                    13086   ; * Arguments  : task      is a pointer to the task's code
                    13087   ; *
                    13088   ; *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
                    13089   ; *                        the task when the task first executes.  Where the task is concerned it thinks
                    13090   ; *                        it was invoked and passed the argument 'p_arg' as follows:
                    13091   ; *
                    13092   ; *                            void Task (void *p_arg)
                    13093   ; *                            {
                    13094   ; *                                for (;;) {
                    13095   ; *                                    Task code;
                    13096   ; *                                }
                    13097   ; *                            }
                    13098   ; *
                    13099   ; *              ptos      is a pointer to the task's top of stack.  If the configuration constant
                    13100   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13101   ; *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
                    13102   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
                    13103   ; *                        lowest memory location of the stack and the stack will grow with increasing
                    13104   ; *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
                    13105   ; *
                    13106   ; *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
                    13107   ; *                        lower the number, the higher the priority.
                    13108   ; *
                    13109   ; *              id        is the task's ID (0..65535)
                    13110   ; *
                    13111   ; *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
                    13112   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13113   ; *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
                    13114   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    13115   ; *                        HIGHEST memory location of the stack and the stack will grow with increasing
                    13116   ; *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
                    13117   ; *
                    13118   ; *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
                    13119   ; *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
                    13120   ; *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
                    13121   ; *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
                    13122   ; *                        available on the stack.
                    13123   ; *
                    13124   ; *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
                    13125   ; *                        For example, this user memory can hold the contents of floating-point registers
                    13126   ; *                        during a context switch, the time each task takes to execute, the number of times
                    13127   ; *                        the task has been switched-in, etc.
                    13128   ; *
                    13129   ; *              opt       contains additional information (or options) about the behavior of the task.  The
                    13130   ; *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    13131   ; *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
                    13132   ; *
                    13133   ; *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
                    13134   ; *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
                    13135   ; *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
                    13136   ; *                                                 during a context switch.
                    13137   ; *
                    13138   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13139   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13140   ; *                                               (each task MUST have a unique priority).
                    13141   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13142   ; *                                               allowed (i.e. > OS_LOWEST_PRIO)
                    13143   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13144   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13145   ; *                                               operation started.
                    13146   ; *********************************************************************************************************
                    13147   ; */
                    13148   ; /*$PAGE*/
                    13149   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    13150   ; INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
                    13151   ; void    *p_arg,
                    13152   ; OS_STK  *ptos,
                    13153   ; INT8U    prio,
                    13154   ; INT16U   id,
                    13155   ; OS_STK  *pbos,
                    13156   ; INT32U   stk_size,
                    13157   ; void    *pext,
                    13158   ; INT16U   opt)
                    13159   ; {
                    13160   _OSTaskCreateExt:
08003F78  4E56 FFFC 13161          link      A6,#-4
08003F7C  48E7 3820 13162          movem.l   D2/D3/D4/A2,-(A7)
08003F80  142E 0017 13163          move.b    23(A6),D2
08003F84  C4BC 0000 13164          and.l     #255,D2
08003F88  00FF      
08003F8A  382E 002A 13165          move.w    42(A6),D4
08003F8E  C8BC 0000 13166          and.l     #65535,D4
08003F92  FFFF      
08003F94  45F9 0800 13167          lea       _OSTCBPrioTbl.L,A2
08003F98  043C      
                    13168   ; OS_STK     *psp;
                    13169   ; INT8U       err;
                    13170   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13171   ; OS_CPU_SR   cpu_sr = 0u;
                    13172   ; #endif
                    13173   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13174   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13175   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13176   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13177   ; }
                    13178   ; #endif
                    13179   ; #if OS_ARG_CHK_EN > 0u
                    13180   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13181   ; return (OS_ERR_PRIO_INVALID);
                    13182   ; }
                    13183   ; #endif
                    13184   ; OS_ENTER_CRITICAL();
08003F9A  40E7      13185          dc.w      16615
08003F9C  007C      13186          dc.w      124
08003F9E  0700      13187          dc.w      1792
                    13188   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
08003FA0  1039 0800 13189          move.b    _OSIntNesting.L,D0
08003FA4  0312      
08003FA6  0C00 0000 13190          cmp.b     #0,D0
08003FAA  6308      13191          bls.s     OSTaskCreateExt_1
                    13192   ; OS_EXIT_CRITICAL();
08003FAC  46DF      13193          dc.w      18143
                    13194   ; return (OS_ERR_TASK_CREATE_ISR);
08003FAE  703C      13195          moveq     #60,D0
08003FB0  6000 00D2 13196          bra       OSTaskCreateExt_3
                    13197   OSTaskCreateExt_1:
                    13198   ; }
                    13199   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
08003FB4  C4BC 0000 13200          and.l     #255,D2
08003FB8  00FF      
08003FBA  2002      13201          move.l    D2,D0
08003FBC  E588      13202          lsl.l     #2,D0
08003FBE  2032 0800 13203          move.l    0(A2,D0.L),D0
08003FC2  6600 00BC 13204          bne       OSTaskCreateExt_4
                    13205   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
08003FC6  C4BC 0000 13206          and.l     #255,D2
08003FCA  00FF      
08003FCC  2002      13207          move.l    D2,D0
08003FCE  E588      13208          lsl.l     #2,D0
08003FD0  25BC 0000 13209          move.l    #1,0(A2,D0.L)
08003FD4  0001 0800 
                    13210   ; /* ... the same thing until task is created.              */
                    13211   ; OS_EXIT_CRITICAL();
08003FD8  46DF      13212          dc.w      18143
                    13213   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u)
                    13214   ; OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
08003FDA  C8BC 0000 13215          and.l     #65535,D4
08003FDE  FFFF      
08003FE0  2F04      13216          move.l    D4,-(A7)
08003FE2  2F2E 0020 13217          move.l    32(A6),-(A7)
08003FE6  2F2E 001C 13218          move.l    28(A6),-(A7)
08003FEA  4EB9 0800 13219          jsr       _OS_TaskStkClr
08003FEE  47F0      
08003FF0  DEFC 000C 13220          add.w     #12,A7
                    13221   ; #endif
                    13222   ; psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
08003FF4  C8BC 0000 13223          and.l     #65535,D4
08003FF8  FFFF      
08003FFA  2F04      13224          move.l    D4,-(A7)
08003FFC  2F2E 0010 13225          move.l    16(A6),-(A7)
08004000  2F2E 000C 13226          move.l    12(A6),-(A7)
08004004  2F2E 0008 13227          move.l    8(A6),-(A7)
08004008  4EB9 0800 13228          jsr       _OSTaskStkInit
0800400C  0182      
0800400E  DEFC 0010 13229          add.w     #16,A7
08004012  2D40 FFFC 13230          move.l    D0,-4(A6)
                    13231   ; err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
08004016  C8BC 0000 13232          and.l     #65535,D4
0800401A  FFFF      
0800401C  2F04      13233          move.l    D4,-(A7)
0800401E  2F2E 0024 13234          move.l    36(A6),-(A7)
08004022  2F2E 0020 13235          move.l    32(A6),-(A7)
08004026  322E 001A 13236          move.w    26(A6),D1
0800402A  C2BC 0000 13237          and.l     #65535,D1
0800402E  FFFF      
08004030  2F01      13238          move.l    D1,-(A7)
08004032  2F2E 001C 13239          move.l    28(A6),-(A7)
08004036  2F2E FFFC 13240          move.l    -4(A6),-(A7)
0800403A  C4BC 0000 13241          and.l     #255,D2
0800403E  00FF      
08004040  2F02      13242          move.l    D2,-(A7)
08004042  4EB9 0800 13243          jsr       _OS_TCBInit
08004046  11A8      
08004048  DEFC 001C 13244          add.w     #28,A7
0800404C  1600      13245          move.b    D0,D3
                    13246   ; if (err == OS_ERR_NONE) {
0800404E  4A03      13247          tst.b     D3
08004050  6614      13248          bne.s     OSTaskCreateExt_6
                    13249   ; if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
08004052  1039 0800 13250          move.b    _OSRunning.L,D0
08004056  0324      
08004058  0C00 0001 13251          cmp.b     #1,D0
0800405C  6606      13252          bne.s     OSTaskCreateExt_8
                    13253   ; OS_Sched();
0800405E  4EB9 0800 13254          jsr       _OS_Sched
08004062  0F8A      
                    13255   OSTaskCreateExt_8:
08004064  6016      13256          bra.s     OSTaskCreateExt_7
                    13257   OSTaskCreateExt_6:
                    13258   ; }
                    13259   ; } else {
                    13260   ; OS_ENTER_CRITICAL();
08004066  40E7      13261          dc.w      16615
08004068  007C      13262          dc.w      124
0800406A  0700      13263          dc.w      1792
                    13264   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
0800406C  C4BC 0000 13265          and.l     #255,D2
08004070  00FF      
08004072  2002      13266          move.l    D2,D0
08004074  E588      13267          lsl.l     #2,D0
08004076  42B2 0800 13268          clr.l     0(A2,D0.L)
                    13269   ; OS_EXIT_CRITICAL();
0800407A  46DF      13270          dc.w      18143
                    13271   OSTaskCreateExt_7:
                    13272   ; }
                    13273   ; return (err);
0800407C  1003      13274          move.b    D3,D0
0800407E  6004      13275          bra.s     OSTaskCreateExt_3
                    13276   OSTaskCreateExt_4:
                    13277   ; }
                    13278   ; OS_EXIT_CRITICAL();
08004080  46DF      13279          dc.w      18143
                    13280   ; return (OS_ERR_PRIO_EXIST);
08004082  7028      13281          moveq     #40,D0
                    13282   OSTaskCreateExt_3:
08004084  4CDF 041C 13283          movem.l   (A7)+,D2/D3/D4/A2
08004088  4E5E      13284          unlk      A6
0800408A  4E75      13285          rts
                    13286   ; }
                    13287   ; #endif
                    13288   ; /*$PAGE*/
                    13289   ; /*
                    13290   ; *********************************************************************************************************
                    13291   ; *                                            DELETE A TASK
                    13292   ; *
                    13293   ; * Description: This function allows you to delete a task.  The calling task can delete itself by
                    13294   ; *              its own priority number.  The deleted task is returned to the dormant state and can be
                    13295   ; *              re-activated by creating the deleted task again.
                    13296   ; *
                    13297   ; * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
                    13298   ; *                      the current task without knowing its priority level by setting 'prio' to
                    13299   ; *                      OS_PRIO_SELF.
                    13300   ; *
                    13301   ; * Returns    : OS_ERR_NONE             if the call is successful
                    13302   ; *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
                    13303   ; *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
                    13304   ; *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13305   ; *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
                    13306   ; *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
                    13307   ; *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
                    13308   ; *
                    13309   ; * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
                    13310   ; *                    a) by making it not ready
                    13311   ; *                    b) by removing it from any wait lists
                    13312   ; *                    c) by preventing OSTimeTick() from making the task ready to run.
                    13313   ; *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
                    13314   ; *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
                    13315   ; *                 the next instruction following the enable interrupt instruction is ignored.
                    13316   ; *              3) An ISR cannot delete a task.
                    13317   ; *              4) The lock nesting counter is incremented because, for a brief instant, if the current
                    13318   ; *                 task is being deleted, the current task would not be able to be rescheduled because it
                    13319   ; *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
                    13320   ; *                 from being schedule.  This means that an ISR would return to the current task which is
                    13321   ; *                 being deleted.  The rest of the deletion would thus be able to be completed.
                    13322   ; *********************************************************************************************************
                    13323   ; */
                    13324   ; #if OS_TASK_DEL_EN > 0u
                    13325   ; INT8U  OSTaskDel (INT8U prio)
                    13326   ; {
                    13327   _OSTaskDel:
0800408C  4E56 0000 13328          link      A6,#0
08004090  48E7 3800 13329          movem.l   D2/D3/D4,-(A7)
08004094  162E 000B 13330          move.b    11(A6),D3
08004098  C6BC 0000 13331          and.l     #255,D3
0800409C  00FF      
                    13332   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13333   ; OS_FLAG_NODE *pnode;
                    13334   ; #endif
                    13335   ; OS_TCB       *ptcb;
                    13336   ; #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
                    13337   ; OS_CPU_SR     cpu_sr = 0u;
                    13338   ; #endif
                    13339   ; if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
0800409E  1039 0800 13340          move.b    _OSIntNesting.L,D0
080040A2  0312      
080040A4  0C00 0000 13341          cmp.b     #0,D0
080040A8  6306      13342          bls.s     OSTaskDel_1
                    13343   ; return (OS_ERR_TASK_DEL_ISR);
080040AA  7040      13344          moveq     #64,D0
080040AC  6000 01B0 13345          bra       OSTaskDel_3
                    13346   OSTaskDel_1:
                    13347   ; }
                    13348   ; if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
080040B0  0C03 003F 13349          cmp.b     #63,D3
080040B4  6606      13350          bne.s     OSTaskDel_4
                    13351   ; return (OS_ERR_TASK_DEL_IDLE);
080040B6  703E      13352          moveq     #62,D0
080040B8  6000 01A4 13353          bra       OSTaskDel_3
                    13354   OSTaskDel_4:
                    13355   ; }
                    13356   ; #if OS_ARG_CHK_EN > 0u
                    13357   ; if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
                    13358   ; if (prio != OS_PRIO_SELF) {
                    13359   ; return (OS_ERR_PRIO_INVALID);
                    13360   ; }
                    13361   ; }
                    13362   ; #endif
                    13363   ; /*$PAGE*/
                    13364   ; OS_ENTER_CRITICAL();
080040BC  40E7      13365          dc.w      16615
080040BE  007C      13366          dc.w      124
080040C0  0700      13367          dc.w      1792
                    13368   ; if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
080040C2  0C03 00FF 13369          cmp.b     #255,D3
080040C6  660A      13370          bne.s     OSTaskDel_6
                    13371   ; prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
080040C8  2079 0800 13372          move.l    _OSTCBCur.L,A0
080040CC  042C      
080040CE  1628 0034 13373          move.b    52(A0),D3
                    13374   OSTaskDel_6:
                    13375   ; }
                    13376   ; ptcb = OSTCBPrioTbl[prio];
080040D2  C6BC 0000 13377          and.l     #255,D3
080040D6  00FF      
080040D8  2003      13378          move.l    D3,D0
080040DA  E588      13379          lsl.l     #2,D0
080040DC  41F9 0800 13380          lea       _OSTCBPrioTbl.L,A0
080040E0  043C      
080040E2  2430 0800 13381          move.l    0(A0,D0.L),D2
                    13382   ; if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
080040E6  4A82      13383          tst.l     D2
080040E8  6608      13384          bne.s     OSTaskDel_8
                    13385   ; OS_EXIT_CRITICAL();
080040EA  46DF      13386          dc.w      18143
                    13387   ; return (OS_ERR_TASK_NOT_EXIST);
080040EC  7043      13388          moveq     #67,D0
080040EE  6000 016E 13389          bra       OSTaskDel_3
                    13390   OSTaskDel_8:
                    13391   ; }
                    13392   ; if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
080040F2  0C82 0000 13393          cmp.l     #1,D2
080040F6  0001      
080040F8  6608      13394          bne.s     OSTaskDel_10
                    13395   ; OS_EXIT_CRITICAL();
080040FA  46DF      13396          dc.w      18143
                    13397   ; return (OS_ERR_TASK_DEL);
080040FC  703D      13398          moveq     #61,D0
080040FE  6000 015E 13399          bra       OSTaskDel_3
                    13400   OSTaskDel_10:
                    13401   ; }
                    13402   ; OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
08004102  2042      13403          move.l    D2,A0
08004104  1028 0036 13404          move.b    54(A0),D0
08004108  C0BC 0000 13405          and.l     #255,D0
0800410C  00FF      
0800410E  41F9 0800 13406          lea       _OSRdyTbl.L,A0
08004112  031C      
08004114  2242      13407          move.l    D2,A1
08004116  1229 0037 13408          move.b    55(A1),D1
0800411A  4601      13409          not.b     D1
0800411C  C330 0800 13410          and.b     D1,0(A0,D0.L)
                    13411   ; if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
08004120  2042      13412          move.l    D2,A0
08004122  1028 0036 13413          move.b    54(A0),D0
08004126  C0BC 0000 13414          and.l     #255,D0
0800412A  00FF      
0800412C  41F9 0800 13415          lea       _OSRdyTbl.L,A0
08004130  031C      
08004132  1030 0800 13416          move.b    0(A0,D0.L),D0
08004136  660E      13417          bne.s     OSTaskDel_12
                    13418   ; OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
08004138  2042      13419          move.l    D2,A0
0800413A  1028 0038 13420          move.b    56(A0),D0
0800413E  4600      13421          not.b     D0
08004140  C139 0800 13422          and.b     D0,_OSRdyGrp.L
08004144  031A      
                    13423   OSTaskDel_12:
                    13424   ; }
                    13425   ; #if (OS_EVENT_EN)
                    13426   ; if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
08004146  2042      13427          move.l    D2,A0
08004148  2028 001C 13428          move.l    28(A0),D0
0800414C  6710      13429          beq.s     OSTaskDel_14
                    13430   ; OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
0800414E  2042      13431          move.l    D2,A0
08004150  2F28 001C 13432          move.l    28(A0),-(A7)
08004154  2F02      13433          move.l    D2,-(A7)
08004156  4EB9 0800 13434          jsr       _OS_EventTaskRemove
0800415A  0BB0      
0800415C  504F      13435          addq.w    #8,A7
                    13436   OSTaskDel_14:
                    13437   ; }
                    13438   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13439   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
0800415E  2042      13440          move.l    D2,A0
08004160  2028 0020 13441          move.l    32(A0),D0
08004164  6710      13442          beq.s     OSTaskDel_16
                    13443   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
08004166  2042      13444          move.l    D2,A0
08004168  2F28 0020 13445          move.l    32(A0),-(A7)
0800416C  2F02      13446          move.l    D2,-(A7)
0800416E  4EB9 0800 13447          jsr       _OS_EventTaskRemoveMulti
08004172  0C02      
08004174  504F      13448          addq.w    #8,A7
                    13449   OSTaskDel_16:
                    13450   ; }
                    13451   ; #endif
                    13452   ; #endif
                    13453   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13454   ; pnode = ptcb->OSTCBFlagNode;
08004176  2042      13455          move.l    D2,A0
08004178  2828 0028 13456          move.l    40(A0),D4
                    13457   ; if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
0800417C  4A84      13458          tst.l     D4
0800417E  670A      13459          beq.s     OSTaskDel_18
                    13460   ; OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
08004180  2F04      13461          move.l    D4,-(A7)
08004182  4EB9 0800 13462          jsr       _OS_FlagUnlink
08004186  1DCC      
08004188  584F      13463          addq.w    #4,A7
                    13464   OSTaskDel_18:
                    13465   ; }
                    13466   ; #endif
                    13467   ; ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
0800418A  2042      13468          move.l    D2,A0
0800418C  42A8 002E 13469          clr.l     46(A0)
                    13470   ; ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
08004190  2042      13471          move.l    D2,A0
08004192  4228 0032 13472          clr.b     50(A0)
                    13473   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
08004196  2042      13474          move.l    D2,A0
08004198  4228 0033 13475          clr.b     51(A0)
                    13476   ; if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
0800419C  1039 0800 13477          move.b    _OSLockNesting.L,D0
080041A0  0314      
080041A2  0C00 00FF 13478          cmp.b     #255,D0
080041A6  6406      13479          bhs.s     OSTaskDel_20
                    13480   ; OSLockNesting++;
080041A8  5239 0800 13481          addq.b    #1,_OSLockNesting.L
080041AC  0314      
                    13482   OSTaskDel_20:
                    13483   ; }
                    13484   ; OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
080041AE  46DF      13485          dc.w      18143
                    13486   ; OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
080041B0  4EB9 0800 13487          jsr       _OS_Dummy
080041B4  09A8      
                    13488   ; OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
080041B6  40E7      13489          dc.w      16615
080041B8  007C      13490          dc.w      124
080041BA  0700      13491          dc.w      1792
                    13492   ; if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
080041BC  1039 0800 13493          move.b    _OSLockNesting.L,D0
080041C0  0314      
080041C2  0C00 0000 13494          cmp.b     #0,D0
080041C6  6306      13495          bls.s     OSTaskDel_22
                    13496   ; OSLockNesting--;
080041C8  5339 0800 13497          subq.b    #1,_OSLockNesting.L
080041CC  0314      
                    13498   OSTaskDel_22:
                    13499   ; }
                    13500   ; OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
080041CE  2F02      13501          move.l    D2,-(A7)
080041D0  4EB9 0800 13502          jsr       _OSTaskDelHook
080041D4  026C      
080041D6  584F      13503          addq.w    #4,A7
                    13504   ; OSTaskCtr--;                                        /* One less task being managed                 */
080041D8  5339 0800 13505          subq.b    #1,_OSTaskCtr.L
080041DC  0326      
                    13506   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
080041DE  C6BC 0000 13507          and.l     #255,D3
080041E2  00FF      
080041E4  2003      13508          move.l    D3,D0
080041E6  E588      13509          lsl.l     #2,D0
080041E8  41F9 0800 13510          lea       _OSTCBPrioTbl.L,A0
080041EC  043C      
080041EE  42B0 0800 13511          clr.l     0(A0,D0.L)
                    13512   ; if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
080041F2  2042      13513          move.l    D2,A0
080041F4  2028 0018 13514          move.l    24(A0),D0
080041F8  6616      13515          bne.s     OSTaskDel_24
                    13516   ; ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
080041FA  2042      13517          move.l    D2,A0
080041FC  2068 0014 13518          move.l    20(A0),A0
08004200  42A8 0018 13519          clr.l     24(A0)
                    13520   ; OSTCBList                  = ptcb->OSTCBNext;
08004204  2042      13521          move.l    D2,A0
08004206  23E8 0014 13522          move.l    20(A0),_OSTCBList.L
0800420A  0800 0438 
0800420E  601C      13523          bra.s     OSTaskDel_25
                    13524   OSTaskDel_24:
                    13525   ; } else {
                    13526   ; ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
08004210  2042      13527          move.l    D2,A0
08004212  2242      13528          move.l    D2,A1
08004214  2269 0018 13529          move.l    24(A1),A1
08004218  2368 0014 13530          move.l    20(A0),20(A1)
0800421C  0014      
                    13531   ; ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
0800421E  2042      13532          move.l    D2,A0
08004220  2242      13533          move.l    D2,A1
08004222  2269 0014 13534          move.l    20(A1),A1
08004226  2368 0018 13535          move.l    24(A0),24(A1)
0800422A  0018      
                    13536   OSTaskDel_25:
                    13537   ; }
                    13538   ; ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
0800422C  2042      13539          move.l    D2,A0
0800422E  2179 0800 13540          move.l    _OSTCBFreeList.L,20(A0)
08004232  0430 0014 
                    13541   ; OSTCBFreeList       = ptcb;
08004236  23C2 0800 13542          move.l    D2,_OSTCBFreeList.L
0800423A  0430      
                    13543   ; #if OS_TASK_NAME_EN > 0u
                    13544   ; ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
0800423C  41F9 0800 13545          lea       @ucos_ii_1.L,A0
08004240  57FE      
08004242  2242      13546          move.l    D2,A1
08004244  2348 004E 13547          move.l    A0,78(A1)
                    13548   ; #endif
                    13549   ; OS_EXIT_CRITICAL();
08004248  46DF      13550          dc.w      18143
                    13551   ; if (OSRunning == OS_TRUE) {
0800424A  1039 0800 13552          move.b    _OSRunning.L,D0
0800424E  0324      
08004250  0C00 0001 13553          cmp.b     #1,D0
08004254  6606      13554          bne.s     OSTaskDel_26
                    13555   ; OS_Sched();                                     /* Find new highest priority task              */
08004256  4EB9 0800 13556          jsr       _OS_Sched
0800425A  0F8A      
                    13557   OSTaskDel_26:
                    13558   ; }
                    13559   ; return (OS_ERR_NONE);
0800425C  4200      13560          clr.b     D0
                    13561   OSTaskDel_3:
0800425E  4CDF 001C 13562          movem.l   (A7)+,D2/D3/D4
08004262  4E5E      13563          unlk      A6
08004264  4E75      13564          rts
                    13565   ; }
                    13566   ; #endif
                    13567   ; /*$PAGE*/
                    13568   ; /*
                    13569   ; *********************************************************************************************************
                    13570   ; *                                  REQUEST THAT A TASK DELETE ITSELF
                    13571   ; *
                    13572   ; * Description: This function is used to:
                    13573   ; *                   a) notify a task to delete itself.
                    13574   ; *                   b) to see if a task requested that the current task delete itself.
                    13575   ; *              This function is a little tricky to understand.  Basically, you have a task that needs
                    13576   ; *              to be deleted however, this task has resources that it has allocated (memory buffers,
                    13577   ; *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
                    13578   ; *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
                    13579   ; *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
                    13580   ; *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
                    13581   ; *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
                    13582   ; *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
                    13583   ; *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
                    13584   ; *              this:
                    13585   ; *
                    13586   ; *                   void Task(void *p_arg)
                    13587   ; *                   {
                    13588   ; *                       .
                    13589   ; *                       .
                    13590   ; *                       while (1) {
                    13591   ; *                           OSTimeDly(1);
                    13592   ; *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
                    13593   ; *                               Release any owned resources;
                    13594   ; *                               De-allocate any dynamic memory;
                    13595   ; *                               OSTaskDel(OS_PRIO_SELF);
                    13596   ; *                           }
                    13597   ; *                       }
                    13598   ; *                   }
                    13599   ; *
                    13600   ; * Arguments  : prio    is the priority of the task to request the delete from
                    13601   ; *
                    13602   ; * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
                    13603   ; *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
                    13604   ; *                                     the request has been executed.
                    13605   ; *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
                    13606   ; *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
                    13607   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    13608   ; *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13609   ; *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
                    13610   ; *                                     deleted.
                    13611   ; *********************************************************************************************************
                    13612   ; */
                    13613   ; /*$PAGE*/
                    13614   ; #if OS_TASK_DEL_EN > 0u
                    13615   ; INT8U  OSTaskDelReq (INT8U prio)
                    13616   ; {
                    13617   _OSTaskDelReq:
08004266  4E56 FFFC 13618          link      A6,#-4
0800426A  48E7 3000 13619          movem.l   D2/D3,-(A7)
0800426E  162E 000B 13620          move.b    11(A6),D3
08004272  C6BC 0000 13621          and.l     #255,D3
08004276  00FF      
                    13622   ; INT8U      stat;
                    13623   ; OS_TCB    *ptcb;
                    13624   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    13625   ; OS_CPU_SR  cpu_sr = 0u;
                    13626   ; #endif
                    13627   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
08004278  0C03 003F 13628          cmp.b     #63,D3
0800427C  6606      13629          bne.s     OSTaskDelReq_1
                    13630   ; return (OS_ERR_TASK_DEL_IDLE);
0800427E  703E      13631          moveq     #62,D0
08004280  6000 0062 13632          bra       OSTaskDelReq_3
                    13633   OSTaskDelReq_1:
                    13634   ; }
                    13635   ; #if OS_ARG_CHK_EN > 0u
                    13636   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    13637   ; if (prio != OS_PRIO_SELF) {
                    13638   ; return (OS_ERR_PRIO_INVALID);
                    13639   ; }
                    13640   ; }
                    13641   ; #endif
                    13642   ; if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
08004284  0C03 00FF 13643          cmp.b     #255,D3
08004288  661C      13644          bne.s     OSTaskDelReq_4
                    13645   ; OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
0800428A  40E7      13646          dc.w      16615
0800428C  007C      13647          dc.w      124
0800428E  0700      13648          dc.w      1792
                    13649   ; stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
08004290  2079 0800 13650          move.l    _OSTCBCur.L,A0
08004294  042C      
08004296  1D68 0039 13651          move.b    57(A0),-1(A6)
0800429A  FFFF      
                    13652   ; OS_EXIT_CRITICAL();
0800429C  46DF      13653          dc.w      18143
                    13654   ; return (stat);
0800429E  102E FFFF 13655          move.b    -1(A6),D0
080042A2  6000 0040 13656          bra       OSTaskDelReq_3
                    13657   OSTaskDelReq_4:
                    13658   ; }
                    13659   ; OS_ENTER_CRITICAL();
080042A6  40E7      13660          dc.w      16615
080042A8  007C      13661          dc.w      124
080042AA  0700      13662          dc.w      1792
                    13663   ; ptcb = OSTCBPrioTbl[prio];
080042AC  C6BC 0000 13664          and.l     #255,D3
080042B0  00FF      
080042B2  2003      13665          move.l    D3,D0
080042B4  E588      13666          lsl.l     #2,D0
080042B6  41F9 0800 13667          lea       _OSTCBPrioTbl.L,A0
080042BA  043C      
080042BC  2430 0800 13668          move.l    0(A0,D0.L),D2
                    13669   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
080042C0  4A82      13670          tst.l     D2
080042C2  6606      13671          bne.s     OSTaskDelReq_6
                    13672   ; OS_EXIT_CRITICAL();
080042C4  46DF      13673          dc.w      18143
                    13674   ; return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
080042C6  7043      13675          moveq     #67,D0
080042C8  601A      13676          bra.s     OSTaskDelReq_3
                    13677   OSTaskDelReq_6:
                    13678   ; }
                    13679   ; if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
080042CA  0C82 0000 13680          cmp.l     #1,D2
080042CE  0001      
080042D0  6606      13681          bne.s     OSTaskDelReq_8
                    13682   ; OS_EXIT_CRITICAL();
080042D2  46DF      13683          dc.w      18143
                    13684   ; return (OS_ERR_TASK_DEL);
080042D4  703D      13685          moveq     #61,D0
080042D6  600C      13686          bra.s     OSTaskDelReq_3
                    13687   OSTaskDelReq_8:
                    13688   ; }
                    13689   ; ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
080042D8  2042      13690          move.l    D2,A0
080042DA  117C 003F 13691          move.b    #63,57(A0)
080042DE  0039      
                    13692   ; OS_EXIT_CRITICAL();
080042E0  46DF      13693          dc.w      18143
                    13694   ; return (OS_ERR_NONE);
080042E2  4200      13695          clr.b     D0
                    13696   OSTaskDelReq_3:
080042E4  4CDF 000C 13697          movem.l   (A7)+,D2/D3
080042E8  4E5E      13698          unlk      A6
080042EA  4E75      13699          rts
                    13700   ; }
                    13701   ; #endif
                    13702   ; /*$PAGE*/
                    13703   ; /*
                    13704   ; *********************************************************************************************************
                    13705   ; *                                       GET THE NAME OF A TASK
                    13706   ; *
                    13707   ; * Description: This function is called to obtain the name of a task.
                    13708   ; *
                    13709   ; * Arguments  : prio      is the priority of the task that you want to obtain the name from.
                    13710   ; *
                    13711   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
                    13712   ; *
                    13713   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    13714   ; *
                    13715   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13716   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13717   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13718   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13719   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13720   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    13721   ; *
                    13722   ; *
                    13723   ; * Returns    : The length of the string or 0 if the task does not exist.
                    13724   ; *********************************************************************************************************
                    13725   ; */
                    13726   ; #if OS_TASK_NAME_EN > 0u
                    13727   ; INT8U  OSTaskNameGet (INT8U    prio,
                    13728   ; INT8U  **pname,
                    13729   ; INT8U   *perr)
                    13730   ; {
                    13731   _OSTaskNameGet:
080042EC  4E56 FFFC 13732          link      A6,#-4
080042F0  48E7 3800 13733          movem.l   D2/D3/D4,-(A7)
080042F4  262E 0010 13734          move.l    16(A6),D3
080042F8  182E 000B 13735          move.b    11(A6),D4
080042FC  C8BC 0000 13736          and.l     #255,D4
08004300  00FF      
                    13737   ; OS_TCB    *ptcb;
                    13738   ; INT8U      len;
                    13739   ; #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
                    13740   ; OS_CPU_SR  cpu_sr = 0u;
                    13741   ; #endif
                    13742   ; #ifdef OS_SAFETY_CRITICAL
                    13743   ; if (perr == (INT8U *)0) {
                    13744   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13745   ; return (0u);
                    13746   ; }
                    13747   ; #endif
                    13748   ; #if OS_ARG_CHK_EN > 0u
                    13749   ; if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
                    13750   ; if (prio != OS_PRIO_SELF) {
                    13751   ; *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
                    13752   ; return (0u);
                    13753   ; }
                    13754   ; }
                    13755   ; if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
                    13756   ; *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
                    13757   ; return (0u);
                    13758   ; }
                    13759   ; #endif
                    13760   ; if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
08004302  1039 0800 13761          move.b    _OSIntNesting.L,D0
08004306  0312      
08004308  0C00 0000 13762          cmp.b     #0,D0
0800430C  630C      13763          bls.s     OSTaskNameGet_1
                    13764   ; *perr = OS_ERR_NAME_GET_ISR;
0800430E  2043      13765          move.l    D3,A0
08004310  10BC 0011 13766          move.b    #17,(A0)
                    13767   ; return (0u);
08004314  4200      13768          clr.b     D0
08004316  6000 0078 13769          bra       OSTaskNameGet_3
                    13770   OSTaskNameGet_1:
                    13771   ; }
                    13772   ; OS_ENTER_CRITICAL();
0800431A  40E7      13773          dc.w      16615
0800431C  007C      13774          dc.w      124
0800431E  0700      13775          dc.w      1792
                    13776   ; if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
08004320  0C04 00FF 13777          cmp.b     #255,D4
08004324  660A      13778          bne.s     OSTaskNameGet_4
                    13779   ; prio = OSTCBCur->OSTCBPrio;
08004326  2079 0800 13780          move.l    _OSTCBCur.L,A0
0800432A  042C      
0800432C  1828 0034 13781          move.b    52(A0),D4
                    13782   OSTaskNameGet_4:
                    13783   ; }
                    13784   ; ptcb = OSTCBPrioTbl[prio];
08004330  C8BC 0000 13785          and.l     #255,D4
08004334  00FF      
08004336  2004      13786          move.l    D4,D0
08004338  E588      13787          lsl.l     #2,D0
0800433A  41F9 0800 13788          lea       _OSTCBPrioTbl.L,A0
0800433E  043C      
08004340  2430 0800 13789          move.l    0(A0,D0.L),D2
                    13790   ; if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
08004344  4A82      13791          tst.l     D2
08004346  660E      13792          bne.s     OSTaskNameGet_6
                    13793   ; OS_EXIT_CRITICAL();                              /* No                                         */
08004348  46DF      13794          dc.w      18143
                    13795   ; *perr = OS_ERR_TASK_NOT_EXIST;
0800434A  2043      13796          move.l    D3,A0
0800434C  10BC 0043 13797          move.b    #67,(A0)
                    13798   ; return (0u);
08004350  4200      13799          clr.b     D0
08004352  6000 003C 13800          bra       OSTaskNameGet_3
                    13801   OSTaskNameGet_6:
                    13802   ; }
                    13803   ; if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
08004356  0C82 0000 13804          cmp.l     #1,D2
0800435A  0001      
0800435C  660C      13805          bne.s     OSTaskNameGet_8
                    13806   ; OS_EXIT_CRITICAL();                              /* Yes                                        */
0800435E  46DF      13807          dc.w      18143
                    13808   ; *perr = OS_ERR_TASK_NOT_EXIST;
08004360  2043      13809          move.l    D3,A0
08004362  10BC 0043 13810          move.b    #67,(A0)
                    13811   ; return (0u);
08004366  4200      13812          clr.b     D0
08004368  6026      13813          bra.s     OSTaskNameGet_3
                    13814   OSTaskNameGet_8:
                    13815   ; }
                    13816   ; *pname = ptcb->OSTCBTaskName;
0800436A  2042      13817          move.l    D2,A0
0800436C  226E 000C 13818          move.l    12(A6),A1
08004370  22A8 004E 13819          move.l    78(A0),(A1)
                    13820   ; len    = OS_StrLen(*pname);
08004374  206E 000C 13821          move.l    12(A6),A0
08004378  2F10      13822          move.l    (A0),-(A7)
0800437A  4EB9 0800 13823          jsr       _OS_StrLen
0800437E  1034      
08004380  584F      13824          addq.w    #4,A7
08004382  1D40 FFFF 13825          move.b    D0,-1(A6)
                    13826   ; OS_EXIT_CRITICAL();
08004386  46DF      13827          dc.w      18143
                    13828   ; *perr  = OS_ERR_NONE;
08004388  2043      13829          move.l    D3,A0
0800438A  4210      13830          clr.b     (A0)
                    13831   ; return (len);
0800438C  102E FFFF 13832          move.b    -1(A6),D0
                    13833   OSTaskNameGet_3:
08004390  4CDF 001C 13834          movem.l   (A7)+,D2/D3/D4
08004394  4E5E      13835          unlk      A6
08004396  4E75      13836          rts
                    13837   ; }
                    13838   ; #endif
                    13839   ; /*$PAGE*/
                    13840   ; /*
                    13841   ; *********************************************************************************************************
                    13842   ; *                                       ASSIGN A NAME TO A TASK
                    13843   ; *
                    13844   ; * Description: This function is used to set the name of a task.
                    13845   ; *
                    13846   ; * Arguments  : prio      is the priority of the task that you want the assign a name to.
                    13847   ; *
                    13848   ; *              pname     is a pointer to an ASCII string that contains the name of the task.
                    13849   ; *
                    13850   ; *              perr       is a pointer to an error code that can contain one of the following values:
                    13851   ; *
                    13852   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13853   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13854   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13855   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13856   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13857   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    13858   ; *
                    13859   ; * Returns    : None
                    13860   ; *********************************************************************************************************
                    13861   ; */
                    13862   ; #if OS_TASK_NAME_EN > 0u
                    13863   ; void  OSTaskNameSet (INT8U   prio,
                    13864   ; INT8U  *pname,
                    13865   ; INT8U  *perr)
                    13866   ; {
                    13867   _OSTaskNameSet:
08004398  4E56 0000 13868          link      A6,#0
0800439C  48E7 3800 13869          movem.l   D2/D3/D4,-(A7)
080043A0  262E 0010 13870          move.l    16(A6),D3
080043A4  182E 000B 13871          move.b    11(A6),D4
080043A8  C8BC 0000 13872          and.l     #255,D4
080043AC  00FF      
                    13873   ; OS_TCB    *ptcb;
                    13874   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    13875   ; OS_CPU_SR  cpu_sr = 0u;
                    13876   ; #endif
                    13877   ; #ifdef OS_SAFETY_CRITICAL
                    13878   ; if (perr == (INT8U *)0) {
                    13879   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13880   ; return;
                    13881   ; }
                    13882   ; #endif
                    13883   ; #if OS_ARG_CHK_EN > 0u
                    13884   ; if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
                    13885   ; if (prio != OS_PRIO_SELF) {
                    13886   ; *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
                    13887   ; return;
                    13888   ; }
                    13889   ; }
                    13890   ; if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
                    13891   ; *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
                    13892   ; return;
                    13893   ; }
                    13894   ; #endif
                    13895   ; if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
080043AE  1039 0800 13896          move.b    _OSIntNesting.L,D0
080043B2  0312      
080043B4  0C00 0000 13897          cmp.b     #0,D0
080043B8  630A      13898          bls.s     OSTaskNameSet_1
                    13899   ; *perr = OS_ERR_NAME_SET_ISR;
080043BA  2043      13900          move.l    D3,A0
080043BC  10BC 0012 13901          move.b    #18,(A0)
                    13902   ; return;
080043C0  6000 005A 13903          bra       OSTaskNameSet_3
                    13904   OSTaskNameSet_1:
                    13905   ; }
                    13906   ; OS_ENTER_CRITICAL();
080043C4  40E7      13907          dc.w      16615
080043C6  007C      13908          dc.w      124
080043C8  0700      13909          dc.w      1792
                    13910   ; if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
080043CA  0C04 00FF 13911          cmp.b     #255,D4
080043CE  660A      13912          bne.s     OSTaskNameSet_4
                    13913   ; prio = OSTCBCur->OSTCBPrio;
080043D0  2079 0800 13914          move.l    _OSTCBCur.L,A0
080043D4  042C      
080043D6  1828 0034 13915          move.b    52(A0),D4
                    13916   OSTaskNameSet_4:
                    13917   ; }
                    13918   ; ptcb = OSTCBPrioTbl[prio];
080043DA  C8BC 0000 13919          and.l     #255,D4
080043DE  00FF      
080043E0  2004      13920          move.l    D4,D0
080043E2  E588      13921          lsl.l     #2,D0
080043E4  41F9 0800 13922          lea       _OSTCBPrioTbl.L,A0
080043E8  043C      
080043EA  2430 0800 13923          move.l    0(A0,D0.L),D2
                    13924   ; if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
080043EE  4A82      13925          tst.l     D2
080043F0  660A      13926          bne.s     OSTaskNameSet_6
                    13927   ; OS_EXIT_CRITICAL();                          /* No                                             */
080043F2  46DF      13928          dc.w      18143
                    13929   ; *perr = OS_ERR_TASK_NOT_EXIST;
080043F4  2043      13930          move.l    D3,A0
080043F6  10BC 0043 13931          move.b    #67,(A0)
                    13932   ; return;
080043FA  6020      13933          bra.s     OSTaskNameSet_3
                    13934   OSTaskNameSet_6:
                    13935   ; }
                    13936   ; if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
080043FC  0C82 0000 13937          cmp.l     #1,D2
08004400  0001      
08004402  660A      13938          bne.s     OSTaskNameSet_8
                    13939   ; OS_EXIT_CRITICAL();                          /* Yes                                            */
08004404  46DF      13940          dc.w      18143
                    13941   ; *perr = OS_ERR_TASK_NOT_EXIST;
08004406  2043      13942          move.l    D3,A0
08004408  10BC 0043 13943          move.b    #67,(A0)
                    13944   ; return;
0800440C  600E      13945          bra.s     OSTaskNameSet_3
                    13946   OSTaskNameSet_8:
                    13947   ; }
                    13948   ; ptcb->OSTCBTaskName = pname;
0800440E  2042      13949          move.l    D2,A0
08004410  216E 000C 13950          move.l    12(A6),78(A0)
08004414  004E      
                    13951   ; OS_EXIT_CRITICAL();
08004416  46DF      13952          dc.w      18143
                    13953   ; *perr               = OS_ERR_NONE;
08004418  2043      13954          move.l    D3,A0
0800441A  4210      13955          clr.b     (A0)
                    13956   OSTaskNameSet_3:
0800441C  4CDF 001C 13957          movem.l   (A7)+,D2/D3/D4
08004420  4E5E      13958          unlk      A6
08004422  4E75      13959          rts
                    13960   ; }
                    13961   ; #endif
                    13962   ; /*$PAGE*/
                    13963   ; /*
                    13964   ; *********************************************************************************************************
                    13965   ; *                                       RESUME A SUSPENDED TASK
                    13966   ; *
                    13967   ; * Description: This function is called to resume a previously suspended task.  This is the only call that
                    13968   ; *              will remove an explicit task suspension.
                    13969   ; *
                    13970   ; * Arguments  : prio     is the priority of the task to resume.
                    13971   ; *
                    13972   ; * Returns    : OS_ERR_NONE                if the requested task is resumed
                    13973   ; *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
                    13974   ; *                                         (i.e. >= OS_LOWEST_PRIO)
                    13975   ; *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
                    13976   ; *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
                    13977   ; *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
                    13978   ; *********************************************************************************************************
                    13979   ; */
                    13980   ; #if OS_TASK_SUSPEND_EN > 0u
                    13981   ; INT8U  OSTaskResume (INT8U prio)
                    13982   ; {
                    13983   _OSTaskResume:
08004424  4E56 0000 13984          link      A6,#0
08004428  2F02      13985          move.l    D2,-(A7)
                    13986   ; OS_TCB    *ptcb;
                    13987   ; #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
                    13988   ; OS_CPU_SR  cpu_sr = 0u;
                    13989   ; #endif
                    13990   ; #if OS_ARG_CHK_EN > 0u
                    13991   ; if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
                    13992   ; return (OS_ERR_PRIO_INVALID);
                    13993   ; }
                    13994   ; #endif
                    13995   ; OS_ENTER_CRITICAL();
0800442A  40E7      13996          dc.w      16615
0800442C  007C      13997          dc.w      124
0800442E  0700      13998          dc.w      1792
                    13999   ; ptcb = OSTCBPrioTbl[prio];
08004430  102E 000B 14000          move.b    11(A6),D0
08004434  C0BC 0000 14001          and.l     #255,D0
08004438  00FF      
0800443A  E588      14002          lsl.l     #2,D0
0800443C  41F9 0800 14003          lea       _OSTCBPrioTbl.L,A0
08004440  043C      
08004442  2430 0800 14004          move.l    0(A0,D0.L),D2
                    14005   ; if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
08004446  4A82      14006          tst.l     D2
08004448  6608      14007          bne.s     OSTaskResume_1
                    14008   ; OS_EXIT_CRITICAL();
0800444A  46DF      14009          dc.w      18143
                    14010   ; return (OS_ERR_TASK_RESUME_PRIO);
0800444C  7046      14011          moveq     #70,D0
0800444E  6000 008A 14012          bra       OSTaskResume_3
                    14013   OSTaskResume_1:
                    14014   ; }
                    14015   ; if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
08004452  0C82 0000 14016          cmp.l     #1,D2
08004456  0001      
08004458  6608      14017          bne.s     OSTaskResume_4
                    14018   ; OS_EXIT_CRITICAL();
0800445A  46DF      14019          dc.w      18143
                    14020   ; return (OS_ERR_TASK_NOT_EXIST);
0800445C  7043      14021          moveq     #67,D0
0800445E  6000 007A 14022          bra       OSTaskResume_3
                    14023   OSTaskResume_4:
                    14024   ; }
                    14025   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
08004462  2042      14026          move.l    D2,A0
08004464  1028 0032 14027          move.b    50(A0),D0
08004468  C03C 0008 14028          and.b     #8,D0
0800446C  6700 0068 14029          beq       OSTaskResume_6
                    14030   ; ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
08004470  2042      14031          move.l    D2,A0
08004472  7008      14032          moveq     #8,D0
08004474  4600      14033          not.b     D0
08004476  C128 0032 14034          and.b     D0,50(A0)
                    14035   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
0800447A  2042      14036          move.l    D2,A0
0800447C  1028 0032 14037          move.b    50(A0),D0
08004480  6600 004E 14038          bne       OSTaskResume_8
                    14039   ; if (ptcb->OSTCBDly == 0u) {
08004484  2042      14040          move.l    D2,A0
08004486  2028 002E 14041          move.l    46(A0),D0
0800448A  6600 0040 14042          bne       OSTaskResume_10
                    14043   ; OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
0800448E  2042      14044          move.l    D2,A0
08004490  1028 0038 14045          move.b    56(A0),D0
08004494  8139 0800 14046          or.b      D0,_OSRdyGrp.L
08004498  031A      
                    14047   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0800449A  2042      14048          move.l    D2,A0
0800449C  1028 0036 14049          move.b    54(A0),D0
080044A0  C0BC 0000 14050          and.l     #255,D0
080044A4  00FF      
080044A6  41F9 0800 14051          lea       _OSRdyTbl.L,A0
080044AA  031C      
080044AC  2242      14052          move.l    D2,A1
080044AE  1229 0037 14053          move.b    55(A1),D1
080044B2  8330 0800 14054          or.b      D1,0(A0,D0.L)
                    14055   ; OS_EXIT_CRITICAL();
080044B6  46DF      14056          dc.w      18143
                    14057   ; if (OSRunning == OS_TRUE) {
080044B8  1039 0800 14058          move.b    _OSRunning.L,D0
080044BC  0324      
080044BE  0C00 0001 14059          cmp.b     #1,D0
080044C2  6606      14060          bne.s     OSTaskResume_12
                    14061   ; OS_Sched();                               /* Find new highest priority task        */
080044C4  4EB9 0800 14062          jsr       _OS_Sched
080044C8  0F8A      
                    14063   OSTaskResume_12:
080044CA  6002      14064          bra.s     OSTaskResume_11
                    14065   OSTaskResume_10:
                    14066   ; }
                    14067   ; } else {
                    14068   ; OS_EXIT_CRITICAL();
080044CC  46DF      14069          dc.w      18143
                    14070   OSTaskResume_11:
080044CE  6002      14071          bra.s     OSTaskResume_9
                    14072   OSTaskResume_8:
                    14073   ; }
                    14074   ; } else {                                              /* Must be pending on event              */
                    14075   ; OS_EXIT_CRITICAL();
080044D0  46DF      14076          dc.w      18143
                    14077   OSTaskResume_9:
                    14078   ; }
                    14079   ; return (OS_ERR_NONE);
080044D2  4200      14080          clr.b     D0
080044D4  6004      14081          bra.s     OSTaskResume_3
                    14082   OSTaskResume_6:
                    14083   ; }
                    14084   ; OS_EXIT_CRITICAL();
080044D6  46DF      14085          dc.w      18143
                    14086   ; return (OS_ERR_TASK_NOT_SUSPENDED);
080044D8  7044      14087          moveq     #68,D0
                    14088   OSTaskResume_3:
080044DA  241F      14089          move.l    (A7)+,D2
080044DC  4E5E      14090          unlk      A6
080044DE  4E75      14091          rts
                    14092   ; }
                    14093   ; #endif
                    14094   ; /*$PAGE*/
                    14095   ; /*
                    14096   ; *********************************************************************************************************
                    14097   ; *                                           STACK CHECKING
                    14098   ; *
                    14099   ; * Description: This function is called to check the amount of free memory left on the specified task's
                    14100   ; *              stack.
                    14101   ; *
                    14102   ; * Arguments  : prio          is the task priority
                    14103   ; *
                    14104   ; *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
                    14105   ; *
                    14106   ; * Returns    : OS_ERR_NONE            upon success
                    14107   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14108   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14109   ; *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
                    14110   ; *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
                    14111   ; *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
                    14112   ; *********************************************************************************************************
                    14113   ; */
                    14114   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14115   ; INT8U  OSTaskStkChk (INT8U         prio,
                    14116   ; OS_STK_DATA  *p_stk_data)
                    14117   ; {
                    14118   _OSTaskStkChk:
080044E0  4E56 FFF8 14119          link      A6,#-8
080044E4  48E7 3C00 14120          movem.l   D2/D3/D4/D5,-(A7)
080044E8  282E 000C 14121          move.l    12(A6),D4
080044EC  1A2E 000B 14122          move.b    11(A6),D5
080044F0  CABC 0000 14123          and.l     #255,D5
080044F4  00FF      
                    14124   ; OS_TCB    *ptcb;
                    14125   ; OS_STK    *pchk;
                    14126   ; INT32U     nfree;
                    14127   ; INT32U     size;
                    14128   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    14129   ; OS_CPU_SR  cpu_sr = 0u;
                    14130   ; #endif
                    14131   ; #if OS_ARG_CHK_EN > 0u
                    14132   ; if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
                    14133   ; if (prio != OS_PRIO_SELF) {
                    14134   ; return (OS_ERR_PRIO_INVALID);
                    14135   ; }
                    14136   ; }
                    14137   ; if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
                    14138   ; return (OS_ERR_PDATA_NULL);
                    14139   ; }
                    14140   ; #endif
                    14141   ; p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
080044F6  2044      14142          move.l    D4,A0
080044F8  4290      14143          clr.l     (A0)
                    14144   ; p_stk_data->OSUsed = 0u;
080044FA  2044      14145          move.l    D4,A0
080044FC  42A8 0004 14146          clr.l     4(A0)
                    14147   ; OS_ENTER_CRITICAL();
08004500  40E7      14148          dc.w      16615
08004502  007C      14149          dc.w      124
08004504  0700      14150          dc.w      1792
                    14151   ; if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
08004506  0C05 00FF 14152          cmp.b     #255,D5
0800450A  660A      14153          bne.s     OSTaskStkChk_1
                    14154   ; prio = OSTCBCur->OSTCBPrio;
0800450C  2079 0800 14155          move.l    _OSTCBCur.L,A0
08004510  042C      
08004512  1A28 0034 14156          move.b    52(A0),D5
                    14157   OSTaskStkChk_1:
                    14158   ; }
                    14159   ; ptcb = OSTCBPrioTbl[prio];
08004516  CABC 0000 14160          and.l     #255,D5
0800451A  00FF      
0800451C  2005      14161          move.l    D5,D0
0800451E  E588      14162          lsl.l     #2,D0
08004520  41F9 0800 14163          lea       _OSTCBPrioTbl.L,A0
08004524  043C      
08004526  2430 0800 14164          move.l    0(A0,D0.L),D2
                    14165   ; if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
0800452A  4A82      14166          tst.l     D2
0800452C  6608      14167          bne.s     OSTaskStkChk_3
                    14168   ; OS_EXIT_CRITICAL();
0800452E  46DF      14169          dc.w      18143
                    14170   ; return (OS_ERR_TASK_NOT_EXIST);
08004530  7043      14171          moveq     #67,D0
08004532  6000 005C 14172          bra       OSTaskStkChk_5
                    14173   OSTaskStkChk_3:
                    14174   ; }
                    14175   ; if (ptcb == OS_TCB_RESERVED) {
08004536  0C82 0000 14176          cmp.l     #1,D2
0800453A  0001      
0800453C  6608      14177          bne.s     OSTaskStkChk_6
                    14178   ; OS_EXIT_CRITICAL();
0800453E  46DF      14179          dc.w      18143
                    14180   ; return (OS_ERR_TASK_NOT_EXIST);
08004540  7043      14181          moveq     #67,D0
08004542  6000 004C 14182          bra       OSTaskStkChk_5
                    14183   OSTaskStkChk_6:
                    14184   ; }
                    14185   ; if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
08004546  2042      14186          move.l    D2,A0
08004548  3028 0010 14187          move.w    16(A0),D0
0800454C  C07C 0001 14188          and.w     #1,D0
08004550  6608      14189          bne.s     OSTaskStkChk_8
                    14190   ; OS_EXIT_CRITICAL();
08004552  46DF      14191          dc.w      18143
                    14192   ; return (OS_ERR_TASK_OPT);
08004554  7045      14193          moveq     #69,D0
08004556  6000 0038 14194          bra       OSTaskStkChk_5
                    14195   OSTaskStkChk_8:
                    14196   ; }
                    14197   ; nfree = 0u;
0800455A  4283      14198          clr.l     D3
                    14199   ; size  = ptcb->OSTCBStkSize;
0800455C  2042      14200          move.l    D2,A0
0800455E  2D68 000C 14201          move.l    12(A0),-4(A6)
08004562  FFFC      
                    14202   ; pchk  = ptcb->OSTCBStkBottom;
08004564  2042      14203          move.l    D2,A0
08004566  2D68 0008 14204          move.l    8(A0),-8(A6)
0800456A  FFF8      
                    14205   ; OS_EXIT_CRITICAL();
0800456C  46DF      14206          dc.w      18143
                    14207   ; #if OS_STK_GROWTH == 1u
                    14208   ; while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
                    14209   OSTaskStkChk_10:
0800456E  206E FFF8 14210          move.l    -8(A6),A0
08004572  54AE FFF8 14211          addq.l    #2,-8(A6)
08004576  3010      14212          move.w    (A0),D0
08004578  6604      14213          bne.s     OSTaskStkChk_12
                    14214   ; nfree++;
0800457A  5283      14215          addq.l    #1,D3
0800457C  60F0      14216          bra       OSTaskStkChk_10
                    14217   OSTaskStkChk_12:
                    14218   ; }
                    14219   ; #else
                    14220   ; while (*pchk-- == (OS_STK)0) {
                    14221   ; nfree++;
                    14222   ; }
                    14223   ; #endif
                    14224   ; p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
0800457E  2044      14225          move.l    D4,A0
08004580  2083      14226          move.l    D3,(A0)
                    14227   ; p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
08004582  202E FFFC 14228          move.l    -4(A6),D0
08004586  9083      14229          sub.l     D3,D0
08004588  2044      14230          move.l    D4,A0
0800458A  2140 0004 14231          move.l    D0,4(A0)
                    14232   ; return (OS_ERR_NONE);
0800458E  4200      14233          clr.b     D0
                    14234   OSTaskStkChk_5:
08004590  4CDF 003C 14235          movem.l   (A7)+,D2/D3/D4/D5
08004594  4E5E      14236          unlk      A6
08004596  4E75      14237          rts
                    14238   ; }
                    14239   ; #endif
                    14240   ; /*$PAGE*/
                    14241   ; /*
                    14242   ; *********************************************************************************************************
                    14243   ; *                                           SUSPEND A TASK
                    14244   ; *
                    14245   ; * Description: This function is called to suspend a task.  The task can be the calling task if the
                    14246   ; *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
                    14247   ; *
                    14248   ; * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
                    14249   ; *                       calling task will suspend itself and rescheduling will occur.
                    14250   ; *
                    14251   ; * Returns    : OS_ERR_NONE               if the requested task is suspended
                    14252   ; *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
                    14253   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    14254   ; *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14255   ; *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
                    14256   ; *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
                    14257   ; *
                    14258   ; * Note       : You should use this function with great care.  If you suspend a task that is waiting for
                    14259   ; *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
                    14260   ; *              running when the event arrives.
                    14261   ; *********************************************************************************************************
                    14262   ; */
                    14263   ; #if OS_TASK_SUSPEND_EN > 0u
                    14264   ; INT8U  OSTaskSuspend (INT8U prio)
                    14265   ; {
                    14266   _OSTaskSuspend:
08004598  4E56 0000 14267          link      A6,#0
0800459C  48E7 3C00 14268          movem.l   D2/D3/D4/D5,-(A7)
080045A0  182E 000B 14269          move.b    11(A6),D4
080045A4  C8BC 0000 14270          and.l     #255,D4
080045A8  00FF      
                    14271   ; BOOLEAN    self;
                    14272   ; OS_TCB    *ptcb;
                    14273   ; INT8U      y;
                    14274   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14275   ; OS_CPU_SR  cpu_sr = 0u;
                    14276   ; #endif
                    14277   ; #if OS_ARG_CHK_EN > 0u
                    14278   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
                    14279   ; return (OS_ERR_TASK_SUSPEND_IDLE);
                    14280   ; }
                    14281   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    14282   ; if (prio != OS_PRIO_SELF) {
                    14283   ; return (OS_ERR_PRIO_INVALID);
                    14284   ; }
                    14285   ; }
                    14286   ; #endif
                    14287   ; OS_ENTER_CRITICAL();
080045AA  40E7      14288          dc.w      16615
080045AC  007C      14289          dc.w      124
080045AE  0700      14290          dc.w      1792
                    14291   ; if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
080045B0  0C04 00FF 14292          cmp.b     #255,D4
080045B4  660E      14293          bne.s     OSTaskSuspend_1
                    14294   ; prio = OSTCBCur->OSTCBPrio;
080045B6  2079 0800 14295          move.l    _OSTCBCur.L,A0
080045BA  042C      
080045BC  1828 0034 14296          move.b    52(A0),D4
                    14297   ; self = OS_TRUE;
080045C0  7601      14298          moveq     #1,D3
080045C2  6012      14299          bra.s     OSTaskSuspend_4
                    14300   OSTaskSuspend_1:
                    14301   ; } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
080045C4  2079 0800 14302          move.l    _OSTCBCur.L,A0
080045C8  042C      
080045CA  B828 0034 14303          cmp.b     52(A0),D4
080045CE  6604      14304          bne.s     OSTaskSuspend_3
                    14305   ; self = OS_TRUE;
080045D0  7601      14306          moveq     #1,D3
080045D2  6002      14307          bra.s     OSTaskSuspend_4
                    14308   OSTaskSuspend_3:
                    14309   ; } else {
                    14310   ; self = OS_FALSE;                                        /* No suspending another task          */
080045D4  4203      14311          clr.b     D3
                    14312   OSTaskSuspend_4:
                    14313   ; }
                    14314   ; ptcb = OSTCBPrioTbl[prio];
080045D6  C8BC 0000 14315          and.l     #255,D4
080045DA  00FF      
080045DC  2004      14316          move.l    D4,D0
080045DE  E588      14317          lsl.l     #2,D0
080045E0  41F9 0800 14318          lea       _OSTCBPrioTbl.L,A0
080045E4  043C      
080045E6  2430 0800 14319          move.l    0(A0,D0.L),D2
                    14320   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
080045EA  4A82      14321          tst.l     D2
080045EC  6608      14322          bne.s     OSTaskSuspend_5
                    14323   ; OS_EXIT_CRITICAL();
080045EE  46DF      14324          dc.w      18143
                    14325   ; return (OS_ERR_TASK_SUSPEND_PRIO);
080045F0  7048      14326          moveq     #72,D0
080045F2  6000 0068 14327          bra       OSTaskSuspend_7
                    14328   OSTaskSuspend_5:
                    14329   ; }
                    14330   ; if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
080045F6  0C82 0000 14331          cmp.l     #1,D2
080045FA  0001      
080045FC  6608      14332          bne.s     OSTaskSuspend_8
                    14333   ; OS_EXIT_CRITICAL();
080045FE  46DF      14334          dc.w      18143
                    14335   ; return (OS_ERR_TASK_NOT_EXIST);
08004600  7043      14336          moveq     #67,D0
08004602  6000 0058 14337          bra       OSTaskSuspend_7
                    14338   OSTaskSuspend_8:
                    14339   ; }
                    14340   ; y            = ptcb->OSTCBY;
08004606  2042      14341          move.l    D2,A0
08004608  1A28 0036 14342          move.b    54(A0),D5
                    14343   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
0800460C  CABC 0000 14344          and.l     #255,D5
08004610  00FF      
08004612  41F9 0800 14345          lea       _OSRdyTbl.L,A0
08004616  031C      
08004618  2242      14346          move.l    D2,A1
0800461A  1029 0037 14347          move.b    55(A1),D0
0800461E  4600      14348          not.b     D0
08004620  C130 5800 14349          and.b     D0,0(A0,D5.L)
                    14350   ; if (OSRdyTbl[y] == 0u) {
08004624  CABC 0000 14351          and.l     #255,D5
08004628  00FF      
0800462A  41F9 0800 14352          lea       _OSRdyTbl.L,A0
0800462E  031C      
08004630  1030 5800 14353          move.b    0(A0,D5.L),D0
08004634  660E      14354          bne.s     OSTaskSuspend_10
                    14355   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
08004636  2042      14356          move.l    D2,A0
08004638  1028 0038 14357          move.b    56(A0),D0
0800463C  4600      14358          not.b     D0
0800463E  C139 0800 14359          and.b     D0,_OSRdyGrp.L
08004642  031A      
                    14360   OSTaskSuspend_10:
                    14361   ; }
                    14362   ; ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
08004644  2042      14363          move.l    D2,A0
08004646  0028 0008 14364          or.b      #8,50(A0)
0800464A  0032      
                    14365   ; OS_EXIT_CRITICAL();
0800464C  46DF      14366          dc.w      18143
                    14367   ; if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
0800464E  0C03 0001 14368          cmp.b     #1,D3
08004652  6606      14369          bne.s     OSTaskSuspend_12
                    14370   ; OS_Sched();                                             /* Find new highest priority task      */
08004654  4EB9 0800 14371          jsr       _OS_Sched
08004658  0F8A      
                    14372   OSTaskSuspend_12:
                    14373   ; }
                    14374   ; return (OS_ERR_NONE);
0800465A  4200      14375          clr.b     D0
                    14376   OSTaskSuspend_7:
0800465C  4CDF 003C 14377          movem.l   (A7)+,D2/D3/D4/D5
08004660  4E5E      14378          unlk      A6
08004662  4E75      14379          rts
                    14380   ; }
                    14381   ; #endif
                    14382   ; /*$PAGE*/
                    14383   ; /*
                    14384   ; *********************************************************************************************************
                    14385   ; *                                            QUERY A TASK
                    14386   ; *
                    14387   ; * Description: This function is called to obtain a copy of the desired task's TCB.
                    14388   ; *
                    14389   ; * Arguments  : prio         is the priority of the task to obtain information from.
                    14390   ; *
                    14391   ; *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
                    14392   ; *
                    14393   ; * Returns    : OS_ERR_NONE            if the requested task is suspended
                    14394   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14395   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14396   ; *              OS_ERR_PRIO            if the desired task has not been created
                    14397   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
                    14398   ; *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
                    14399   ; *********************************************************************************************************
                    14400   ; */
                    14401   ; #if OS_TASK_QUERY_EN > 0u
                    14402   ; INT8U  OSTaskQuery (INT8U    prio,
                    14403   ; OS_TCB  *p_task_data)
                    14404   ; {
                    14405   _OSTaskQuery:
08004664  4E56 0000 14406          link      A6,#0
08004668  48E7 3000 14407          movem.l   D2/D3,-(A7)
0800466C  162E 000B 14408          move.b    11(A6),D3
08004670  C6BC 0000 14409          and.l     #255,D3
08004674  00FF      
                    14410   ; OS_TCB    *ptcb;
                    14411   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14412   ; OS_CPU_SR  cpu_sr = 0u;
                    14413   ; #endif
                    14414   ; #if OS_ARG_CHK_EN > 0u
                    14415   ; if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
                    14416   ; if (prio != OS_PRIO_SELF) {
                    14417   ; return (OS_ERR_PRIO_INVALID);
                    14418   ; }
                    14419   ; }
                    14420   ; if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
                    14421   ; return (OS_ERR_PDATA_NULL);
                    14422   ; }
                    14423   ; #endif
                    14424   ; OS_ENTER_CRITICAL();
08004676  40E7      14425          dc.w      16615
08004678  007C      14426          dc.w      124
0800467A  0700      14427          dc.w      1792
                    14428   ; if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
0800467C  0C03 00FF 14429          cmp.b     #255,D3
08004680  660A      14430          bne.s     OSTaskQuery_1
                    14431   ; prio = OSTCBCur->OSTCBPrio;
08004682  2079 0800 14432          move.l    _OSTCBCur.L,A0
08004686  042C      
08004688  1628 0034 14433          move.b    52(A0),D3
                    14434   OSTaskQuery_1:
                    14435   ; }
                    14436   ; ptcb = OSTCBPrioTbl[prio];
0800468C  C6BC 0000 14437          and.l     #255,D3
08004690  00FF      
08004692  2003      14438          move.l    D3,D0
08004694  E588      14439          lsl.l     #2,D0
08004696  41F9 0800 14440          lea       _OSTCBPrioTbl.L,A0
0800469A  043C      
0800469C  2430 0800 14441          move.l    0(A0,D0.L),D2
                    14442   ; if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
080046A0  4A82      14443          tst.l     D2
080046A2  6606      14444          bne.s     OSTaskQuery_3
                    14445   ; OS_EXIT_CRITICAL();
080046A4  46DF      14446          dc.w      18143
                    14447   ; return (OS_ERR_PRIO);
080046A6  7029      14448          moveq     #41,D0
080046A8  6026      14449          bra.s     OSTaskQuery_5
                    14450   OSTaskQuery_3:
                    14451   ; }
                    14452   ; if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
080046AA  0C82 0000 14453          cmp.l     #1,D2
080046AE  0001      
080046B0  6606      14454          bne.s     OSTaskQuery_6
                    14455   ; OS_EXIT_CRITICAL();
080046B2  46DF      14456          dc.w      18143
                    14457   ; return (OS_ERR_TASK_NOT_EXIST);
080046B4  7043      14458          moveq     #67,D0
080046B6  6018      14459          bra.s     OSTaskQuery_5
                    14460   OSTaskQuery_6:
                    14461   ; }
                    14462   ; /* Copy TCB into user storage area                    */
                    14463   ; OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
080046B8  4878 0056 14464          pea       86
080046BC  2F02      14465          move.l    D2,-(A7)
080046BE  2F2E 000C 14466          move.l    12(A6),-(A7)
080046C2  4EB9 0800 14467          jsr       _OS_MemCopy
080046C6  0F60      
080046C8  DEFC 000C 14468          add.w     #12,A7
                    14469   ; OS_EXIT_CRITICAL();
080046CC  46DF      14470          dc.w      18143
                    14471   ; return (OS_ERR_NONE);
080046CE  4200      14472          clr.b     D0
                    14473   OSTaskQuery_5:
080046D0  4CDF 000C 14474          movem.l   (A7)+,D2/D3
080046D4  4E5E      14475          unlk      A6
080046D6  4E75      14476          rts
                    14477   ; }
                    14478   ; #endif
                    14479   ; /*$PAGE*/
                    14480   ; /*
                    14481   ; *********************************************************************************************************
                    14482   ; *                              GET THE CURRENT VALUE OF A TASK REGISTER
                    14483   ; *
                    14484   ; * Description: This function is called to obtain the current value of a task register.  Task registers
                    14485   ; *              are application specific and can be used to store task specific values such as 'error
                    14486   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14487   ; *
                    14488   ; * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
                    14489   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14490   ; *
                    14491   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14492   ; *                        than OS_TASK_REG_TBL_SIZE
                    14493   ; *
                    14494   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14495   ; *
                    14496   ; *                        OS_ERR_NONE            if the call was successful
                    14497   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14498   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14499   ; *
                    14500   ; * Returns    : The current value of the task's register or 0 if an error is detected.
                    14501   ; *
                    14502   ; * Note(s)    : The maximum number of task variables is 254
                    14503   ; *********************************************************************************************************
                    14504   ; */
                    14505   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14506   ; INT32U  OSTaskRegGet (INT8U   prio,
                    14507   ; INT8U   id,
                    14508   ; INT8U  *perr)
                    14509   ; {
                    14510   _OSTaskRegGet:
080046D8  4E56 FFFC 14511          link      A6,#-4
080046DC  2F02      14512          move.l    D2,-(A7)
                    14513   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14514   ; OS_CPU_SR  cpu_sr = 0u;
                    14515   ; #endif
                    14516   ; INT32U     value;
                    14517   ; OS_TCB    *ptcb;
                    14518   ; #ifdef OS_SAFETY_CRITICAL
                    14519   ; if (perr == (INT8U *)0) {
                    14520   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14521   ; return (0u);
                    14522   ; }
                    14523   ; #endif
                    14524   ; #if OS_ARG_CHK_EN > 0u
                    14525   ; if (prio >= OS_LOWEST_PRIO) {
                    14526   ; if (prio != OS_PRIO_SELF) {
                    14527   ; *perr = OS_ERR_PRIO_INVALID;
                    14528   ; return (0u);
                    14529   ; }
                    14530   ; }
                    14531   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14532   ; *perr = OS_ERR_ID_INVALID;
                    14533   ; return (0u);
                    14534   ; }
                    14535   ; #endif
                    14536   ; OS_ENTER_CRITICAL();
080046DE  40E7      14537          dc.w      16615
080046E0  007C      14538          dc.w      124
080046E2  0700      14539          dc.w      1792
                    14540   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
080046E4  102E 000B 14541          move.b    11(A6),D0
080046E8  0C00 00FF 14542          cmp.b     #255,D0
080046EC  6608      14543          bne.s     OSTaskRegGet_1
                    14544   ; ptcb = OSTCBCur;
080046EE  2439 0800 14545          move.l    _OSTCBCur.L,D2
080046F2  042C      
080046F4  6016      14546          bra.s     OSTaskRegGet_2
                    14547   OSTaskRegGet_1:
                    14548   ; } else {
                    14549   ; ptcb = OSTCBPrioTbl[prio];
080046F6  102E 000B 14550          move.b    11(A6),D0
080046FA  C0BC 0000 14551          and.l     #255,D0
080046FE  00FF      
08004700  E588      14552          lsl.l     #2,D0
08004702  41F9 0800 14553          lea       _OSTCBPrioTbl.L,A0
08004706  043C      
08004708  2430 0800 14554          move.l    0(A0,D0.L),D2
                    14555   OSTaskRegGet_2:
                    14556   ; }
                    14557   ; value = ptcb->OSTCBRegTbl[id];
0800470C  2042      14558          move.l    D2,A0
0800470E  102E 000F 14559          move.b    15(A6),D0
08004712  C0BC 0000 14560          and.l     #255,D0
08004716  00FF      
08004718  E588      14561          lsl.l     #2,D0
0800471A  D1C0      14562          add.l     D0,A0
0800471C  2D68 0052 14563          move.l    82(A0),-4(A6)
08004720  FFFC      
                    14564   ; OS_EXIT_CRITICAL();
08004722  46DF      14565          dc.w      18143
                    14566   ; *perr = OS_ERR_NONE;
08004724  206E 0010 14567          move.l    16(A6),A0
08004728  4210      14568          clr.b     (A0)
                    14569   ; return (value);
0800472A  202E FFFC 14570          move.l    -4(A6),D0
0800472E  241F      14571          move.l    (A7)+,D2
08004730  4E5E      14572          unlk      A6
08004732  4E75      14573          rts
                    14574   ; }
                    14575   ; #endif
                    14576   ; /*$PAGE*/
                    14577   ; /*
                    14578   ; ************************************************************************************************************************
                    14579   ; *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
                    14580   ; *
                    14581   ; * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
                    14582   ; *              allocated dynamically instead of statically.
                    14583   ; *
                    14584   ; * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
                    14585   ; *
                    14586   ; *                            OS_ERR_NONE               if the call was successful
                    14587   ; *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
                    14588   ; *                                                           have available through OS_TASK_REG_TBL_SIZE.
                    14589   ; *
                    14590   ; * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
                    14591   ; ************************************************************************************************************************
                    14592   ; */
                    14593   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14594   ; INT8U  OSTaskRegGetID (INT8U  *perr)
                    14595   ; {
                    14596   _OSTaskRegGetID:
08004734  4E56 FFFC 14597          link      A6,#-4
                    14598   ; #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
                    14599   ; OS_CPU_SR  cpu_sr = 0u;
                    14600   ; #endif
                    14601   ; INT8U      id;
                    14602   ; #ifdef OS_SAFETY_CRITICAL
                    14603   ; if (perr == (INT8U *)0) {
                    14604   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14605   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
                    14606   ; }
                    14607   ; #endif
                    14608   ; OS_ENTER_CRITICAL();
08004738  40E7      14609          dc.w      16615
0800473A  007C      14610          dc.w      124
0800473C  0700      14611          dc.w      1792
                    14612   ; if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
0800473E  1039 0800 14613          move.b    _OSTaskRegNextAvailID.L,D0
08004742  0D80      
08004744  0C00 0001 14614          cmp.b     #1,D0
08004748  650E      14615          blo.s     OSTaskRegGetID_1
                    14616   ; *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
0800474A  206E 0008 14617          move.l    8(A6),A0
0800474E  10BC 0096 14618          move.b    #150,(A0)
                    14619   ; OS_EXIT_CRITICAL();
08004752  46DF      14620          dc.w      18143
                    14621   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
08004754  7001      14622          moveq     #1,D0
08004756  601A      14623          bra.s     OSTaskRegGetID_3
                    14624   OSTaskRegGetID_1:
                    14625   ; }
                    14626   ; id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
08004758  1D79 0800 14627          move.b    _OSTaskRegNextAvailID.L,-1(A6)
0800475C  0D80 FFFF 
                    14628   ; OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
08004760  5239 0800 14629          addq.b    #1,_OSTaskRegNextAvailID.L
08004764  0D80      
                    14630   ; OS_EXIT_CRITICAL();
08004766  46DF      14631          dc.w      18143
                    14632   ; *perr = OS_ERR_NONE;
08004768  206E 0008 14633          move.l    8(A6),A0
0800476C  4210      14634          clr.b     (A0)
                    14635   ; return (id);
0800476E  102E FFFF 14636          move.b    -1(A6),D0
                    14637   OSTaskRegGetID_3:
08004772  4E5E      14638          unlk      A6
08004774  4E75      14639          rts
                    14640   ; }
                    14641   ; #endif
                    14642   ; /*$PAGE*/
                    14643   ; /*
                    14644   ; *********************************************************************************************************
                    14645   ; *                              SET THE CURRENT VALUE OF A TASK VARIABLE
                    14646   ; *
                    14647   ; * Description: This function is called to change the current value of a task register.  Task registers
                    14648   ; *              are application specific and can be used to store task specific values such as 'error
                    14649   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14650   ; *
                    14651   ; * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
                    14652   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14653   ; *
                    14654   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14655   ; *                        than OS_TASK_REG_TBL_SIZE
                    14656   ; *
                    14657   ; *              value     is the desired value for the task register.
                    14658   ; *
                    14659   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14660   ; *
                    14661   ; *                        OS_ERR_NONE            if the call was successful
                    14662   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14663   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14664   ; *
                    14665   ; * Returns    : The current value of the task's variable or 0 if an error is detected.
                    14666   ; *
                    14667   ; * Note(s)    : The maximum number of task variables is 254
                    14668   ; *********************************************************************************************************
                    14669   ; */
                    14670   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14671   ; void  OSTaskRegSet (INT8U    prio,
                    14672   ; INT8U    id,
                    14673   ; INT32U   value,
                    14674   ; INT8U   *perr)
                    14675   ; {
                    14676   _OSTaskRegSet:
08004776  4E56 0000 14677          link      A6,#0
0800477A  2F02      14678          move.l    D2,-(A7)
                    14679   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14680   ; OS_CPU_SR  cpu_sr = 0u;
                    14681   ; #endif
                    14682   ; OS_TCB    *ptcb;
                    14683   ; #ifdef OS_SAFETY_CRITICAL
                    14684   ; if (perr == (INT8U *)0) {
                    14685   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14686   ; return;
                    14687   ; }
                    14688   ; #endif
                    14689   ; #if OS_ARG_CHK_EN > 0u
                    14690   ; if (prio >= OS_LOWEST_PRIO) {
                    14691   ; if (prio != OS_PRIO_SELF) {
                    14692   ; *perr = OS_ERR_PRIO_INVALID;
                    14693   ; return;
                    14694   ; }
                    14695   ; }
                    14696   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14697   ; *perr = OS_ERR_ID_INVALID;
                    14698   ; return;
                    14699   ; }
                    14700   ; #endif
                    14701   ; OS_ENTER_CRITICAL();
0800477C  40E7      14702          dc.w      16615
0800477E  007C      14703          dc.w      124
08004780  0700      14704          dc.w      1792
                    14705   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
08004782  102E 000B 14706          move.b    11(A6),D0
08004786  0C00 00FF 14707          cmp.b     #255,D0
0800478A  6608      14708          bne.s     OSTaskRegSet_1
                    14709   ; ptcb = OSTCBCur;
0800478C  2439 0800 14710          move.l    _OSTCBCur.L,D2
08004790  042C      
08004792  6016      14711          bra.s     OSTaskRegSet_2
                    14712   OSTaskRegSet_1:
                    14713   ; } else {
                    14714   ; ptcb = OSTCBPrioTbl[prio];
08004794  102E 000B 14715          move.b    11(A6),D0
08004798  C0BC 0000 14716          and.l     #255,D0
0800479C  00FF      
0800479E  E588      14717          lsl.l     #2,D0
080047A0  41F9 0800 14718          lea       _OSTCBPrioTbl.L,A0
080047A4  043C      
080047A6  2430 0800 14719          move.l    0(A0,D0.L),D2
                    14720   OSTaskRegSet_2:
                    14721   ; }
                    14722   ; ptcb->OSTCBRegTbl[id] = value;
080047AA  2042      14723          move.l    D2,A0
080047AC  102E 000F 14724          move.b    15(A6),D0
080047B0  C0BC 0000 14725          and.l     #255,D0
080047B4  00FF      
080047B6  E588      14726          lsl.l     #2,D0
080047B8  D1C0      14727          add.l     D0,A0
080047BA  216E 0010 14728          move.l    16(A6),82(A0)
080047BE  0052      
                    14729   ; OS_EXIT_CRITICAL();
080047C0  46DF      14730          dc.w      18143
                    14731   ; *perr                 = OS_ERR_NONE;
080047C2  206E 0014 14732          move.l    20(A6),A0
080047C6  4210      14733          clr.b     (A0)
080047C8  241F      14734          move.l    (A7)+,D2
080047CA  4E5E      14735          unlk      A6
080047CC  4E75      14736          rts
                    14737   ; }
                    14738   ; #endif
                    14739   ; /*$PAGE*/
                    14740   ; /*
                    14741   ; *********************************************************************************************************
                    14742   ; *                                    CATCH ACCIDENTAL TASK RETURN
                    14743   ; *
                    14744   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    14745   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    14746   ; *
                    14747   ; * Arguments  : none
                    14748   ; *
                    14749   ; * Returns    : none
                    14750   ; *
                    14751   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    14752   ; *********************************************************************************************************
                    14753   ; */
                    14754   ; void  OS_TaskReturn (void)
                    14755   ; {
                    14756   _OS_TaskReturn:
                    14757   ; OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
080047CE  2F39 0800 14758          move.l    _OSTCBCur.L,-(A7)
080047D2  042C      
080047D4  4EB9 0800 14759          jsr       _OSTaskReturnHook
080047D8  0278      
080047DA  584F      14760          addq.w    #4,A7
                    14761   ; #if OS_TASK_DEL_EN > 0u
                    14762   ; (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
080047DC  4878 00FF 14763          pea       255
080047E0  4EB9 0800 14764          jsr       _OSTaskDel
080047E4  408C      
080047E6  584F      14765          addq.w    #4,A7
080047E8  C0BC 0000 14766          and.l     #255,D0
080047EC  00FF      
080047EE  4E75      14767          rts
                    14768   ; #else
                    14769   ; for (;;) {
                    14770   ; OSTimeDly(OS_TICKS_PER_SEC);
                    14771   ; }
                    14772   ; #endif
                    14773   ; }
                    14774   ; /*$PAGE*/
                    14775   ; /*
                    14776   ; *********************************************************************************************************
                    14777   ; *                                          CLEAR TASK STACK
                    14778   ; *
                    14779   ; * Description: This function is used to clear the stack of a task (i.e. write all zeros)
                    14780   ; *
                    14781   ; * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
                    14782   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    14783   ; *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
                    14784   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    14785   ; *                       highest memory location of the stack and the stack will grow with increasing
                    14786   ; *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
                    14787   ; *
                    14788   ; *              size     is the number of 'stack elements' to clear.
                    14789   ; *
                    14790   ; *              opt      contains additional information (or options) about the behavior of the task.  The
                    14791   ; *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    14792   ; *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
                    14793   ; *
                    14794   ; * Returns    : none
                    14795   ; *********************************************************************************************************
                    14796   ; */
                    14797   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14798   ; void  OS_TaskStkClr (OS_STK  *pbos,
                    14799   ; INT32U   size,
                    14800   ; INT16U   opt)
                    14801   ; {
                    14802   _OS_TaskStkClr:
080047F0  4E56 0000 14803          link      A6,#0
                    14804   ; if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
080047F4  302E 0012 14805          move.w    18(A6),D0
080047F8  C07C 0001 14806          and.w     #1,D0
080047FC  6726      14807          beq.s     OS_TaskStkClr_7
                    14808   ; if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
080047FE  302E 0012 14809          move.w    18(A6),D0
08004802  C07C 0002 14810          and.w     #2,D0
08004806  671C      14811          beq.s     OS_TaskStkClr_7
                    14812   ; #if OS_STK_GROWTH == 1u
                    14813   ; while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                    14814   OS_TaskStkClr_5:
08004808  202E 000C 14815          move.l    12(A6),D0
0800480C  0C80 0000 14816          cmp.l     #0,D0
08004810  0000      
08004812  6310      14817          bls.s     OS_TaskStkClr_7
                    14818   ; size--;
08004814  53AE 000C 14819          subq.l    #1,12(A6)
                    14820   ; *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
08004818  206E 0008 14821          move.l    8(A6),A0
0800481C  54AE 0008 14822          addq.l    #2,8(A6)
08004820  4250      14823          clr.w     (A0)
08004822  60E4      14824          bra       OS_TaskStkClr_5
                    14825   OS_TaskStkClr_7:
08004824  4E5E      14826          unlk      A6
08004826  4E75      14827          rts
                    14828   ; /*
                    14829   ; *********************************************************************************************************
                    14830   ; *                                                uC/OS-II
                    14831   ; *                                          The Real-Time Kernel
                    14832   ; *                                             TIME MANAGEMENT
                    14833   ; *
                    14834   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    14835   ; *                                           All Rights Reserved
                    14836   ; *
                    14837   ; * File    : OS_TIME.C
                    14838   ; * By      : Jean J. Labrosse
                    14839   ; * Version : V2.92.07
                    14840   ; *
                    14841   ; * LICENSING TERMS:
                    14842   ; * ---------------
                    14843   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    14844   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    14845   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    14846   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    14847   ; * licensing fee.
                    14848   ; *********************************************************************************************************
                    14849   ; */
                    14850   ; #define  MICRIUM_SOURCE
                    14851   ; #ifndef  OS_MASTER_FILE
                    14852   ; #include <ucos_ii.h>
                    14853   ; #endif
                    14854   ; /*
                    14855   ; *********************************************************************************************************
                    14856   ; *                                        DELAY TASK 'n' TICKS
                    14857   ; *
                    14858   ; * Description: This function is called to delay execution of the currently running task until the
                    14859   ; *              specified number of system ticks expires.  This, of course, directly equates to delaying
                    14860   ; *              the current task for some time to expire.  No delay will result If the specified delay is
                    14861   ; *              0.  If the specified delay is greater than 0 then, a context switch will result.
                    14862   ; *
                    14863   ; * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
                    14864   ; *                        Note that by specifying 0, the task will not be delayed.
                    14865   ; *
                    14866   ; * Returns    : none
                    14867   ; *********************************************************************************************************
                    14868   ; */
                    14869   ; void  OSTimeDly (INT32U ticks)
                    14870   ; {
                    14871   _OSTimeDly:
08004828  4E56 0000 14872          link      A6,#0
0800482C  48E7 2020 14873          movem.l   D2/A2,-(A7)
08004830  45F9 0800 14874          lea       _OSTCBCur.L,A2
08004834  042C      
                    14875   ; INT8U      y;
                    14876   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14877   ; OS_CPU_SR  cpu_sr = 0u;
                    14878   ; #endif
                    14879   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
08004836  1039 0800 14880          move.b    _OSIntNesting.L,D0
0800483A  0312      
0800483C  0C00 0000 14881          cmp.b     #0,D0
08004840  6304      14882          bls.s     OSTimeDly_1
                    14883   ; return;
08004842  6000 0074 14884          bra       OSTimeDly_6
                    14885   OSTimeDly_1:
                    14886   ; }
                    14887   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
08004846  1039 0800 14888          move.b    _OSLockNesting.L,D0
0800484A  0314      
0800484C  0C00 0000 14889          cmp.b     #0,D0
08004850  6304      14890          bls.s     OSTimeDly_4
                    14891   ; return;
08004852  6000 0064 14892          bra       OSTimeDly_6
                    14893   OSTimeDly_4:
                    14894   ; }
                    14895   ; if (ticks > 0u) {                            /* 0 means no delay!                                  */
08004856  202E 0008 14896          move.l    8(A6),D0
0800485A  0C80 0000 14897          cmp.l     #0,D0
0800485E  0000      
08004860  6300 0056 14898          bls       OSTimeDly_6
                    14899   ; OS_ENTER_CRITICAL();
08004864  40E7      14900          dc.w      16615
08004866  007C      14901          dc.w      124
08004868  0700      14902          dc.w      1792
                    14903   ; y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
0800486A  2052      14904          move.l    (A2),A0
0800486C  1428 0036 14905          move.b    54(A0),D2
                    14906   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
08004870  C4BC 0000 14907          and.l     #255,D2
08004874  00FF      
08004876  41F9 0800 14908          lea       _OSRdyTbl.L,A0
0800487A  031C      
0800487C  2252      14909          move.l    (A2),A1
0800487E  1029 0037 14910          move.b    55(A1),D0
08004882  4600      14911          not.b     D0
08004884  C130 2800 14912          and.b     D0,0(A0,D2.L)
                    14913   ; if (OSRdyTbl[y] == 0u) {
08004888  C4BC 0000 14914          and.l     #255,D2
0800488C  00FF      
0800488E  41F9 0800 14915          lea       _OSRdyTbl.L,A0
08004892  031C      
08004894  1030 2800 14916          move.b    0(A0,D2.L),D0
08004898  660E      14917          bne.s     OSTimeDly_8
                    14918   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0800489A  2052      14919          move.l    (A2),A0
0800489C  1028 0038 14920          move.b    56(A0),D0
080048A0  4600      14921          not.b     D0
080048A2  C139 0800 14922          and.b     D0,_OSRdyGrp.L
080048A6  031A      
                    14923   OSTimeDly_8:
                    14924   ; }
                    14925   ; OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
080048A8  2052      14926          move.l    (A2),A0
080048AA  216E 0008 14927          move.l    8(A6),46(A0)
080048AE  002E      
                    14928   ; OS_EXIT_CRITICAL();
080048B0  46DF      14929          dc.w      18143
                    14930   ; OS_Sched();                              /* Find next task to run!                             */
080048B2  4EB9 0800 14931          jsr       _OS_Sched
080048B6  0F8A      
                    14932   OSTimeDly_6:
080048B8  4CDF 0404 14933          movem.l   (A7)+,D2/A2
080048BC  4E5E      14934          unlk      A6
080048BE  4E75      14935          rts
                    14936   ; }
                    14937   ; }
                    14938   ; /*$PAGE*/
                    14939   ; /*
                    14940   ; *********************************************************************************************************
                    14941   ; *                                    DELAY TASK FOR SPECIFIED TIME
                    14942   ; *
                    14943   ; * Description: This function is called to delay execution of the currently running task until some time
                    14944   ; *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
                    14945   ; *              MILLISECONDS instead of ticks.
                    14946   ; *
                    14947   ; * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
                    14948   ; *              minutes   specifies the number of minutes (max. 59)
                    14949   ; *              seconds   specifies the number of seconds (max. 59)
                    14950   ; *              ms        specifies the number of milliseconds (max. 999)
                    14951   ; *
                    14952   ; * Returns    : OS_ERR_NONE
                    14953   ; *              OS_ERR_TIME_INVALID_MINUTES
                    14954   ; *              OS_ERR_TIME_INVALID_SECONDS
                    14955   ; *              OS_ERR_TIME_INVALID_MS
                    14956   ; *              OS_ERR_TIME_ZERO_DLY
                    14957   ; *              OS_ERR_TIME_DLY_ISR
                    14958   ; *
                    14959   ; * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
                    14960   ; *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
                    14961   ; *              set to 0.  The actual delay is rounded to the nearest tick.
                    14962   ; *********************************************************************************************************
                    14963   ; */
                    14964   ; #if OS_TIME_DLY_HMSM_EN > 0u
                    14965   ; INT8U  OSTimeDlyHMSM (INT8U   hours,
                    14966   ; INT8U   minutes,
                    14967   ; INT8U   seconds,
                    14968   ; INT16U  ms)
                    14969   ; {
                    14970   _OSTimeDlyHMSM:
080048C0  4E56 FFFC 14971          link      A6,#-4
                    14972   ; INT32U ticks;
                    14973   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
080048C4  1039 0800 14974          move.b    _OSIntNesting.L,D0
080048C8  0312      
080048CA  0C00 0000 14975          cmp.b     #0,D0
080048CE  6306      14976          bls.s     OSTimeDlyHMSM_1
                    14977   ; return (OS_ERR_TIME_DLY_ISR);
080048D0  7055      14978          moveq     #85,D0
080048D2  6000 00A6 14979          bra       OSTimeDlyHMSM_3
                    14980   OSTimeDlyHMSM_1:
                    14981   ; }
                    14982   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
080048D6  1039 0800 14983          move.b    _OSLockNesting.L,D0
080048DA  0314      
080048DC  0C00 0000 14984          cmp.b     #0,D0
080048E0  6306      14985          bls.s     OSTimeDlyHMSM_4
                    14986   ; return (OS_ERR_SCHED_LOCKED);
080048E2  7032      14987          moveq     #50,D0
080048E4  6000 0094 14988          bra       OSTimeDlyHMSM_3
                    14989   OSTimeDlyHMSM_4:
                    14990   ; }
                    14991   ; #if OS_ARG_CHK_EN > 0u
                    14992   ; if (hours == 0u) {
                    14993   ; if (minutes == 0u) {
                    14994   ; if (seconds == 0u) {
                    14995   ; if (ms == 0u) {
                    14996   ; return (OS_ERR_TIME_ZERO_DLY);
                    14997   ; }
                    14998   ; }
                    14999   ; }
                    15000   ; }
                    15001   ; if (minutes > 59u) {
                    15002   ; return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
                    15003   ; }
                    15004   ; if (seconds > 59u) {
                    15005   ; return (OS_ERR_TIME_INVALID_SECONDS);
                    15006   ; }
                    15007   ; if (ms > 999u) {
                    15008   ; return (OS_ERR_TIME_INVALID_MS);
                    15009   ; }
                    15010   ; #endif
                    15011   ; /* Compute the total number of clock ticks required.. */
                    15012   ; /* .. (rounded to the nearest tick)                   */
                    15013   ; ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
080048E8  102E 000B 15014          move.b    11(A6),D0
080048EC  C0BC 0000 15015          and.l     #255,D0
080048F0  00FF      
080048F2  2F00      15016          move.l    D0,-(A7)
080048F4  4878 0E10 15017          pea       3600
080048F8  4EB9 0800 15018          jsr       ULMUL
080048FC  5680      
080048FE  2017      15019          move.l    (A7),D0
08004900  504F      15020          addq.w    #8,A7
08004902  122E 000F 15021          move.b    15(A6),D1
08004906  C2BC 0000 15022          and.l     #255,D1
0800490A  00FF      
0800490C  2F01      15023          move.l    D1,-(A7)
0800490E  4878 003C 15024          pea       60
08004912  4EB9 0800 15025          jsr       ULMUL
08004916  5680      
08004918  2217      15026          move.l    (A7),D1
0800491A  504F      15027          addq.w    #8,A7
0800491C  D081      15028          add.l     D1,D0
0800491E  122E 0013 15029          move.b    19(A6),D1
08004922  C2BC 0000 15030          and.l     #255,D1
08004926  00FF      
08004928  D081      15031          add.l     D1,D0
0800492A  2F00      15032          move.l    D0,-(A7)
0800492C  4878 0064 15033          pea       100
08004930  4EB9 0800 15034          jsr       ULMUL
08004934  5680      
08004936  2017      15035          move.l    (A7),D0
08004938  504F      15036          addq.w    #8,A7
0800493A  322E 0016 15037          move.w    22(A6),D1
0800493E  C2BC 0000 15038          and.l     #65535,D1
08004942  FFFF      
08004944  5A81      15039          addq.l    #5,D1
08004946  2F01      15040          move.l    D1,-(A7)
08004948  4878 0064 15041          pea       100
0800494C  4EB9 0800 15042          jsr       ULMUL
08004950  5680      
08004952  2217      15043          move.l    (A7),D1
08004954  504F      15044          addq.w    #8,A7
08004956  2F01      15045          move.l    D1,-(A7)
08004958  4878 03E8 15046          pea       1000
0800495C  4EB9 0800 15047          jsr       ULDIV
08004960  5720      
08004962  2217      15048          move.l    (A7),D1
08004964  504F      15049          addq.w    #8,A7
08004966  D081      15050          add.l     D1,D0
08004968  2D40 FFFC 15051          move.l    D0,-4(A6)
                    15052   ; + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
                    15053   ; OSTimeDly(ticks);
0800496C  2F2E FFFC 15054          move.l    -4(A6),-(A7)
08004970  4EB9 0800 15055          jsr       _OSTimeDly
08004974  4828      
08004976  584F      15056          addq.w    #4,A7
                    15057   ; return (OS_ERR_NONE);
08004978  4200      15058          clr.b     D0
                    15059   OSTimeDlyHMSM_3:
0800497A  4E5E      15060          unlk      A6
0800497C  4E75      15061          rts
                    15062   ; }
                    15063   ; #endif
                    15064   ; /*$PAGE*/
                    15065   ; /*
                    15066   ; *********************************************************************************************************
                    15067   ; *                                        RESUME A DELAYED TASK
                    15068   ; *
                    15069   ; * Description: This function is used resume a task that has been delayed through a call to either
                    15070   ; *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
                    15071   ; *              task that is waiting for an event with timeout.  This would make the task look
                    15072   ; *              like a timeout occurred.
                    15073   ; *
                    15074   ; * Arguments  : prio                      specifies the priority of the task to resume
                    15075   ; *
                    15076   ; * Returns    : OS_ERR_NONE               Task has been resumed
                    15077   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    15078   ; *                                        (i.e. >= OS_LOWEST_PRIO)
                    15079   ; *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
                    15080   ; *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
                    15081   ; *********************************************************************************************************
                    15082   ; */
                    15083   ; #if OS_TIME_DLY_RESUME_EN > 0u
                    15084   ; INT8U  OSTimeDlyResume (INT8U prio)
                    15085   ; {
                    15086   _OSTimeDlyResume:
0800497E  4E56 0000 15087          link      A6,#0
08004982  2F02      15088          move.l    D2,-(A7)
                    15089   ; OS_TCB    *ptcb;
                    15090   ; #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
                    15091   ; OS_CPU_SR  cpu_sr = 0u;
                    15092   ; #endif
                    15093   ; if (prio >= OS_LOWEST_PRIO) {
08004984  102E 000B 15094          move.b    11(A6),D0
08004988  0C00 003F 15095          cmp.b     #63,D0
0800498C  6506      15096          blo.s     OSTimeDlyResume_1
                    15097   ; return (OS_ERR_PRIO_INVALID);
0800498E  702A      15098          moveq     #42,D0
08004990  6000 00B6 15099          bra       OSTimeDlyResume_3
                    15100   OSTimeDlyResume_1:
                    15101   ; }
                    15102   ; OS_ENTER_CRITICAL();
08004994  40E7      15103          dc.w      16615
08004996  007C      15104          dc.w      124
08004998  0700      15105          dc.w      1792
                    15106   ; ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
0800499A  102E 000B 15107          move.b    11(A6),D0
0800499E  C0BC 0000 15108          and.l     #255,D0
080049A2  00FF      
080049A4  E588      15109          lsl.l     #2,D0
080049A6  41F9 0800 15110          lea       _OSTCBPrioTbl.L,A0
080049AA  043C      
080049AC  2430 0800 15111          move.l    0(A0,D0.L),D2
                    15112   ; if (ptcb == (OS_TCB *)0) {
080049B0  4A82      15113          tst.l     D2
080049B2  6608      15114          bne.s     OSTimeDlyResume_4
                    15115   ; OS_EXIT_CRITICAL();
080049B4  46DF      15116          dc.w      18143
                    15117   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
080049B6  7043      15118          moveq     #67,D0
080049B8  6000 008E 15119          bra       OSTimeDlyResume_3
                    15120   OSTimeDlyResume_4:
                    15121   ; }
                    15122   ; if (ptcb == OS_TCB_RESERVED) {
080049BC  0C82 0000 15123          cmp.l     #1,D2
080049C0  0001      
080049C2  6608      15124          bne.s     OSTimeDlyResume_6
                    15125   ; OS_EXIT_CRITICAL();
080049C4  46DF      15126          dc.w      18143
                    15127   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
080049C6  7043      15128          moveq     #67,D0
080049C8  6000 007E 15129          bra       OSTimeDlyResume_3
                    15130   OSTimeDlyResume_6:
                    15131   ; }
                    15132   ; if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
080049CC  2042      15133          move.l    D2,A0
080049CE  2028 002E 15134          move.l    46(A0),D0
080049D2  6608      15135          bne.s     OSTimeDlyResume_8
                    15136   ; OS_EXIT_CRITICAL();
080049D4  46DF      15137          dc.w      18143
                    15138   ; return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
080049D6  7050      15139          moveq     #80,D0
080049D8  6000 006E 15140          bra       OSTimeDlyResume_3
                    15141   OSTimeDlyResume_8:
                    15142   ; }
                    15143   ; ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
080049DC  2042      15144          move.l    D2,A0
080049DE  42A8 002E 15145          clr.l     46(A0)
                    15146   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
080049E2  2042      15147          move.l    D2,A0
080049E4  1028 0032 15148          move.b    50(A0),D0
080049E8  C03C 0037 15149          and.b     #55,D0
080049EC  6712      15150          beq.s     OSTimeDlyResume_10
                    15151   ; ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
080049EE  2042      15152          move.l    D2,A0
080049F0  0228 00C8 15153          and.b     #-56,50(A0)
080049F4  0032      
                    15154   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
080049F6  2042      15155          move.l    D2,A0
080049F8  117C 0001 15156          move.b    #1,51(A0)
080049FC  0033      
080049FE  6006      15157          bra.s     OSTimeDlyResume_11
                    15158   OSTimeDlyResume_10:
                    15159   ; } else {
                    15160   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
08004A00  2042      15161          move.l    D2,A0
08004A02  4228 0033 15162          clr.b     51(A0)
                    15163   OSTimeDlyResume_11:
                    15164   ; }
                    15165   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
08004A06  2042      15166          move.l    D2,A0
08004A08  1028 0032 15167          move.b    50(A0),D0
08004A0C  C03C 0008 15168          and.b     #8,D0
08004A10  6632      15169          bne.s     OSTimeDlyResume_12
                    15170   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
08004A12  2042      15171          move.l    D2,A0
08004A14  1028 0038 15172          move.b    56(A0),D0
08004A18  8139 0800 15173          or.b      D0,_OSRdyGrp.L
08004A1C  031A      
                    15174   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
08004A1E  2042      15175          move.l    D2,A0
08004A20  1028 0036 15176          move.b    54(A0),D0
08004A24  C0BC 0000 15177          and.l     #255,D0
08004A28  00FF      
08004A2A  41F9 0800 15178          lea       _OSRdyTbl.L,A0
08004A2E  031C      
08004A30  2242      15179          move.l    D2,A1
08004A32  1229 0037 15180          move.b    55(A1),D1
08004A36  8330 0800 15181          or.b      D1,0(A0,D0.L)
                    15182   ; OS_EXIT_CRITICAL();
08004A3A  46DF      15183          dc.w      18143
                    15184   ; OS_Sched();                                            /* See if this is new highest priority  */
08004A3C  4EB9 0800 15185          jsr       _OS_Sched
08004A40  0F8A      
08004A42  6002      15186          bra.s     OSTimeDlyResume_13
                    15187   OSTimeDlyResume_12:
                    15188   ; } else {
                    15189   ; OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
08004A44  46DF      15190          dc.w      18143
                    15191   OSTimeDlyResume_13:
                    15192   ; }
                    15193   ; return (OS_ERR_NONE);
08004A46  4200      15194          clr.b     D0
                    15195   OSTimeDlyResume_3:
08004A48  241F      15196          move.l    (A7)+,D2
08004A4A  4E5E      15197          unlk      A6
08004A4C  4E75      15198          rts
                    15199   ; }
                    15200   ; #endif
                    15201   ; /*$PAGE*/
                    15202   ; /*
                    15203   ; *********************************************************************************************************
                    15204   ; *                                       GET CURRENT SYSTEM TIME
                    15205   ; *
                    15206   ; * Description: This function is used by your application to obtain the current value of the 32-bit
                    15207   ; *              counter which keeps track of the number of clock ticks.
                    15208   ; *
                    15209   ; * Arguments  : none
                    15210   ; *
                    15211   ; * Returns    : The current value of OSTime
                    15212   ; *********************************************************************************************************
                    15213   ; */
                    15214   ; #if OS_TIME_GET_SET_EN > 0u
                    15215   ; INT32U  OSTimeGet (void)
                    15216   ; {
                    15217   _OSTimeGet:
08004A4E  4E56 FFFC 15218          link      A6,#-4
                    15219   ; INT32U     ticks;
                    15220   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15221   ; OS_CPU_SR  cpu_sr = 0u;
                    15222   ; #endif
                    15223   ; OS_ENTER_CRITICAL();
08004A52  40E7      15224          dc.w      16615
08004A54  007C      15225          dc.w      124
08004A56  0700      15226          dc.w      1792
                    15227   ; ticks = OSTime;
08004A58  2D79 0800 15228          move.l    _OSTime.L,-4(A6)
08004A5C  0D82 FFFC 
                    15229   ; OS_EXIT_CRITICAL();
08004A60  46DF      15230          dc.w      18143
                    15231   ; return (ticks);
08004A62  202E FFFC 15232          move.l    -4(A6),D0
08004A66  4E5E      15233          unlk      A6
08004A68  4E75      15234          rts
                    15235   ; }
                    15236   ; #endif
                    15237   ; /*
                    15238   ; *********************************************************************************************************
                    15239   ; *                                          SET SYSTEM CLOCK
                    15240   ; *
                    15241   ; * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
                    15242   ; *
                    15243   ; * Arguments  : ticks      specifies the new value that OSTime needs to take.
                    15244   ; *
                    15245   ; * Returns    : none
                    15246   ; *********************************************************************************************************
                    15247   ; */
                    15248   ; #if OS_TIME_GET_SET_EN > 0u
                    15249   ; void  OSTimeSet (INT32U ticks)
                    15250   ; {
                    15251   _OSTimeSet:
08004A6A  4E56 0000 15252          link      A6,#0
                    15253   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15254   ; OS_CPU_SR  cpu_sr = 0u;
                    15255   ; #endif
                    15256   ; OS_ENTER_CRITICAL();
08004A6E  40E7      15257          dc.w      16615
08004A70  007C      15258          dc.w      124
08004A72  0700      15259          dc.w      1792
                    15260   ; OSTime = ticks;
08004A74  23EE 0008 15261          move.l    8(A6),_OSTime.L
08004A78  0800 0D82 
                    15262   ; OS_EXIT_CRITICAL();
08004A7C  46DF      15263          dc.w      18143
08004A7E  4E5E      15264          unlk      A6
08004A80  4E75      15265          rts
                    15266   ; /*
                    15267   ; *********************************************************************************************************
                    15268   ; *                                                uC/OS-II
                    15269   ; *                                          The Real-Time Kernel
                    15270   ; *                                            TIMER MANAGEMENT
                    15271   ; *
                    15272   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15273   ; *                                           All Rights Reserved
                    15274   ; *
                    15275   ; *
                    15276   ; * File    : OS_TMR.C
                    15277   ; * By      : Jean J. Labrosse
                    15278   ; * Version : V2.92.07
                    15279   ; *
                    15280   ; * LICENSING TERMS:
                    15281   ; * ---------------
                    15282   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15283   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15284   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15285   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15286   ; * licensing fee.
                    15287   ; *********************************************************************************************************
                    15288   ; */
                    15289   ; #define  MICRIUM_SOURCE
                    15290   ; #ifndef  OS_MASTER_FILE
                    15291   ; #include <ucos_ii.h>
                    15292   ; #endif
                    15293   ; /*
                    15294   ; *********************************************************************************************************
                    15295   ; *                                                        NOTES
                    15296   ; *
                    15297   ; * 1) Your application MUST define the following #define constants:
                    15298   ; *
                    15299   ; *    OS_TASK_TMR_PRIO          The priority of the Timer management task
                    15300   ; *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
                    15301   ; *
                    15302   ; * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
                    15303   ; *********************************************************************************************************
                    15304   ; */
                    15305   ; /*
                    15306   ; *********************************************************************************************************
                    15307   ; *                                              CONSTANTS
                    15308   ; *********************************************************************************************************
                    15309   ; */
                    15310   ; #define  OS_TMR_LINK_DLY       0u
                    15311   ; #define  OS_TMR_LINK_PERIODIC  1u
                    15312   ; /*
                    15313   ; *********************************************************************************************************
                    15314   ; *                                          LOCAL PROTOTYPES
                    15315   ; *********************************************************************************************************
                    15316   ; */
                    15317   ; #if OS_TMR_EN > 0u
                    15318   ; static  OS_TMR  *OSTmr_Alloc         (void);
                    15319   ; static  void     OSTmr_Free          (OS_TMR *ptmr);
                    15320   ; static  void     OSTmr_InitTask      (void);
                    15321   ; static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
                    15322   ; static  void     OSTmr_Unlink        (OS_TMR *ptmr);
                    15323   ; static  void     OSTmr_Task          (void   *p_arg);
                    15324   ; #endif
                    15325   ; /*$PAGE*/
                    15326   ; /*
                    15327   ; *********************************************************************************************************
                    15328   ; *                                           CREATE A TIMER
                    15329   ; *
                    15330   ; * Description: This function is called by your application code to create a timer.
                    15331   ; *
                    15332   ; * Arguments  : dly           Initial delay.
                    15333   ; *                            If the timer is configured for ONE-SHOT mode, this is the timeout used.
                    15334   ; *                            If the timer is configured for PERIODIC mode, this is the first timeout to 
                    15335   ; *                               wait for before the timer starts entering periodic mode.
                    15336   ; *
                    15337   ; *              period        The 'period' being repeated for the timer.
                    15338   ; *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer 
                    15339   ; *                               expires, it will automatically restart with the same period.
                    15340   ; *
                    15341   ; *              opt           Specifies either:
                    15342   ; *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
                    15343   ; *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
                    15344   ; *
                    15345   ; *              callback      Is a pointer to a callback function that will be called when the timer expires. 
                    15346   ; *                               The callback function must be declared as follows:
                    15347   ; *
                    15348   ; *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
                    15349   ; *
                    15350   ; *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
                    15351   ; *
                    15352   ; *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are 
                    15353   ; *                               useful for debugging.
                    15354   ; *
                    15355   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15356   ; *                               OS_ERR_NONE
                    15357   ; *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
                    15358   ; *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
                    15359   ; *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
                    15360   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    15361   ; *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
                    15362   ; *
                    15363   ; * Returns    : A pointer to an OS_TMR data structure.
                    15364   ; *              This is the 'handle' that your application will use to reference the timer created.
                    15365   ; *********************************************************************************************************
                    15366   ; */
                    15367   ; #if OS_TMR_EN > 0u
                    15368   ; OS_TMR  *OSTmrCreate (INT32U           dly,
                    15369   ; INT32U           period,
                    15370   ; INT8U            opt,
                    15371   ; OS_TMR_CALLBACK  callback,
                    15372   ; void            *callback_arg,
                    15373   ; INT8U           *pname,
                    15374   ; INT8U           *perr)
                    15375   ; {
                    15376   _OSTmrCreate:
08004A82  4E56 0000 15377          link      A6,#0
08004A86  48E7 3000 15378          movem.l   D2/D3,-(A7)
08004A8A  262E 0020 15379          move.l    32(A6),D3
                    15380   ; OS_TMR   *ptmr;
                    15381   ; #ifdef OS_SAFETY_CRITICAL
                    15382   ; if (perr == (INT8U *)0) {
                    15383   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15384   ; return ((OS_TMR *)0);
                    15385   ; }
                    15386   ; #endif
                    15387   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    15388   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    15389   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15390   ; return ((OS_TMR *)0);
                    15391   ; }
                    15392   ; #endif
                    15393   ; #if OS_ARG_CHK_EN > 0u
                    15394   ; switch (opt) {                                          /* Validate arguments                                     */
                    15395   ; case OS_TMR_OPT_PERIODIC:
                    15396   ; if (period == 0u) {
                    15397   ; *perr = OS_ERR_TMR_INVALID_PERIOD;
                    15398   ; return ((OS_TMR *)0);
                    15399   ; }
                    15400   ; break;
                    15401   ; case OS_TMR_OPT_ONE_SHOT:
                    15402   ; if (dly == 0u) {
                    15403   ; *perr = OS_ERR_TMR_INVALID_DLY;
                    15404   ; return ((OS_TMR *)0);
                    15405   ; }
                    15406   ; break;
                    15407   ; default:
                    15408   ; *perr = OS_ERR_TMR_INVALID_OPT;
                    15409   ; return ((OS_TMR *)0);
                    15410   ; }
                    15411   ; #endif
                    15412   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
08004A8E  1039 0800 15413          move.b    _OSIntNesting.L,D0
08004A92  0312      
08004A94  0C00 0000 15414          cmp.b     #0,D0
08004A98  630C      15415          bls.s     OSTmrCreate_1
                    15416   ; *perr  = OS_ERR_TMR_ISR;
08004A9A  2043      15417          move.l    D3,A0
08004A9C  10BC 008B 15418          move.b    #139,(A0)
                    15419   ; return ((OS_TMR *)0);
08004AA0  4280      15420          clr.l     D0
08004AA2  6000 007E 15421          bra       OSTmrCreate_3
                    15422   OSTmrCreate_1:
                    15423   ; }
                    15424   ; OSSchedLock();
08004AA6  4EB9 0800 15425          jsr       _OSSchedLock
08004AAA  07D6      
                    15426   ; ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
08004AAC  4EB9 0800 15427          jsr       @ucos_ii_OSTmr_Alloc
08004AB0  503C      
08004AB2  2400      15428          move.l    D0,D2
                    15429   ; if (ptmr == (OS_TMR *)0) {
08004AB4  4A82      15430          tst.l     D2
08004AB6  6612      15431          bne.s     OSTmrCreate_4
                    15432   ; OSSchedUnlock();
08004AB8  4EB9 0800 15433          jsr       _OSSchedUnlock
08004ABC  0806      
                    15434   ; *perr = OS_ERR_TMR_NON_AVAIL;
08004ABE  2043      15435          move.l    D3,A0
08004AC0  10BC 0086 15436          move.b    #134,(A0)
                    15437   ; return ((OS_TMR *)0);
08004AC4  4280      15438          clr.l     D0
08004AC6  6000 005A 15439          bra       OSTmrCreate_3
                    15440   OSTmrCreate_4:
                    15441   ; }
                    15442   ; ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
08004ACA  2042      15443          move.l    D2,A0
08004ACC  117C 0001 15444          move.b    #1,35(A0)
08004AD0  0023      
                    15445   ; ptmr->OSTmrDly         = dly;
08004AD2  2042      15446          move.l    D2,A0
08004AD4  216E 0008 15447          move.l    8(A6),22(A0)
08004AD8  0016      
                    15448   ; ptmr->OSTmrPeriod      = period;
08004ADA  2042      15449          move.l    D2,A0
08004ADC  216E 000C 15450          move.l    12(A6),26(A0)
08004AE0  001A      
                    15451   ; ptmr->OSTmrOpt         = opt;
08004AE2  2042      15452          move.l    D2,A0
08004AE4  116E 0013 15453          move.b    19(A6),34(A0)
08004AE8  0022      
                    15454   ; ptmr->OSTmrCallback    = callback;
08004AEA  2042      15455          move.l    D2,A0
08004AEC  216E 0014 15456          move.l    20(A6),2(A0)
08004AF0  0002      
                    15457   ; ptmr->OSTmrCallbackArg = callback_arg;
08004AF2  2042      15458          move.l    D2,A0
08004AF4  216E 0018 15459          move.l    24(A6),6(A0)
08004AF8  0006      
                    15460   ; #if OS_TMR_CFG_NAME_EN > 0u
                    15461   ; if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
08004AFA  202E 001C 15462          move.l    28(A6),D0
08004AFE  660E      15463          bne.s     OSTmrCreate_6
                    15464   ; ptmr->OSTmrName    = (INT8U *)(void *)"?";
08004B00  41F9 0800 15465          lea       @ucos_ii_1.L,A0
08004B04  57FE      
08004B06  2242      15466          move.l    D2,A1
08004B08  2348 001E 15467          move.l    A0,30(A1)
08004B0C  6008      15468          bra.s     OSTmrCreate_7
                    15469   OSTmrCreate_6:
                    15470   ; } else {
                    15471   ; ptmr->OSTmrName    = pname;
08004B0E  2042      15472          move.l    D2,A0
08004B10  216E 001C 15473          move.l    28(A6),30(A0)
08004B14  001E      
                    15474   OSTmrCreate_7:
                    15475   ; }
                    15476   ; #endif
                    15477   ; OSSchedUnlock();
08004B16  4EB9 0800 15478          jsr       _OSSchedUnlock
08004B1A  0806      
                    15479   ; *perr = OS_ERR_NONE;
08004B1C  2043      15480          move.l    D3,A0
08004B1E  4210      15481          clr.b     (A0)
                    15482   ; return (ptmr);
08004B20  2002      15483          move.l    D2,D0
                    15484   OSTmrCreate_3:
08004B22  4CDF 000C 15485          movem.l   (A7)+,D2/D3
08004B26  4E5E      15486          unlk      A6
08004B28  4E75      15487          rts
                    15488   ; }
                    15489   ; #endif
                    15490   ; /*$PAGE*/
                    15491   ; /*
                    15492   ; *********************************************************************************************************
                    15493   ; *                                           DELETE A TIMER
                    15494   ; *
                    15495   ; * Description: This function is called by your application code to delete a timer.
                    15496   ; *
                    15497   ; * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
                    15498   ; *
                    15499   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15500   ; *                               OS_ERR_NONE
                    15501   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15502   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15503   ; *                               OS_ERR_TMR_ISR            if the function was called from an ISR
                    15504   ; *                               OS_ERR_TMR_INACTIVE       if the timer was not created
                    15505   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15506   ; *
                    15507   ; * Returns    : OS_TRUE       If the call was successful
                    15508   ; *              OS_FALSE      If not
                    15509   ; *********************************************************************************************************
                    15510   ; */
                    15511   ; #if OS_TMR_EN > 0u
                    15512   ; BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                    15513   ; INT8U   *perr)
                    15514   ; {
                    15515   _OSTmrDel:
08004B2A  4E56 0000 15516          link      A6,#0
08004B2E  48E7 3020 15517          movem.l   D2/D3/A2,-(A7)
08004B32  242E 000C 15518          move.l    12(A6),D2
08004B36  262E 0008 15519          move.l    8(A6),D3
08004B3A  45F9 0800 15520          lea       _OSSchedUnlock.L,A2
08004B3E  0806      
                    15521   ; #ifdef OS_SAFETY_CRITICAL
                    15522   ; if (perr == (INT8U *)0) {
                    15523   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15524   ; return (OS_FALSE);
                    15525   ; }
                    15526   ; #endif
                    15527   ; #if OS_ARG_CHK_EN > 0u
                    15528   ; if (ptmr == (OS_TMR *)0) {
                    15529   ; *perr = OS_ERR_TMR_INVALID;
                    15530   ; return (OS_FALSE);
                    15531   ; }
                    15532   ; #endif
                    15533   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
08004B40  2043      15534          move.l    D3,A0
08004B42  1010      15535          move.b    (A0),D0
08004B44  0C00 0064 15536          cmp.b     #100,D0
08004B48  670C      15537          beq.s     OSTmrDel_1
                    15538   ; *perr = OS_ERR_TMR_INVALID_TYPE;
08004B4A  2042      15539          move.l    D2,A0
08004B4C  10BC 0089 15540          move.b    #137,(A0)
                    15541   ; return (OS_FALSE);
08004B50  4200      15542          clr.b     D0
08004B52  6000 0092 15543          bra       OSTmrDel_3
                    15544   OSTmrDel_1:
                    15545   ; }
                    15546   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
08004B56  1039 0800 15547          move.b    _OSIntNesting.L,D0
08004B5A  0312      
08004B5C  0C00 0000 15548          cmp.b     #0,D0
08004B60  630C      15549          bls.s     OSTmrDel_4
                    15550   ; *perr  = OS_ERR_TMR_ISR;
08004B62  2042      15551          move.l    D2,A0
08004B64  10BC 008B 15552          move.b    #139,(A0)
                    15553   ; return (OS_FALSE);
08004B68  4200      15554          clr.b     D0
08004B6A  6000 007A 15555          bra       OSTmrDel_3
                    15556   OSTmrDel_4:
                    15557   ; }
                    15558   ; OSSchedLock();
08004B6E  4EB9 0800 15559          jsr       _OSSchedLock
08004B72  07D6      
                    15560   ; switch (ptmr->OSTmrState) {
08004B74  2043      15561          move.l    D3,A0
08004B76  1028 0023 15562          move.b    35(A0),D0
08004B7A  C0BC 0000 15563          and.l     #255,D0
08004B7E  00FF      
08004B80  0C80 0000 15564          cmp.l     #4,D0
08004B84  0004      
08004B86  6400 0054 15565          bhs       OSTmrDel_6
08004B8A  E380      15566          asl.l     #1,D0
08004B8C  303B 0806 15567          move.w    OSTmrDel_8(PC,D0.L),D0
08004B90  4EFB 0002 15568          jmp       OSTmrDel_8(PC,D0.W)
                    15569   OSTmrDel_8:
08004B94  003C      15570          dc.w      OSTmrDel_12-OSTmrDel_8
08004B96  0028      15571          dc.w      OSTmrDel_10-OSTmrDel_8
08004B98  0028      15572          dc.w      OSTmrDel_10-OSTmrDel_8
08004B9A  0008      15573          dc.w      OSTmrDel_9-OSTmrDel_8
                    15574   OSTmrDel_9:
                    15575   ; case OS_TMR_STATE_RUNNING:
                    15576   ; OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
08004B9C  2F03      15577          move.l    D3,-(A7)
08004B9E  4EB9 0800 15578          jsr       @ucos_ii_OSTmr_Unlink
08004BA2  5342      
08004BA4  584F      15579          addq.w    #4,A7
                    15580   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
08004BA6  2F03      15581          move.l    D3,-(A7)
08004BA8  4EB9 0800 15582          jsr       @ucos_ii_OSTmr_Free
08004BAC  5076      
08004BAE  584F      15583          addq.w    #4,A7
                    15584   ; OSSchedUnlock();
08004BB0  4E92      15585          jsr       (A2)
                    15586   ; *perr = OS_ERR_NONE;
08004BB2  2042      15587          move.l    D2,A0
08004BB4  4210      15588          clr.b     (A0)
                    15589   ; return (OS_TRUE);
08004BB6  7001      15590          moveq     #1,D0
08004BB8  6000 002C 15591          bra       OSTmrDel_3
                    15592   OSTmrDel_10:
                    15593   ; case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
                    15594   ; case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
                    15595   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
08004BBC  2F03      15596          move.l    D3,-(A7)
08004BBE  4EB9 0800 15597          jsr       @ucos_ii_OSTmr_Free
08004BC2  5076      
08004BC4  584F      15598          addq.w    #4,A7
                    15599   ; OSSchedUnlock();
08004BC6  4E92      15600          jsr       (A2)
                    15601   ; *perr = OS_ERR_NONE;
08004BC8  2042      15602          move.l    D2,A0
08004BCA  4210      15603          clr.b     (A0)
                    15604   ; return (OS_TRUE);
08004BCC  7001      15605          moveq     #1,D0
08004BCE  6016      15606          bra.s     OSTmrDel_3
                    15607   OSTmrDel_12:
                    15608   ; case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
                    15609   ; OSSchedUnlock();
08004BD0  4E92      15610          jsr       (A2)
                    15611   ; *perr = OS_ERR_TMR_INACTIVE;
08004BD2  2042      15612          move.l    D2,A0
08004BD4  10BC 0087 15613          move.b    #135,(A0)
                    15614   ; return (OS_FALSE);
08004BD8  4200      15615          clr.b     D0
08004BDA  600A      15616          bra.s     OSTmrDel_3
                    15617   OSTmrDel_6:
                    15618   ; default:
                    15619   ; OSSchedUnlock();
08004BDC  4E92      15620          jsr       (A2)
                    15621   ; *perr = OS_ERR_TMR_INVALID_STATE;
08004BDE  2042      15622          move.l    D2,A0
08004BE0  10BC 008D 15623          move.b    #141,(A0)
                    15624   ; return (OS_FALSE);
08004BE4  4200      15625          clr.b     D0
                    15626   OSTmrDel_3:
08004BE6  4CDF 040C 15627          movem.l   (A7)+,D2/D3/A2
08004BEA  4E5E      15628          unlk      A6
08004BEC  4E75      15629          rts
                    15630   ; }
                    15631   ; }
                    15632   ; #endif
                    15633   ; /*$PAGE*/
                    15634   ; /*
                    15635   ; *********************************************************************************************************
                    15636   ; *                                       GET THE NAME OF A TIMER
                    15637   ; *
                    15638   ; * Description: This function is called to obtain the name of a timer.
                    15639   ; *
                    15640   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
                    15641   ; *
                    15642   ; *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
                    15643   ; *
                    15644   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15645   ; *                               OS_ERR_NONE               The call was successful
                    15646   ; *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
                    15647   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15648   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15649   ; *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
                    15650   ; *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
                    15651   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15652   ; *
                    15653   ; * Returns    : The length of the string or 0 if the timer does not exist.
                    15654   ; *********************************************************************************************************
                    15655   ; */
                    15656   ; #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
                    15657   ; INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                    15658   ; INT8U   **pdest,
                    15659   ; INT8U    *perr)
                    15660   ; {
                    15661   _OSTmrNameGet:
08004BEE  4E56 FFFC 15662          link      A6,#-4
08004BF2  48E7 3020 15663          movem.l   D2/D3/A2,-(A7)
08004BF6  242E 0010 15664          move.l    16(A6),D2
08004BFA  45F9 0800 15665          lea       _OSSchedUnlock.L,A2
08004BFE  0806      
08004C00  262E 0008 15666          move.l    8(A6),D3
                    15667   ; INT8U  len;
                    15668   ; #ifdef OS_SAFETY_CRITICAL
                    15669   ; if (perr == (INT8U *)0) {
                    15670   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15671   ; return (0u);
                    15672   ; }
                    15673   ; #endif
                    15674   ; #if OS_ARG_CHK_EN > 0u
                    15675   ; if (pdest == (INT8U **)0) {
                    15676   ; *perr = OS_ERR_TMR_INVALID_DEST;
                    15677   ; return (0u);
                    15678   ; }
                    15679   ; if (ptmr == (OS_TMR *)0) {
                    15680   ; *perr = OS_ERR_TMR_INVALID;
                    15681   ; return (0u);
                    15682   ; }
                    15683   ; #endif
                    15684   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
08004C04  2043      15685          move.l    D3,A0
08004C06  1010      15686          move.b    (A0),D0
08004C08  0C00 0064 15687          cmp.b     #100,D0
08004C0C  670C      15688          beq.s     OSTmrNameGet_1
                    15689   ; *perr = OS_ERR_TMR_INVALID_TYPE;
08004C0E  2042      15690          move.l    D2,A0
08004C10  10BC 0089 15691          move.b    #137,(A0)
                    15692   ; return (0u);
08004C14  4200      15693          clr.b     D0
08004C16  6000 0086 15694          bra       OSTmrNameGet_3
                    15695   OSTmrNameGet_1:
                    15696   ; }
                    15697   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
08004C1A  1039 0800 15698          move.b    _OSIntNesting.L,D0
08004C1E  0312      
08004C20  0C00 0000 15699          cmp.b     #0,D0
08004C24  630C      15700          bls.s     OSTmrNameGet_4
                    15701   ; *perr = OS_ERR_NAME_GET_ISR;
08004C26  2042      15702          move.l    D2,A0
08004C28  10BC 0011 15703          move.b    #17,(A0)
                    15704   ; return (0u);
08004C2C  4200      15705          clr.b     D0
08004C2E  6000 006E 15706          bra       OSTmrNameGet_3
                    15707   OSTmrNameGet_4:
                    15708   ; }
                    15709   ; OSSchedLock();
08004C32  4EB9 0800 15710          jsr       _OSSchedLock
08004C36  07D6      
                    15711   ; switch (ptmr->OSTmrState) {
08004C38  2043      15712          move.l    D3,A0
08004C3A  1028 0023 15713          move.b    35(A0),D0
08004C3E  C0BC 0000 15714          and.l     #255,D0
08004C42  00FF      
08004C44  0C80 0000 15715          cmp.l     #4,D0
08004C48  0004      
08004C4A  6400 0048 15716          bhs       OSTmrNameGet_6
08004C4E  E380      15717          asl.l     #1,D0
08004C50  303B 0806 15718          move.w    OSTmrNameGet_8(PC,D0.L),D0
08004C54  4EFB 0002 15719          jmp       OSTmrNameGet_8(PC,D0.W)
                    15720   OSTmrNameGet_8:
08004C58  0030      15721          dc.w      OSTmrNameGet_12-OSTmrNameGet_8
08004C5A  0008      15722          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
08004C5C  0008      15723          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
08004C5E  0008      15724          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
                    15725   OSTmrNameGet_9:
                    15726   ; case OS_TMR_STATE_RUNNING:
                    15727   ; case OS_TMR_STATE_STOPPED:
                    15728   ; case OS_TMR_STATE_COMPLETED:
                    15729   ; *pdest = ptmr->OSTmrName;
08004C60  2043      15730          move.l    D3,A0
08004C62  226E 000C 15731          move.l    12(A6),A1
08004C66  22A8 001E 15732          move.l    30(A0),(A1)
                    15733   ; len    = OS_StrLen(*pdest);
08004C6A  206E 000C 15734          move.l    12(A6),A0
08004C6E  2F10      15735          move.l    (A0),-(A7)
08004C70  4EB9 0800 15736          jsr       _OS_StrLen
08004C74  1034      
08004C76  584F      15737          addq.w    #4,A7
08004C78  1D40 FFFF 15738          move.b    D0,-1(A6)
                    15739   ; OSSchedUnlock();
08004C7C  4E92      15740          jsr       (A2)
                    15741   ; *perr = OS_ERR_NONE;
08004C7E  2042      15742          move.l    D2,A0
08004C80  4210      15743          clr.b     (A0)
                    15744   ; return (len);
08004C82  102E FFFF 15745          move.b    -1(A6),D0
08004C86  6016      15746          bra.s     OSTmrNameGet_3
                    15747   OSTmrNameGet_12:
                    15748   ; case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
                    15749   ; OSSchedUnlock();
08004C88  4E92      15750          jsr       (A2)
                    15751   ; *perr = OS_ERR_TMR_INACTIVE;
08004C8A  2042      15752          move.l    D2,A0
08004C8C  10BC 0087 15753          move.b    #135,(A0)
                    15754   ; return (0u);
08004C90  4200      15755          clr.b     D0
08004C92  600A      15756          bra.s     OSTmrNameGet_3
                    15757   OSTmrNameGet_6:
                    15758   ; default:
                    15759   ; OSSchedUnlock();
08004C94  4E92      15760          jsr       (A2)
                    15761   ; *perr = OS_ERR_TMR_INVALID_STATE;
08004C96  2042      15762          move.l    D2,A0
08004C98  10BC 008D 15763          move.b    #141,(A0)
                    15764   ; return (0u);
08004C9C  4200      15765          clr.b     D0
                    15766   OSTmrNameGet_3:
08004C9E  4CDF 040C 15767          movem.l   (A7)+,D2/D3/A2
08004CA2  4E5E      15768          unlk      A6
08004CA4  4E75      15769          rts
                    15770   ; }
                    15771   ; }
                    15772   ; #endif
                    15773   ; /*$PAGE*/
                    15774   ; /*
                    15775   ; *********************************************************************************************************
                    15776   ; *                          GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
                    15777   ; *
                    15778   ; * Description: This function is called to get the number of ticks before a timer times out.
                    15779   ; *
                    15780   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
                    15781   ; *
                    15782   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15783   ; *                               OS_ERR_NONE
                    15784   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    15785   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15786   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    15787   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    15788   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15789   ; *
                    15790   ; * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments. 
                    15791   ; *              In other words, if OSTmr_Task() is signaled every 1/10 of a second then the returned 
                    15792   ; *              value represents the number of 1/10 of a second remaining before the timer expires.
                    15793   ; *********************************************************************************************************
                    15794   ; */
                    15795   ; #if OS_TMR_EN > 0u
                    15796   ; INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                    15797   ; INT8U   *perr)
                    15798   ; {
                    15799   _OSTmrRemainGet:
08004CA6  4E56 0000 15800          link      A6,#0
08004CAA  48E7 3820 15801          movem.l   D2/D3/D4/A2,-(A7)
08004CAE  242E 000C 15802          move.l    12(A6),D2
08004CB2  262E 0008 15803          move.l    8(A6),D3
08004CB6  45F9 0800 15804          lea       _OSSchedUnlock.L,A2
08004CBA  0806      
                    15805   ; INT32U  remain;
                    15806   ; #ifdef OS_SAFETY_CRITICAL
                    15807   ; if (perr == (INT8U *)0) {
                    15808   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15809   ; return (0u);
                    15810   ; }
                    15811   ; #endif
                    15812   ; #if OS_ARG_CHK_EN > 0u
                    15813   ; if (ptmr == (OS_TMR *)0) {
                    15814   ; *perr = OS_ERR_TMR_INVALID;
                    15815   ; return (0u);
                    15816   ; }
                    15817   ; #endif
                    15818   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
08004CBC  2043      15819          move.l    D3,A0
08004CBE  1010      15820          move.b    (A0),D0
08004CC0  0C00 0064 15821          cmp.b     #100,D0
08004CC4  670C      15822          beq.s     OSTmrRemainGet_1
                    15823   ; *perr = OS_ERR_TMR_INVALID_TYPE;
08004CC6  2042      15824          move.l    D2,A0
08004CC8  10BC 0089 15825          move.b    #137,(A0)
                    15826   ; return (0u);
08004CCC  4280      15827          clr.l     D0
08004CCE  6000 00D0 15828          bra       OSTmrRemainGet_3
                    15829   OSTmrRemainGet_1:
                    15830   ; }
                    15831   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
08004CD2  1039 0800 15832          move.b    _OSIntNesting.L,D0
08004CD6  0312      
08004CD8  0C00 0000 15833          cmp.b     #0,D0
08004CDC  630C      15834          bls.s     OSTmrRemainGet_4
                    15835   ; *perr = OS_ERR_TMR_ISR;
08004CDE  2042      15836          move.l    D2,A0
08004CE0  10BC 008B 15837          move.b    #139,(A0)
                    15838   ; return (0u);
08004CE4  4280      15839          clr.l     D0
08004CE6  6000 00B8 15840          bra       OSTmrRemainGet_3
                    15841   OSTmrRemainGet_4:
                    15842   ; }
                    15843   ; OSSchedLock();
08004CEA  4EB9 0800 15844          jsr       _OSSchedLock
08004CEE  07D6      
                    15845   ; switch (ptmr->OSTmrState) {
08004CF0  2043      15846          move.l    D3,A0
08004CF2  1028 0023 15847          move.b    35(A0),D0
08004CF6  C0BC 0000 15848          and.l     #255,D0
08004CFA  00FF      
08004CFC  0C80 0000 15849          cmp.l     #4,D0
08004D00  0004      
08004D02  6400 0092 15850          bhs       OSTmrRemainGet_6
08004D06  E380      15851          asl.l     #1,D0
08004D08  303B 0806 15852          move.w    OSTmrRemainGet_8(PC,D0.L),D0
08004D0C  4EFB 0002 15853          jmp       OSTmrRemainGet_8(PC,D0.W)
                    15854   OSTmrRemainGet_8:
08004D10  007A      15855          dc.w      OSTmrRemainGet_12-OSTmrRemainGet_8
08004D12  0022      15856          dc.w      OSTmrRemainGet_10-OSTmrRemainGet_8
08004D14  0070      15857          dc.w      OSTmrRemainGet_11-OSTmrRemainGet_8
08004D16  0008      15858          dc.w      OSTmrRemainGet_9-OSTmrRemainGet_8
                    15859   OSTmrRemainGet_9:
                    15860   ; case OS_TMR_STATE_RUNNING:
                    15861   ; remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
08004D18  2043      15862          move.l    D3,A0
08004D1A  2028 0012 15863          move.l    18(A0),D0
08004D1E  90B9 0800 15864          sub.l     _OSTmrTime.L,D0
08004D22  0D8A      
08004D24  2800      15865          move.l    D0,D4
                    15866   ; OSSchedUnlock();
08004D26  4E92      15867          jsr       (A2)
                    15868   ; *perr  = OS_ERR_NONE;
08004D28  2042      15869          move.l    D2,A0
08004D2A  4210      15870          clr.b     (A0)
                    15871   ; return (remain);
08004D2C  2004      15872          move.l    D4,D0
08004D2E  6000 0070 15873          bra       OSTmrRemainGet_3
                    15874   OSTmrRemainGet_10:
                    15875   ; case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
                    15876   ; switch (ptmr->OSTmrOpt) {
08004D32  2043      15877          move.l    D3,A0
08004D34  1028 0022 15878          move.b    34(A0),D0
08004D38  C0BC 0000 15879          and.l     #255,D0
08004D3C  00FF      
08004D3E  0C80 0000 15880          cmp.l     #2,D0
08004D42  0002      
08004D44  670C      15881          beq.s     OSTmrRemainGet_16
08004D46  6228      15882          bhi.s     OSTmrRemainGet_17
08004D48  0C80 0000 15883          cmp.l     #1,D0
08004D4C  0001      
08004D4E  6720      15884          beq.s     OSTmrRemainGet_17
08004D50  601E      15885          bra.s     OSTmrRemainGet_17
                    15886   OSTmrRemainGet_16:
                    15887   ; case OS_TMR_OPT_PERIODIC:
                    15888   ; if (ptmr->OSTmrDly == 0u) {
08004D52  2043      15889          move.l    D3,A0
08004D54  2028 0016 15890          move.l    22(A0),D0
08004D58  6608      15891          bne.s     OSTmrRemainGet_19
                    15892   ; remain = ptmr->OSTmrPeriod;
08004D5A  2043      15893          move.l    D3,A0
08004D5C  2828 001A 15894          move.l    26(A0),D4
08004D60  6006      15895          bra.s     OSTmrRemainGet_20
                    15896   OSTmrRemainGet_19:
                    15897   ; } else {
                    15898   ; remain = ptmr->OSTmrDly;
08004D62  2043      15899          move.l    D3,A0
08004D64  2828 0016 15900          move.l    22(A0),D4
                    15901   OSTmrRemainGet_20:
                    15902   ; }
                    15903   ; OSSchedUnlock();
08004D68  4E92      15904          jsr       (A2)
                    15905   ; *perr  = OS_ERR_NONE;
08004D6A  2042      15906          move.l    D2,A0
08004D6C  4210      15907          clr.b     (A0)
                    15908   ; break;
08004D6E  600C      15909          bra.s     OSTmrRemainGet_15
                    15910   OSTmrRemainGet_17:
                    15911   ; case OS_TMR_OPT_ONE_SHOT:
                    15912   ; default:
                    15913   ; remain = ptmr->OSTmrDly;
08004D70  2043      15914          move.l    D3,A0
08004D72  2828 0016 15915          move.l    22(A0),D4
                    15916   ; OSSchedUnlock();
08004D76  4E92      15917          jsr       (A2)
                    15918   ; *perr  = OS_ERR_NONE;
08004D78  2042      15919          move.l    D2,A0
08004D7A  4210      15920          clr.b     (A0)
                    15921   ; break;
                    15922   OSTmrRemainGet_15:
                    15923   ; }
                    15924   ; return (remain);
08004D7C  2004      15925          move.l    D4,D0
08004D7E  6020      15926          bra.s     OSTmrRemainGet_3
                    15927   OSTmrRemainGet_11:
                    15928   ; case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
                    15929   ; OSSchedUnlock();
08004D80  4E92      15930          jsr       (A2)
                    15931   ; *perr = OS_ERR_NONE;
08004D82  2042      15932          move.l    D2,A0
08004D84  4210      15933          clr.b     (A0)
                    15934   ; return (0u);
08004D86  4280      15935          clr.l     D0
08004D88  6016      15936          bra.s     OSTmrRemainGet_3
                    15937   OSTmrRemainGet_12:
                    15938   ; case OS_TMR_STATE_UNUSED:
                    15939   ; OSSchedUnlock();
08004D8A  4E92      15940          jsr       (A2)
                    15941   ; *perr = OS_ERR_TMR_INACTIVE;
08004D8C  2042      15942          move.l    D2,A0
08004D8E  10BC 0087 15943          move.b    #135,(A0)
                    15944   ; return (0u);
08004D92  4280      15945          clr.l     D0
08004D94  600A      15946          bra.s     OSTmrRemainGet_3
                    15947   OSTmrRemainGet_6:
                    15948   ; default:
                    15949   ; OSSchedUnlock();
08004D96  4E92      15950          jsr       (A2)
                    15951   ; *perr = OS_ERR_TMR_INVALID_STATE;
08004D98  2042      15952          move.l    D2,A0
08004D9A  10BC 008D 15953          move.b    #141,(A0)
                    15954   ; return (0u);
08004D9E  4280      15955          clr.l     D0
                    15956   OSTmrRemainGet_3:
08004DA0  4CDF 041C 15957          movem.l   (A7)+,D2/D3/D4/A2
08004DA4  4E5E      15958          unlk      A6
08004DA6  4E75      15959          rts
                    15960   ; }
                    15961   ; }
                    15962   ; #endif
                    15963   ; /*$PAGE*/
                    15964   ; /*
                    15965   ; *********************************************************************************************************
                    15966   ; *                                  FIND OUT WHAT STATE A TIMER IS IN
                    15967   ; *
                    15968   ; * Description: This function is called to determine what state the timer is in:
                    15969   ; *
                    15970   ; *                  OS_TMR_STATE_UNUSED     the timer has not been created
                    15971   ; *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
                    15972   ; *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
                    15973   ; *                  OS_TMR_STATE_RUNNING    the timer is currently running
                    15974   ; *
                    15975   ; * Arguments  : ptmr          Is a pointer to the desired timer
                    15976   ; *
                    15977   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15978   ; *                               OS_ERR_NONE
                    15979   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    15980   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15981   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    15982   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    15983   ; *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
                    15984   ; *
                    15985   ; * Returns    : The current state of the timer (see description).
                    15986   ; *********************************************************************************************************
                    15987   ; */
                    15988   ; #if OS_TMR_EN > 0u
                    15989   ; INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                    15990   ; INT8U   *perr)
                    15991   ; {
                    15992   _OSTmrStateGet:
08004DA8  4E56 0000 15993          link      A6,#0
08004DAC  48E7 3000 15994          movem.l   D2/D3,-(A7)
08004DB0  242E 000C 15995          move.l    12(A6),D2
                    15996   ; INT8U  state;
                    15997   ; #ifdef OS_SAFETY_CRITICAL
                    15998   ; if (perr == (INT8U *)0) {
                    15999   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16000   ; return (0u);
                    16001   ; }
                    16002   ; #endif
                    16003   ; #if OS_ARG_CHK_EN > 0u
                    16004   ; if (ptmr == (OS_TMR *)0) {
                    16005   ; *perr = OS_ERR_TMR_INVALID;
                    16006   ; return (0u);
                    16007   ; }
                    16008   ; #endif
                    16009   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
08004DB4  206E 0008 16010          move.l    8(A6),A0
08004DB8  1010      16011          move.b    (A0),D0
08004DBA  0C00 0064 16012          cmp.b     #100,D0
08004DBE  670C      16013          beq.s     OSTmrStateGet_1
                    16014   ; *perr = OS_ERR_TMR_INVALID_TYPE;
08004DC0  2042      16015          move.l    D2,A0
08004DC2  10BC 0089 16016          move.b    #137,(A0)
                    16017   ; return (0u);
08004DC6  4200      16018          clr.b     D0
08004DC8  6000 005E 16019          bra       OSTmrStateGet_3
                    16020   OSTmrStateGet_1:
                    16021   ; }
                    16022   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
08004DCC  1039 0800 16023          move.b    _OSIntNesting.L,D0
08004DD0  0312      
08004DD2  0C00 0000 16024          cmp.b     #0,D0
08004DD6  630C      16025          bls.s     OSTmrStateGet_4
                    16026   ; *perr = OS_ERR_TMR_ISR;
08004DD8  2042      16027          move.l    D2,A0
08004DDA  10BC 008B 16028          move.b    #139,(A0)
                    16029   ; return (0u);
08004DDE  4200      16030          clr.b     D0
08004DE0  6000 0046 16031          bra       OSTmrStateGet_3
                    16032   OSTmrStateGet_4:
                    16033   ; }
                    16034   ; OSSchedLock();
08004DE4  4EB9 0800 16035          jsr       _OSSchedLock
08004DE8  07D6      
                    16036   ; state = ptmr->OSTmrState;
08004DEA  206E 0008 16037          move.l    8(A6),A0
08004DEE  1628 0023 16038          move.b    35(A0),D3
                    16039   ; switch (state) {
08004DF2  C6BC 0000 16040          and.l     #255,D3
08004DF6  00FF      
08004DF8  2003      16041          move.l    D3,D0
08004DFA  0C80 0000 16042          cmp.l     #4,D0
08004DFE  0004      
08004E00  6418      16043          bhs.s     OSTmrStateGet_6
08004E02  E380      16044          asl.l     #1,D0
08004E04  303B 0806 16045          move.w    OSTmrStateGet_8(PC,D0.L),D0
08004E08  4EFB 0002 16046          jmp       OSTmrStateGet_8(PC,D0.W)
                    16047   OSTmrStateGet_8:
08004E0C  0008      16048          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
08004E0E  0008      16049          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
08004E10  0008      16050          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
08004E12  0008      16051          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
                    16052   OSTmrStateGet_9:
                    16053   ; case OS_TMR_STATE_UNUSED:
                    16054   ; case OS_TMR_STATE_STOPPED:
                    16055   ; case OS_TMR_STATE_COMPLETED:
                    16056   ; case OS_TMR_STATE_RUNNING:
                    16057   ; *perr = OS_ERR_NONE;
08004E14  2042      16058          move.l    D2,A0
08004E16  4210      16059          clr.b     (A0)
                    16060   ; break;
08004E18  6006      16061          bra.s     OSTmrStateGet_7
                    16062   OSTmrStateGet_6:
                    16063   ; default:
                    16064   ; *perr = OS_ERR_TMR_INVALID_STATE;
08004E1A  2042      16065          move.l    D2,A0
08004E1C  10BC 008D 16066          move.b    #141,(A0)
                    16067   ; break;
                    16068   OSTmrStateGet_7:
                    16069   ; }
                    16070   ; OSSchedUnlock();
08004E20  4EB9 0800 16071          jsr       _OSSchedUnlock
08004E24  0806      
                    16072   ; return (state);
08004E26  1003      16073          move.b    D3,D0
                    16074   OSTmrStateGet_3:
08004E28  4CDF 000C 16075          movem.l   (A7)+,D2/D3
08004E2C  4E5E      16076          unlk      A6
08004E2E  4E75      16077          rts
                    16078   ; }
                    16079   ; #endif
                    16080   ; /*$PAGE*/
                    16081   ; /*
                    16082   ; *********************************************************************************************************
                    16083   ; *                                            START A TIMER
                    16084   ; *
                    16085   ; * Description: This function is called by your application code to start a timer.
                    16086   ; *
                    16087   ; * Arguments  : ptmr          Is a pointer to an OS_TMR
                    16088   ; *
                    16089   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16090   ; *                               OS_ERR_NONE
                    16091   ; *                               OS_ERR_TMR_INVALID
                    16092   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16093   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    16094   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16095   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16096   ; *
                    16097   ; * Returns    : OS_TRUE    if the timer was started
                    16098   ; *              OS_FALSE   if an error was detected
                    16099   ; *********************************************************************************************************
                    16100   ; */
                    16101   ; #if OS_TMR_EN > 0u
                    16102   ; BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                    16103   ; INT8U    *perr)
                    16104   ; {
                    16105   _OSTmrStart:
08004E30  4E56 0000 16106          link      A6,#0
08004E34  48E7 3020 16107          movem.l   D2/D3/A2,-(A7)
08004E38  242E 000C 16108          move.l    12(A6),D2
08004E3C  262E 0008 16109          move.l    8(A6),D3
08004E40  45F9 0800 16110          lea       _OSSchedUnlock.L,A2
08004E44  0806      
                    16111   ; #ifdef OS_SAFETY_CRITICAL
                    16112   ; if (perr == (INT8U *)0) {
                    16113   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16114   ; return (OS_FALSE);
                    16115   ; }
                    16116   ; #endif
                    16117   ; #if OS_ARG_CHK_EN > 0u
                    16118   ; if (ptmr == (OS_TMR *)0) {
                    16119   ; *perr = OS_ERR_TMR_INVALID;
                    16120   ; return (OS_FALSE);
                    16121   ; }
                    16122   ; #endif
                    16123   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
08004E46  2043      16124          move.l    D3,A0
08004E48  1010      16125          move.b    (A0),D0
08004E4A  0C00 0064 16126          cmp.b     #100,D0
08004E4E  670C      16127          beq.s     OSTmrStart_1
                    16128   ; *perr = OS_ERR_TMR_INVALID_TYPE;
08004E50  2042      16129          move.l    D2,A0
08004E52  10BC 0089 16130          move.b    #137,(A0)
                    16131   ; return (OS_FALSE);
08004E56  4200      16132          clr.b     D0
08004E58  6000 0096 16133          bra       OSTmrStart_3
                    16134   OSTmrStart_1:
                    16135   ; }
                    16136   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
08004E5C  1039 0800 16137          move.b    _OSIntNesting.L,D0
08004E60  0312      
08004E62  0C00 0000 16138          cmp.b     #0,D0
08004E66  630C      16139          bls.s     OSTmrStart_4
                    16140   ; *perr  = OS_ERR_TMR_ISR;
08004E68  2042      16141          move.l    D2,A0
08004E6A  10BC 008B 16142          move.b    #139,(A0)
                    16143   ; return (OS_FALSE);
08004E6E  4200      16144          clr.b     D0
08004E70  6000 007E 16145          bra       OSTmrStart_3
                    16146   OSTmrStart_4:
                    16147   ; }
                    16148   ; OSSchedLock();
08004E74  4EB9 0800 16149          jsr       _OSSchedLock
08004E78  07D6      
                    16150   ; switch (ptmr->OSTmrState) {
08004E7A  2043      16151          move.l    D3,A0
08004E7C  1028 0023 16152          move.b    35(A0),D0
08004E80  C0BC 0000 16153          and.l     #255,D0
08004E84  00FF      
08004E86  0C80 0000 16154          cmp.l     #4,D0
08004E8A  0004      
08004E8C  6400 0058 16155          bhs       OSTmrStart_6
08004E90  E380      16156          asl.l     #1,D0
08004E92  303B 0806 16157          move.w    OSTmrStart_8(PC,D0.L),D0
08004E96  4EFB 0002 16158          jmp       OSTmrStart_8(PC,D0.W)
                    16159   OSTmrStart_8:
08004E9A  0040      16160          dc.w      OSTmrStart_12-OSTmrStart_8
08004E9C  002A      16161          dc.w      OSTmrStart_10-OSTmrStart_8
08004E9E  002A      16162          dc.w      OSTmrStart_10-OSTmrStart_8
08004EA0  0008      16163          dc.w      OSTmrStart_9-OSTmrStart_8
                    16164   OSTmrStart_9:
                    16165   ; case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
                    16166   ; OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
08004EA2  2F03      16167          move.l    D3,-(A7)
08004EA4  4EB9 0800 16168          jsr       @ucos_ii_OSTmr_Unlink
08004EA8  5342      
08004EAA  584F      16169          addq.w    #4,A7
                    16170   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
08004EAC  42A7      16171          clr.l     -(A7)
08004EAE  2F03      16172          move.l    D3,-(A7)
08004EB0  4EB9 0800 16173          jsr       @ucos_ii_OSTmr_Link
08004EB4  526E      
08004EB6  504F      16174          addq.w    #8,A7
                    16175   ; OSSchedUnlock();
08004EB8  4E92      16176          jsr       (A2)
                    16177   ; *perr = OS_ERR_NONE;
08004EBA  2042      16178          move.l    D2,A0
08004EBC  4210      16179          clr.b     (A0)
                    16180   ; return (OS_TRUE);
08004EBE  7001      16181          moveq     #1,D0
08004EC0  6000 002E 16182          bra       OSTmrStart_3
                    16183   OSTmrStart_10:
                    16184   ; case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
                    16185   ; case OS_TMR_STATE_COMPLETED:
                    16186   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
08004EC4  42A7      16187          clr.l     -(A7)
08004EC6  2F03      16188          move.l    D3,-(A7)
08004EC8  4EB9 0800 16189          jsr       @ucos_ii_OSTmr_Link
08004ECC  526E      
08004ECE  504F      16190          addq.w    #8,A7
                    16191   ; OSSchedUnlock();
08004ED0  4E92      16192          jsr       (A2)
                    16193   ; *perr = OS_ERR_NONE;
08004ED2  2042      16194          move.l    D2,A0
08004ED4  4210      16195          clr.b     (A0)
                    16196   ; return (OS_TRUE);
08004ED6  7001      16197          moveq     #1,D0
08004ED8  6016      16198          bra.s     OSTmrStart_3
                    16199   OSTmrStart_12:
                    16200   ; case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
                    16201   ; OSSchedUnlock();
08004EDA  4E92      16202          jsr       (A2)
                    16203   ; *perr = OS_ERR_TMR_INACTIVE;
08004EDC  2042      16204          move.l    D2,A0
08004EDE  10BC 0087 16205          move.b    #135,(A0)
                    16206   ; return (OS_FALSE);
08004EE2  4200      16207          clr.b     D0
08004EE4  600A      16208          bra.s     OSTmrStart_3
                    16209   OSTmrStart_6:
                    16210   ; default:
                    16211   ; OSSchedUnlock();
08004EE6  4E92      16212          jsr       (A2)
                    16213   ; *perr = OS_ERR_TMR_INVALID_STATE;
08004EE8  2042      16214          move.l    D2,A0
08004EEA  10BC 008D 16215          move.b    #141,(A0)
                    16216   ; return (OS_FALSE);
08004EEE  4200      16217          clr.b     D0
                    16218   OSTmrStart_3:
08004EF0  4CDF 040C 16219          movem.l   (A7)+,D2/D3/A2
08004EF4  4E5E      16220          unlk      A6
08004EF6  4E75      16221          rts
                    16222   ; }
                    16223   ; }
                    16224   ; #endif
                    16225   ; /*$PAGE*/
                    16226   ; /*
                    16227   ; *********************************************************************************************************
                    16228   ; *                                            STOP A TIMER
                    16229   ; *
                    16230   ; * Description: This function is called by your application code to stop a timer.
                    16231   ; *
                    16232   ; * Arguments  : ptmr          Is a pointer to the timer to stop.
                    16233   ; *
                    16234   ; *              opt           Allows you to specify an option to this functions which can be:
                    16235   ; *
                    16236   ; *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
                    16237   ; *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the 
                    16238   ; *                                                        callback argument specified when the timer 
                    16239   ; *                                                        was created.
                    16240   ; *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the 
                    16241   ; *                                                        callback argument specified in THIS function call.
                    16242   ; *
                    16243   ; *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
                    16244   ; *                            function instead of the timer's callback argument.  In other words, use 
                    16245   ; *                            'callback_arg' passed in THIS function INSTEAD of ptmr->OSTmrCallbackArg.
                    16246   ; *
                    16247   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16248   ; *                               OS_ERR_NONE
                    16249   ; *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
                    16250   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16251   ; *                               OS_ERR_TMR_ISR             if the function was called from an ISR
                    16252   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16253   ; *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
                    16254   ; *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
                    16255   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16256   ; *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
                    16257   ; *
                    16258   ; * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
                    16259   ; *              OS_FALSE      If not
                    16260   ; *********************************************************************************************************
                    16261   ; */
                    16262   ; #if OS_TMR_EN > 0u
                    16263   ; BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    16264   ; INT8U    opt,
                    16265   ; void    *callback_arg,
                    16266   ; INT8U   *perr)
                    16267   ; {
                    16268   _OSTmrStop:
08004EF8  4E56 0000 16269          link      A6,#0
08004EFC  48E7 3820 16270          movem.l   D2/D3/D4/A2,-(A7)
08004F00  242E 0014 16271          move.l    20(A6),D2
08004F04  262E 0008 16272          move.l    8(A6),D3
08004F08  45F9 0800 16273          lea       _OSSchedUnlock.L,A2
08004F0C  0806      
                    16274   ; OS_TMR_CALLBACK  pfnct;
                    16275   ; #ifdef OS_SAFETY_CRITICAL
                    16276   ; if (perr == (INT8U *)0) {
                    16277   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16278   ; return (OS_FALSE);
                    16279   ; }
                    16280   ; #endif
                    16281   ; #if OS_ARG_CHK_EN > 0u
                    16282   ; if (ptmr == (OS_TMR *)0) {
                    16283   ; *perr = OS_ERR_TMR_INVALID;
                    16284   ; return (OS_FALSE);
                    16285   ; }
                    16286   ; #endif
                    16287   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
08004F0E  2043      16288          move.l    D3,A0
08004F10  1010      16289          move.b    (A0),D0
08004F12  0C00 0064 16290          cmp.b     #100,D0
08004F16  670C      16291          beq.s     OSTmrStop_1
                    16292   ; *perr = OS_ERR_TMR_INVALID_TYPE;
08004F18  2042      16293          move.l    D2,A0
08004F1A  10BC 0089 16294          move.b    #137,(A0)
                    16295   ; return (OS_FALSE);
08004F1E  4200      16296          clr.b     D0
08004F20  6000 00F4 16297          bra       OSTmrStop_3
                    16298   OSTmrStop_1:
                    16299   ; }
                    16300   ; if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
08004F24  1039 0800 16301          move.b    _OSIntNesting.L,D0
08004F28  0312      
08004F2A  0C00 0000 16302          cmp.b     #0,D0
08004F2E  630C      16303          bls.s     OSTmrStop_4
                    16304   ; *perr  = OS_ERR_TMR_ISR;
08004F30  2042      16305          move.l    D2,A0
08004F32  10BC 008B 16306          move.b    #139,(A0)
                    16307   ; return (OS_FALSE);
08004F36  4200      16308          clr.b     D0
08004F38  6000 00DC 16309          bra       OSTmrStop_3
                    16310   OSTmrStop_4:
                    16311   ; }
                    16312   ; OSSchedLock();
08004F3C  4EB9 0800 16313          jsr       _OSSchedLock
08004F40  07D6      
                    16314   ; switch (ptmr->OSTmrState) {
08004F42  2043      16315          move.l    D3,A0
08004F44  1028 0023 16316          move.b    35(A0),D0
08004F48  C0BC 0000 16317          and.l     #255,D0
08004F4C  00FF      
08004F4E  0C80 0000 16318          cmp.l     #4,D0
08004F52  0004      
08004F54  6400 00B6 16319          bhs       OSTmrStop_6
08004F58  E380      16320          asl.l     #1,D0
08004F5A  303B 0806 16321          move.w    OSTmrStop_8(PC,D0.L),D0
08004F5E  4EFB 0002 16322          jmp       OSTmrStop_8(PC,D0.W)
                    16323   OSTmrStop_8:
08004F62  009E      16324          dc.w      OSTmrStop_12-OSTmrStop_8
08004F64  0092      16325          dc.w      OSTmrStop_10-OSTmrStop_8
08004F66  0092      16326          dc.w      OSTmrStop_10-OSTmrStop_8
08004F68  0008      16327          dc.w      OSTmrStop_9-OSTmrStop_8
                    16328   OSTmrStop_9:
                    16329   ; case OS_TMR_STATE_RUNNING:
                    16330   ; OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
08004F6A  2F03      16331          move.l    D3,-(A7)
08004F6C  4EB9 0800 16332          jsr       @ucos_ii_OSTmr_Unlink
08004F70  5342      
08004F72  584F      16333          addq.w    #4,A7
                    16334   ; *perr = OS_ERR_NONE;
08004F74  2042      16335          move.l    D2,A0
08004F76  4210      16336          clr.b     (A0)
                    16337   ; switch (opt) {
08004F78  102E 000F 16338          move.b    15(A6),D0
08004F7C  C0BC 0000 16339          and.l     #255,D0
08004F80  00FF      
08004F82  0C80 0000 16340          cmp.l     #3,D0
08004F86  0003      
08004F88  6718      16341          beq.s     OSTmrStop_16
08004F8A  620A      16342          bhi.s     OSTmrStop_20
08004F8C  4A80      16343          tst.l     D0
08004F8E  6700 0056 16344          beq       OSTmrStop_18
08004F92  6000 0054 16345          bra       OSTmrStop_14
                    16346   OSTmrStop_20:
08004F96  0C80 0000 16347          cmp.l     #4,D0
08004F9A  0004      
08004F9C  6728      16348          beq.s     OSTmrStop_17
08004F9E  6000 0048 16349          bra       OSTmrStop_14
                    16350   OSTmrStop_16:
                    16351   ; case OS_TMR_OPT_CALLBACK:
                    16352   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
08004FA2  2043      16353          move.l    D3,A0
08004FA4  2828 0002 16354          move.l    2(A0),D4
                    16355   ; if (pfnct != (OS_TMR_CALLBACK)0) {
08004FA8  4A84      16356          tst.l     D4
08004FAA  6710      16357          beq.s     OSTmrStop_21
                    16358   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
08004FAC  2043      16359          move.l    D3,A0
08004FAE  2F28 0006 16360          move.l    6(A0),-(A7)
08004FB2  2F03      16361          move.l    D3,-(A7)
08004FB4  2044      16362          move.l    D4,A0
08004FB6  4E90      16363          jsr       (A0)
08004FB8  504F      16364          addq.w    #8,A7
08004FBA  6006      16365          bra.s     OSTmrStop_22
                    16366   OSTmrStop_21:
                    16367   ; } else {
                    16368   ; *perr = OS_ERR_TMR_NO_CALLBACK;
08004FBC  2042      16369          move.l    D2,A0
08004FBE  10BC 008F 16370          move.b    #143,(A0)
                    16371   OSTmrStop_22:
                    16372   ; }
                    16373   ; break;
08004FC2  6000 002A 16374          bra       OSTmrStop_15
                    16375   OSTmrStop_17:
                    16376   ; case OS_TMR_OPT_CALLBACK_ARG:
                    16377   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
08004FC6  2043      16378          move.l    D3,A0
08004FC8  2828 0002 16379          move.l    2(A0),D4
                    16380   ; if (pfnct != (OS_TMR_CALLBACK)0) {
08004FCC  4A84      16381          tst.l     D4
08004FCE  670E      16382          beq.s     OSTmrStop_23
                    16383   ; (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
08004FD0  2F2E 0010 16384          move.l    16(A6),-(A7)
08004FD4  2F03      16385          move.l    D3,-(A7)
08004FD6  2044      16386          move.l    D4,A0
08004FD8  4E90      16387          jsr       (A0)
08004FDA  504F      16388          addq.w    #8,A7
08004FDC  6006      16389          bra.s     OSTmrStop_24
                    16390   OSTmrStop_23:
                    16391   ; } else {
                    16392   ; *perr = OS_ERR_TMR_NO_CALLBACK;
08004FDE  2042      16393          move.l    D2,A0
08004FE0  10BC 008F 16394          move.b    #143,(A0)
                    16395   OSTmrStop_24:
                    16396   ; }
                    16397   ; break;
08004FE4  6008      16398          bra.s     OSTmrStop_15
                    16399   OSTmrStop_18:
                    16400   ; case OS_TMR_OPT_NONE:
                    16401   ; break;
08004FE6  6006      16402          bra.s     OSTmrStop_15
                    16403   OSTmrStop_14:
                    16404   ; default:
                    16405   ; *perr = OS_ERR_TMR_INVALID_OPT;
08004FE8  2042      16406          move.l    D2,A0
08004FEA  10BC 0084 16407          move.b    #132,(A0)
                    16408   ; break;
                    16409   OSTmrStop_15:
                    16410   ; }
                    16411   ; OSSchedUnlock();
08004FEE  4E92      16412          jsr       (A2)
                    16413   ; return (OS_TRUE);
08004FF0  7001      16414          moveq     #1,D0
08004FF2  6022      16415          bra.s     OSTmrStop_3
                    16416   OSTmrStop_10:
                    16417   ; case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
                    16418   ; case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
                    16419   ; OSSchedUnlock();
08004FF4  4E92      16420          jsr       (A2)
                    16421   ; *perr = OS_ERR_TMR_STOPPED;
08004FF6  2042      16422          move.l    D2,A0
08004FF8  10BC 008E 16423          move.b    #142,(A0)
                    16424   ; return (OS_TRUE);
08004FFC  7001      16425          moveq     #1,D0
08004FFE  6016      16426          bra.s     OSTmrStop_3
                    16427   OSTmrStop_12:
                    16428   ; case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
                    16429   ; OSSchedUnlock();
08005000  4E92      16430          jsr       (A2)
                    16431   ; *perr = OS_ERR_TMR_INACTIVE;
08005002  2042      16432          move.l    D2,A0
08005004  10BC 0087 16433          move.b    #135,(A0)
                    16434   ; return (OS_FALSE);
08005008  4200      16435          clr.b     D0
0800500A  600A      16436          bra.s     OSTmrStop_3
                    16437   OSTmrStop_6:
                    16438   ; default:
                    16439   ; OSSchedUnlock();
0800500C  4E92      16440          jsr       (A2)
                    16441   ; *perr = OS_ERR_TMR_INVALID_STATE;
0800500E  2042      16442          move.l    D2,A0
08005010  10BC 008D 16443          move.b    #141,(A0)
                    16444   ; return (OS_FALSE);
08005014  4200      16445          clr.b     D0
                    16446   OSTmrStop_3:
08005016  4CDF 041C 16447          movem.l   (A7)+,D2/D3/D4/A2
0800501A  4E5E      16448          unlk      A6
0800501C  4E75      16449          rts
                    16450   ; }
                    16451   ; }
                    16452   ; #endif
                    16453   ; /*$PAGE*/
                    16454   ; /*
                    16455   ; *********************************************************************************************************
                    16456   ; *                             SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
                    16457   ; *
                    16458   ; * Description: This function is typically called by the ISR that occurs at the timer tick rate and is 
                    16459   ; *              used to signal to OSTmr_Task() that it's time to update the timers.
                    16460   ; *
                    16461   ; * Arguments  : none
                    16462   ; *
                    16463   ; * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
                    16464   ; *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle 
                    16465   ; *                                  the timers. This would indicate that your system is heavily loaded.
                    16466   ; *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for 
                    16467   ; *                                  signaling is created by uC/OS-II.
                    16468   ; *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore 
                    16469   ; *                                  used for signaling is created by uC/OS-II.
                    16470   ; *********************************************************************************************************
                    16471   ; */
                    16472   ; #if OS_TMR_EN > 0u
                    16473   ; INT8U  OSTmrSignal (void)
                    16474   ; {
                    16475   _OSTmrSignal:
0800501E  4E56 FFFC 16476          link      A6,#-4
                    16477   ; INT8U  err;
                    16478   ; err = OSSemPost(OSTmrSemSignal);
08005022  2F39 0800 16479          move.l    _OSTmrSemSignal.L,-(A7)
08005026  0D92      
08005028  4EB9 0800 16480          jsr       _OSSemPost
0800502C  3B3E      
0800502E  584F      16481          addq.w    #4,A7
08005030  1D40 FFFF 16482          move.b    D0,-1(A6)
                    16483   ; return (err);
08005034  102E FFFF 16484          move.b    -1(A6),D0
08005038  4E5E      16485          unlk      A6
0800503A  4E75      16486          rts
                    16487   ; }
                    16488   ; #endif
                    16489   ; /*$PAGE*/
                    16490   ; /*
                    16491   ; *********************************************************************************************************
                    16492   ; *                                      ALLOCATE AND FREE A TIMER
                    16493   ; *
                    16494   ; * Description: This function is called to allocate a timer.
                    16495   ; *
                    16496   ; * Arguments  : none
                    16497   ; *
                    16498   ; * Returns    : a pointer to a timer if one is available
                    16499   ; *********************************************************************************************************
                    16500   ; */
                    16501   ; #if OS_TMR_EN > 0u
                    16502   ; static  OS_TMR  *OSTmr_Alloc (void)
                    16503   ; {
                    16504   @ucos_ii_OSTmr_Alloc:
0800503C  48E7 2020 16505          movem.l   D2/A2,-(A7)
08005040  45F9 0800 16506          lea       _OSTmrFreeList.L,A2
08005044  0FD6      
                    16507   ; OS_TMR *ptmr;
                    16508   ; if (OSTmrFreeList == (OS_TMR *)0) {
08005046  2012      16509          move.l    (A2),D0
08005048  6604      16510          bne.s     @ucos_ii_OSTmr_Alloc_1
                    16511   ; return ((OS_TMR *)0);
0800504A  4280      16512          clr.l     D0
0800504C  6022      16513          bra.s     @ucos_ii_OSTmr_Alloc_3
                    16514   @ucos_ii_OSTmr_Alloc_1:
                    16515   ; }
                    16516   ; ptmr            = (OS_TMR *)OSTmrFreeList;
0800504E  2412      16517          move.l    (A2),D2
                    16518   ; OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
08005050  2042      16519          move.l    D2,A0
08005052  24A8 000A 16520          move.l    10(A0),(A2)
                    16521   ; ptmr->OSTmrNext = (OS_TCB *)0;
08005056  2042      16522          move.l    D2,A0
08005058  42A8 000A 16523          clr.l     10(A0)
                    16524   ; ptmr->OSTmrPrev = (OS_TCB *)0;
0800505C  2042      16525          move.l    D2,A0
0800505E  42A8 000E 16526          clr.l     14(A0)
                    16527   ; OSTmrUsed++;
08005062  5279 0800 16528          addq.w    #1,_OSTmrUsed.L
08005066  0D88      
                    16529   ; OSTmrFree--;
08005068  5379 0800 16530          subq.w    #1,_OSTmrFree.L
0800506C  0D86      
                    16531   ; return (ptmr);
0800506E  2002      16532          move.l    D2,D0
                    16533   @ucos_ii_OSTmr_Alloc_3:
08005070  4CDF 0404 16534          movem.l   (A7)+,D2/A2
08005074  4E75      16535          rts
                    16536   ; }
                    16537   ; #endif
                    16538   ; /*
                    16539   ; *********************************************************************************************************
                    16540   ; *                                   RETURN A TIMER TO THE FREE LIST
                    16541   ; *
                    16542   ; * Description: This function is called to return a timer object to the free list of timers.
                    16543   ; *
                    16544   ; * Arguments  : ptmr     is a pointer to the timer to free
                    16545   ; *
                    16546   ; * Returns    : none
                    16547   ; *********************************************************************************************************
                    16548   ; */
                    16549   ; #if OS_TMR_EN > 0u
                    16550   ; static  void  OSTmr_Free (OS_TMR *ptmr)
                    16551   ; {
                    16552   @ucos_ii_OSTmr_Free:
08005076  4E56 0000 16553          link      A6,#0
0800507A  2F02      16554          move.l    D2,-(A7)
0800507C  242E 0008 16555          move.l    8(A6),D2
                    16556   ; ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
08005080  2042      16557          move.l    D2,A0
08005082  4228 0023 16558          clr.b     35(A0)
                    16559   ; ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
08005086  2042      16560          move.l    D2,A0
08005088  4228 0022 16561          clr.b     34(A0)
                    16562   ; ptmr->OSTmrPeriod      = 0u;
0800508C  2042      16563          move.l    D2,A0
0800508E  42A8 001A 16564          clr.l     26(A0)
                    16565   ; ptmr->OSTmrMatch       = 0u;
08005092  2042      16566          move.l    D2,A0
08005094  42A8 0012 16567          clr.l     18(A0)
                    16568   ; ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
08005098  2042      16569          move.l    D2,A0
0800509A  42A8 0002 16570          clr.l     2(A0)
                    16571   ; ptmr->OSTmrCallbackArg = (void *)0;
0800509E  2042      16572          move.l    D2,A0
080050A0  42A8 0006 16573          clr.l     6(A0)
                    16574   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16575   ; ptmr->OSTmrName        = (INT8U *)(void *)"?";
080050A4  41F9 0800 16576          lea       @ucos_ii_1.L,A0
080050A8  57FE      
080050AA  2242      16577          move.l    D2,A1
080050AC  2348 001E 16578          move.l    A0,30(A1)
                    16579   ; #endif
                    16580   ; ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
080050B0  2042      16581          move.l    D2,A0
080050B2  42A8 000E 16582          clr.l     14(A0)
                    16583   ; ptmr->OSTmrNext        = OSTmrFreeList;
080050B6  2042      16584          move.l    D2,A0
080050B8  2179 0800 16585          move.l    _OSTmrFreeList.L,10(A0)
080050BC  0FD6 000A 
                    16586   ; OSTmrFreeList          = ptmr;
080050C0  23C2 0800 16587          move.l    D2,_OSTmrFreeList.L
080050C4  0FD6      
                    16588   ; OSTmrUsed--;                                       /* Update timer object statistics                              */
080050C6  5379 0800 16589          subq.w    #1,_OSTmrUsed.L
080050CA  0D88      
                    16590   ; OSTmrFree++;
080050CC  5279 0800 16591          addq.w    #1,_OSTmrFree.L
080050D0  0D86      
080050D2  241F      16592          move.l    (A7)+,D2
080050D4  4E5E      16593          unlk      A6
080050D6  4E75      16594          rts
                    16595   ; }
                    16596   ; #endif
                    16597   ; /*$PAGE*/
                    16598   ; /*
                    16599   ; *********************************************************************************************************
                    16600   ; *                                                    INITIALIZATION
                    16601   ; *                                          INITIALIZE THE FREE LIST OF TIMERS
                    16602   ; *
                    16603   ; * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
                    16604   ; *
                    16605   ; * Arguments  : none
                    16606   ; *
                    16607   ; * Returns    : none
                    16608   ; *********************************************************************************************************
                    16609   ; */
                    16610   ; #if OS_TMR_EN > 0u
                    16611   ; void  OSTmr_Init (void)
                    16612   ; {
                    16613   _OSTmr_Init:
080050D8  4E56 FFF8 16614          link      A6,#-8
080050DC  48E7 3020 16615          movem.l   D2/D3/A2,-(A7)
080050E0  45F9 0800 16616          lea       _OSTmrTbl.L,A2
080050E4  0D96      
                    16617   ; #if OS_EVENT_NAME_EN > 0u
                    16618   ; INT8U    err;
                    16619   ; #endif
                    16620   ; INT16U   ix;
                    16621   ; INT16U   ix_next;
                    16622   ; OS_TMR  *ptmr1;
                    16623   ; OS_TMR  *ptmr2;
                    16624   ; OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
080050E6  4878 0240 16625          pea       576
080050EA  2F0A      16626          move.l    A2,-(A7)
080050EC  4EB9 0800 16627          jsr       _OS_MemClr
080050F0  0F3E      
080050F2  504F      16628          addq.w    #8,A7
                    16629   ; OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
080050F4  4878 0020 16630          pea       32
080050F8  4879 0800 16631          pea       _OSTmrWheelTbl.L
080050FC  10DA      
080050FE  4EB9 0800 16632          jsr       _OS_MemClr
08005102  0F3E      
08005104  504F      16633          addq.w    #8,A7
                    16634   ; for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
08005106  4243      16635          clr.w     D3
                    16636   OSTmr_Init_1:
08005108  0C43 000F 16637          cmp.w     #15,D3
0800510C  6400 0056 16638          bhs       OSTmr_Init_3
                    16639   ; ix_next = ix + 1u;
08005110  3003      16640          move.w    D3,D0
08005112  5240      16641          addq.w    #1,D0
08005114  3D40 FFFA 16642          move.w    D0,-6(A6)
                    16643   ; ptmr1 = &OSTmrTbl[ix];
08005118  200A      16644          move.l    A2,D0
0800511A  C6BC 0000 16645          and.l     #65535,D3
0800511E  FFFF      
08005120  2203      16646          move.l    D3,D1
08005122  C3FC 0024 16647          muls      #36,D1
08005126  D081      16648          add.l     D1,D0
08005128  2400      16649          move.l    D0,D2
                    16650   ; ptmr2 = &OSTmrTbl[ix_next];
0800512A  200A      16651          move.l    A2,D0
0800512C  322E FFFA 16652          move.w    -6(A6),D1
08005130  C2BC 0000 16653          and.l     #65535,D1
08005134  FFFF      
08005136  C3FC 0024 16654          muls      #36,D1
0800513A  D081      16655          add.l     D1,D0
0800513C  2D40 FFFC 16656          move.l    D0,-4(A6)
                    16657   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
08005140  2042      16658          move.l    D2,A0
08005142  10BC 0064 16659          move.b    #100,(A0)
                    16660   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
08005146  2042      16661          move.l    D2,A0
08005148  4228 0023 16662          clr.b     35(A0)
                    16663   ; ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
0800514C  2042      16664          move.l    D2,A0
0800514E  216E FFFC 16665          move.l    -4(A6),10(A0)
08005152  000A      
                    16666   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16667   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
08005154  41F9 0800 16668          lea       @ucos_ii_1.L,A0
08005158  57FE      
0800515A  2242      16669          move.l    D2,A1
0800515C  2348 001E 16670          move.l    A0,30(A1)
08005160  5243      16671          addq.w    #1,D3
08005162  60A4      16672          bra       OSTmr_Init_1
                    16673   OSTmr_Init_3:
                    16674   ; #endif
                    16675   ; }
                    16676   ; ptmr1               = &OSTmrTbl[ix];
08005164  200A      16677          move.l    A2,D0
08005166  C6BC 0000 16678          and.l     #65535,D3
0800516A  FFFF      
0800516C  2203      16679          move.l    D3,D1
0800516E  C3FC 0024 16680          muls      #36,D1
08005172  D081      16681          add.l     D1,D0
08005174  2400      16682          move.l    D0,D2
                    16683   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
08005176  2042      16684          move.l    D2,A0
08005178  10BC 0064 16685          move.b    #100,(A0)
                    16686   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
0800517C  2042      16687          move.l    D2,A0
0800517E  4228 0023 16688          clr.b     35(A0)
                    16689   ; ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
08005182  2042      16690          move.l    D2,A0
08005184  42A8 000A 16691          clr.l     10(A0)
                    16692   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16693   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
08005188  41F9 0800 16694          lea       @ucos_ii_1.L,A0
0800518C  57FE      
0800518E  2242      16695          move.l    D2,A1
08005190  2348 001E 16696          move.l    A0,30(A1)
                    16697   ; #endif
                    16698   ; OSTmrTime           = 0u;
08005194  42B9 0800 16699          clr.l     _OSTmrTime.L
08005198  0D8A      
                    16700   ; OSTmrUsed           = 0u;
0800519A  4279 0800 16701          clr.w     _OSTmrUsed.L
0800519E  0D88      
                    16702   ; OSTmrFree           = OS_TMR_CFG_MAX;
080051A0  33FC 0010 16703          move.w    #16,_OSTmrFree.L
080051A4  0800 0D86 
                    16704   ; OSTmrFreeList       = &OSTmrTbl[0];
080051A8  23CA 0800 16705          move.l    A2,_OSTmrFreeList.L
080051AC  0FD6      
                    16706   ; OSTmrSem            = OSSemCreate(1u);
080051AE  4878 0001 16707          pea       1
080051B2  4EB9 0800 16708          jsr       _OSSemCreate
080051B6  37E4      
080051B8  584F      16709          addq.w    #4,A7
080051BA  23C0 0800 16710          move.l    D0,_OSTmrSem.L
080051BE  0D8E      
                    16711   ; OSTmrSemSignal      = OSSemCreate(0u);
080051C0  42A7      16712          clr.l     -(A7)
080051C2  4EB9 0800 16713          jsr       _OSSemCreate
080051C6  37E4      
080051C8  584F      16714          addq.w    #4,A7
080051CA  23C0 0800 16715          move.l    D0,_OSTmrSemSignal.L
080051CE  0D92      
                    16716   ; #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
                    16717   ; OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
080051D0  486E FFF9 16718          pea       -7(A6)
080051D4  4879 0800 16719          pea       @ucos_ii_4.L
080051D8  581C      
080051DA  2F39 0800 16720          move.l    _OSTmrSem.L,-(A7)
080051DE  0D8E      
080051E0  4EB9 0800 16721          jsr       _OSEventNameSet
080051E4  0342      
080051E6  DEFC 000C 16722          add.w     #12,A7
                    16723   ; OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
080051EA  486E FFF9 16724          pea       -7(A6)
080051EE  4879 0800 16725          pea       @ucos_ii_5.L
080051F2  582E      
080051F4  2F39 0800 16726          move.l    _OSTmrSemSignal.L,-(A7)
080051F8  0D92      
080051FA  4EB9 0800 16727          jsr       _OSEventNameSet
080051FE  0342      
08005200  DEFC 000C 16728          add.w     #12,A7
                    16729   ; #endif
                    16730   ; OSTmr_InitTask();
08005204  4EB9 0800 16731          jsr       @ucos_ii_OSTmr_InitTask
08005208  5212      
0800520A  4CDF 040C 16732          movem.l   (A7)+,D2/D3/A2
0800520E  4E5E      16733          unlk      A6
08005210  4E75      16734          rts
                    16735   ; }
                    16736   ; #endif
                    16737   ; /*$PAGE*/
                    16738   ; /*
                    16739   ; *********************************************************************************************************
                    16740   ; *                                INITIALIZE THE TIMER MANAGEMENT TASK
                    16741   ; *
                    16742   ; * Description: This function is called by OSTmrInit() to create the timer management task.
                    16743   ; *                               * Arguments  : none
                    16744   ; *
                    16745   ; * Returns    : none
                    16746   ; *********************************************************************************************************
                    16747   ; */
                    16748   ; #if OS_TMR_EN > 0u
                    16749   ; static  void  OSTmr_InitTask (void)
                    16750   ; {
                    16751   @ucos_ii_OSTmr_InitTask:
08005212  4E56 FFFC 16752          link      A6,#-4
                    16753   ; #if OS_TASK_NAME_EN > 0u
                    16754   ; INT8U  err;
                    16755   ; #endif
                    16756   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    16757   ; #if OS_STK_GROWTH == 1u
                    16758   ; (void)OSTaskCreateExt(OSTmr_Task,
08005216  4878 0003 16759          pea       3
0800521A  42A7      16760          clr.l     -(A7)
0800521C  4878 0080 16761          pea       128
08005220  4879 0800 16762          pea       _OSTmrTaskStk.L
08005224  0FDA      
08005226  4878 FFFD 16763          pea       65533
0800522A  4878 0005 16764          pea       5
0800522E  41F9 0800 16765          lea       _OSTmrTaskStk.L,A0
08005232  0FDA      
08005234  D0FC 00FE 16766          add.w     #254,A0
08005238  2F08      16767          move.l    A0,-(A7)
0800523A  42A7      16768          clr.l     -(A7)
0800523C  4879 0800 16769          pea       @ucos_ii_OSTmr_Task.L
08005240  53E0      
08005242  4EB9 0800 16770          jsr       _OSTaskCreateExt
08005246  3F78      
08005248  DEFC 0024 16771          add.w     #36,A7
0800524C  C0BC 0000 16772          and.l     #255,D0
08005250  00FF      
                    16773   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    16774   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
                    16775   ; OS_TASK_TMR_PRIO,
                    16776   ; OS_TASK_TMR_ID,
                    16777   ; &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
                    16778   ; OS_TASK_TMR_STK_SIZE,
                    16779   ; (void *)0,                                       /* No TCB extension                        */
                    16780   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    16781   ; #else
                    16782   ; (void)OSTaskCreateExt(OSTmr_Task,
                    16783   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    16784   ; &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
                    16785   ; OS_TASK_TMR_PRIO,
                    16786   ; OS_TASK_TMR_ID,
                    16787   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
                    16788   ; OS_TASK_TMR_STK_SIZE,
                    16789   ; (void *)0,                                       /* No TCB extension                        */
                    16790   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    16791   ; #endif
                    16792   ; #else
                    16793   ; #if OS_STK_GROWTH == 1u
                    16794   ; (void)OSTaskCreate(OSTmr_Task,
                    16795   ; (void *)0,
                    16796   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                    16797   ; OS_TASK_TMR_PRIO);
                    16798   ; #else
                    16799   ; (void)OSTaskCreate(OSTmr_Task,
                    16800   ; (void *)0,
                    16801   ; &OSTmrTaskStk[0],
                    16802   ; OS_TASK_TMR_PRIO);
                    16803   ; #endif
                    16804   ; #endif
                    16805   ; #if OS_TASK_NAME_EN > 0u
                    16806   ; OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
08005252  486E FFFF 16807          pea       -1(A6)
08005256  4879 0800 16808          pea       @ucos_ii_6.L
0800525A  5842      
0800525C  4878 0005 16809          pea       5
08005260  4EB9 0800 16810          jsr       _OSTaskNameSet
08005264  4398      
08005266  DEFC 000C 16811          add.w     #12,A7
0800526A  4E5E      16812          unlk      A6
0800526C  4E75      16813          rts
                    16814   ; #endif
                    16815   ; }
                    16816   ; #endif
                    16817   ; /*$PAGE*/
                    16818   ; /*
                    16819   ; *********************************************************************************************************
                    16820   ; *                                 INSERT A TIMER INTO THE TIMER WHEEL
                    16821   ; *
                    16822   ; * Description: This function is called to insert the timer into the timer wheel.  The timer is always 
                    16823   ; *              inserted at the beginning of the list.
                    16824   ; *
                    16825   ; * Arguments  : ptmr          Is a pointer to the timer to insert.
                    16826   ; *
                    16827   ; *              type          Is either:
                    16828   ; *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
                    16829   ; *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
                    16830   ; *
                    16831   ; * Returns    : none
                    16832   ; *********************************************************************************************************
                    16833   ; */
                    16834   ; #if OS_TMR_EN > 0u
                    16835   ; static  void  OSTmr_Link (OS_TMR  *ptmr,
                    16836   ; INT8U    type)
                    16837   ; {
                    16838   @ucos_ii_OSTmr_Link:
0800526E  4E56 FFFC 16839          link      A6,#-4
08005272  48E7 3820 16840          movem.l   D2/D3/D4/A2,-(A7)
08005276  242E 0008 16841          move.l    8(A6),D2
0800527A  45F9 0800 16842          lea       _OSTmrTime.L,A2
0800527E  0D8A      
                    16843   ; OS_TMR       *ptmr1;
                    16844   ; OS_TMR_WHEEL *pspoke;
                    16845   ; INT16U        spoke;
                    16846   ; ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
08005280  2042      16847          move.l    D2,A0
08005282  117C 0003 16848          move.b    #3,35(A0)
08005286  0023      
                    16849   ; if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
08005288  102E 000F 16850          move.b    15(A6),D0
0800528C  0C00 0001 16851          cmp.b     #1,D0
08005290  6610      16852          bne.s     @ucos_ii_OSTmr_Link_1
                    16853   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
08005292  2042      16854          move.l    D2,A0
08005294  2028 001A 16855          move.l    26(A0),D0
08005298  D092      16856          add.l     (A2),D0
0800529A  2042      16857          move.l    D2,A0
0800529C  2140 0012 16858          move.l    D0,18(A0)
080052A0  6026      16859          bra.s     @ucos_ii_OSTmr_Link_4
                    16860   @ucos_ii_OSTmr_Link_1:
                    16861   ; } else {
                    16862   ; if (ptmr->OSTmrDly == 0u) {
080052A2  2042      16863          move.l    D2,A0
080052A4  2028 0016 16864          move.l    22(A0),D0
080052A8  6610      16865          bne.s     @ucos_ii_OSTmr_Link_3
                    16866   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
080052AA  2042      16867          move.l    D2,A0
080052AC  2028 001A 16868          move.l    26(A0),D0
080052B0  D092      16869          add.l     (A2),D0
080052B2  2042      16870          move.l    D2,A0
080052B4  2140 0012 16871          move.l    D0,18(A0)
080052B8  600E      16872          bra.s     @ucos_ii_OSTmr_Link_4
                    16873   @ucos_ii_OSTmr_Link_3:
                    16874   ; } else {
                    16875   ; ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
080052BA  2042      16876          move.l    D2,A0
080052BC  2028 0016 16877          move.l    22(A0),D0
080052C0  D092      16878          add.l     (A2),D0
080052C2  2042      16879          move.l    D2,A0
080052C4  2140 0012 16880          move.l    D0,18(A0)
                    16881   @ucos_ii_OSTmr_Link_4:
                    16882   ; }
                    16883   ; }
                    16884   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
080052C8  2002      16885          move.l    D2,D0
080052CA  0680 0000 16886          add.l     #18,D0
080052CE  0012      
080052D0  2040      16887          move.l    D0,A0
080052D2  2F10      16888          move.l    (A0),-(A7)
080052D4  4878 0008 16889          pea       8
080052D8  4EB9 0800 16890          jsr       ULDIV
080052DC  5720      
080052DE  202F 0004 16891          move.l    4(A7),D0
080052E2  504F      16892          addq.w    #8,A7
080052E4  3D40 FFFE 16893          move.w    D0,-2(A6)
                    16894   ; pspoke = &OSTmrWheelTbl[spoke];
080052E8  41F9 0800 16895          lea       _OSTmrWheelTbl.L,A0
080052EC  10DA      
080052EE  302E FFFE 16896          move.w    -2(A6),D0
080052F2  C0BC 0000 16897          and.l     #65535,D0
080052F6  FFFF      
080052F8  E588      16898          lsl.l     #2,D0
080052FA  D1C0      16899          add.l     D0,A0
080052FC  2608      16900          move.l    A0,D3
                    16901   ; if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
080052FE  2043      16902          move.l    D3,A0
08005300  2010      16903          move.l    (A0),D0
08005302  6614      16904          bne.s     @ucos_ii_OSTmr_Link_5
                    16905   ; pspoke->OSTmrFirst   = ptmr;
08005304  2043      16906          move.l    D3,A0
08005306  2082      16907          move.l    D2,(A0)
                    16908   ; ptmr->OSTmrNext      = (OS_TMR *)0;
08005308  2042      16909          move.l    D2,A0
0800530A  42A8 000A 16910          clr.l     10(A0)
                    16911   ; pspoke->OSTmrEntries = 1u;
0800530E  2043      16912          move.l    D3,A0
08005310  317C 0001 16913          move.w    #1,4(A0)
08005314  0004      
08005316  601C      16914          bra.s     @ucos_ii_OSTmr_Link_6
                    16915   @ucos_ii_OSTmr_Link_5:
                    16916   ; } else {
                    16917   ; ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
08005318  2043      16918          move.l    D3,A0
0800531A  2810      16919          move.l    (A0),D4
                    16920   ; pspoke->OSTmrFirst   = ptmr;
0800531C  2043      16921          move.l    D3,A0
0800531E  2082      16922          move.l    D2,(A0)
                    16923   ; ptmr->OSTmrNext      = (void *)ptmr1;
08005320  2042      16924          move.l    D2,A0
08005322  2144 000A 16925          move.l    D4,10(A0)
                    16926   ; ptmr1->OSTmrPrev     = (void *)ptmr;
08005326  2044      16927          move.l    D4,A0
08005328  2142 000E 16928          move.l    D2,14(A0)
                    16929   ; pspoke->OSTmrEntries++;
0800532C  2003      16930          move.l    D3,D0
0800532E  5880      16931          addq.l    #4,D0
08005330  2040      16932          move.l    D0,A0
08005332  5250      16933          addq.w    #1,(A0)
                    16934   @ucos_ii_OSTmr_Link_6:
                    16935   ; }
                    16936   ; ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
08005334  2042      16937          move.l    D2,A0
08005336  42A8 000E 16938          clr.l     14(A0)
0800533A  4CDF 041C 16939          movem.l   (A7)+,D2/D3/D4/A2
0800533E  4E5E      16940          unlk      A6
08005340  4E75      16941          rts
                    16942   ; }
                    16943   ; #endif
                    16944   ; /*$PAGE*/
                    16945   ; /*
                    16946   ; *********************************************************************************************************
                    16947   ; *                                 REMOVE A TIMER FROM THE TIMER WHEEL
                    16948   ; *
                    16949   ; * Description: This function is called to remove the timer from the timer wheel.
                    16950   ; *
                    16951   ; * Arguments  : ptmr          Is a pointer to the timer to remove.
                    16952   ; *
                    16953   ; * Returns    : none
                    16954   ; *********************************************************************************************************
                    16955   ; */
                    16956   ; #if OS_TMR_EN > 0u
                    16957   ; static  void  OSTmr_Unlink (OS_TMR *ptmr)
                    16958   ; {
                    16959   @ucos_ii_OSTmr_Unlink:
08005342  4E56 FFFC 16960          link      A6,#-4
08005346  48E7 3C00 16961          movem.l   D2/D3/D4/D5,-(A7)
0800534A  242E 0008 16962          move.l    8(A6),D2
                    16963   ; OS_TMR        *ptmr1;
                    16964   ; OS_TMR        *ptmr2;
                    16965   ; OS_TMR_WHEEL  *pspoke;
                    16966   ; INT16U         spoke;
                    16967   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
0800534E  2002      16968          move.l    D2,D0
08005350  0680 0000 16969          add.l     #18,D0
08005354  0012      
08005356  2040      16970          move.l    D0,A0
08005358  2F10      16971          move.l    (A0),-(A7)
0800535A  4878 0008 16972          pea       8
0800535E  4EB9 0800 16973          jsr       ULDIV
08005362  5720      
08005364  202F 0004 16974          move.l    4(A7),D0
08005368  504F      16975          addq.w    #8,A7
0800536A  3D40 FFFE 16976          move.w    D0,-2(A6)
                    16977   ; pspoke = &OSTmrWheelTbl[spoke];
0800536E  41F9 0800 16978          lea       _OSTmrWheelTbl.L,A0
08005372  10DA      
08005374  302E FFFE 16979          move.w    -2(A6),D0
08005378  C0BC 0000 16980          and.l     #65535,D0
0800537C  FFFF      
0800537E  E588      16981          lsl.l     #2,D0
08005380  D1C0      16982          add.l     D0,A0
08005382  2A08      16983          move.l    A0,D5
                    16984   ; if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
08005384  2045      16985          move.l    D5,A0
08005386  B490      16986          cmp.l     (A0),D2
08005388  6616      16987          bne.s     @ucos_ii_OSTmr_Unlink_1
                    16988   ; ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
0800538A  2042      16989          move.l    D2,A0
0800538C  2628 000A 16990          move.l    10(A0),D3
                    16991   ; pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
08005390  2045      16992          move.l    D5,A0
08005392  2083      16993          move.l    D3,(A0)
                    16994   ; if (ptmr1 != (OS_TMR *)0) {
08005394  4A83      16995          tst.l     D3
08005396  6706      16996          beq.s     @ucos_ii_OSTmr_Unlink_3
                    16997   ; ptmr1->OSTmrPrev = (void *)0;
08005398  2043      16998          move.l    D3,A0
0800539A  42A8 000E 16999          clr.l     14(A0)
                    17000   @ucos_ii_OSTmr_Unlink_3:
0800539E  601C      17001          bra.s     @ucos_ii_OSTmr_Unlink_5
                    17002   @ucos_ii_OSTmr_Unlink_1:
                    17003   ; }
                    17004   ; } else {
                    17005   ; ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
080053A0  2042      17006          move.l    D2,A0
080053A2  2628 000E 17007          move.l    14(A0),D3
                    17008   ; ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
080053A6  2042      17009          move.l    D2,A0
080053A8  2828 000A 17010          move.l    10(A0),D4
                    17011   ; ptmr1->OSTmrNext = ptmr2;
080053AC  2043      17012          move.l    D3,A0
080053AE  2144 000A 17013          move.l    D4,10(A0)
                    17014   ; if (ptmr2 != (OS_TMR *)0) {
080053B2  4A84      17015          tst.l     D4
080053B4  6706      17016          beq.s     @ucos_ii_OSTmr_Unlink_5
                    17017   ; ptmr2->OSTmrPrev = (void *)ptmr1;
080053B6  2044      17018          move.l    D4,A0
080053B8  2143 000E 17019          move.l    D3,14(A0)
                    17020   @ucos_ii_OSTmr_Unlink_5:
                    17021   ; }
                    17022   ; }
                    17023   ; ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
080053BC  2042      17024          move.l    D2,A0
080053BE  117C 0001 17025          move.b    #1,35(A0)
080053C2  0023      
                    17026   ; ptmr->OSTmrNext  = (void *)0;
080053C4  2042      17027          move.l    D2,A0
080053C6  42A8 000A 17028          clr.l     10(A0)
                    17029   ; ptmr->OSTmrPrev  = (void *)0;
080053CA  2042      17030          move.l    D2,A0
080053CC  42A8 000E 17031          clr.l     14(A0)
                    17032   ; pspoke->OSTmrEntries--;
080053D0  2005      17033          move.l    D5,D0
080053D2  5880      17034          addq.l    #4,D0
080053D4  2040      17035          move.l    D0,A0
080053D6  5350      17036          subq.w    #1,(A0)
080053D8  4CDF 003C 17037          movem.l   (A7)+,D2/D3/D4/D5
080053DC  4E5E      17038          unlk      A6
080053DE  4E75      17039          rts
                    17040   ; }
                    17041   ; #endif
                    17042   ; /*$PAGE*/
                    17043   ; /*
                    17044   ; *********************************************************************************************************
                    17045   ; *                                        TIMER MANAGEMENT TASK
                    17046   ; *
                    17047   ; * Description: This task is created by OSTmrInit().
                    17048   ; *
                    17049   ; * Arguments  : none
                    17050   ; *
                    17051   ; * Returns    : none
                    17052   ; *********************************************************************************************************
                    17053   ; */
                    17054   ; #if OS_TMR_EN > 0u
                    17055   ; static  void  OSTmr_Task (void *p_arg)
                    17056   ; {
                    17057   @ucos_ii_OSTmr_Task:
080053E0  4E56 FFF4 17058          link      A6,#-12
080053E4  48E7 3020 17059          movem.l   D2/D3/A2,-(A7)
080053E8  45F9 0800 17060          lea       _OSTmrTime.L,A2
080053EC  0D8A      
                    17061   ; INT8U            err;
                    17062   ; OS_TMR          *ptmr;
                    17063   ; OS_TMR          *ptmr_next;
                    17064   ; OS_TMR_CALLBACK  pfnct;
                    17065   ; OS_TMR_WHEEL    *pspoke;
                    17066   ; INT16U           spoke;
                    17067   ; p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
                    17068   ; for (;;) {
                    17069   @ucos_ii_OSTmr_Task_1:
                    17070   ; OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
080053EE  486E FFF5 17071          pea       -11(A6)
080053F2  42A7      17072          clr.l     -(A7)
080053F4  2F39 0800 17073          move.l    _OSTmrSemSignal.L,-(A7)
080053F8  0D92      
080053FA  4EB9 0800 17074          jsr       _OSSemPend
080053FE  3970      
08005400  DEFC 000C 17075          add.w     #12,A7
                    17076   ; OSSchedLock();
08005404  4EB9 0800 17077          jsr       _OSSchedLock
08005408  07D6      
                    17078   ; OSTmrTime++;                                             /* Increment the current time                        */
0800540A  5292      17079          addq.l    #1,(A2)
                    17080   ; spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
0800540C  2F12      17081          move.l    (A2),-(A7)
0800540E  4878 0008 17082          pea       8
08005412  4EB9 0800 17083          jsr       ULDIV
08005416  5720      
08005418  202F 0004 17084          move.l    4(A7),D0
0800541C  504F      17085          addq.w    #8,A7
0800541E  3D40 FFFE 17086          move.w    D0,-2(A6)
                    17087   ; pspoke = &OSTmrWheelTbl[spoke];
08005422  41F9 0800 17088          lea       _OSTmrWheelTbl.L,A0
08005426  10DA      
08005428  302E FFFE 17089          move.w    -2(A6),D0
0800542C  C0BC 0000 17090          and.l     #65535,D0
08005430  FFFF      
08005432  E588      17091          lsl.l     #2,D0
08005434  D1C0      17092          add.l     D0,A0
08005436  2D48 FFFA 17093          move.l    A0,-6(A6)
                    17094   ; ptmr   = pspoke->OSTmrFirst;
0800543A  206E FFFA 17095          move.l    -6(A6),A0
0800543E  2410      17096          move.l    (A0),D2
                    17097   ; while (ptmr != (OS_TMR *)0) {
                    17098   @ucos_ii_OSTmr_Task_4:
08005440  4A82      17099          tst.l     D2
08005442  6700 0062 17100          beq       @ucos_ii_OSTmr_Task_6
                    17101   ; ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
08005446  2042      17102          move.l    D2,A0
08005448  2D68 000A 17103          move.l    10(A0),-10(A6)
0800544C  FFF6      
                    17104   ; /* ... timer could get unlinked from the wheel.      */
                    17105   ; if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
0800544E  2042      17106          move.l    D2,A0
08005450  2012      17107          move.l    (A2),D0
08005452  B0A8 0012 17108          cmp.l     18(A0),D0
08005456  6600 0048 17109          bne       @ucos_ii_OSTmr_Task_11
                    17110   ; OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
0800545A  2F02      17111          move.l    D2,-(A7)
0800545C  4EB9 0800 17112          jsr       @ucos_ii_OSTmr_Unlink
08005460  5342      
08005462  584F      17113          addq.w    #4,A7
                    17114   ; if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
08005464  2042      17115          move.l    D2,A0
08005466  1028 0022 17116          move.b    34(A0),D0
0800546A  0C00 0002 17117          cmp.b     #2,D0
0800546E  6610      17118          bne.s     @ucos_ii_OSTmr_Task_9
                    17119   ; OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
08005470  4878 0001 17120          pea       1
08005474  2F02      17121          move.l    D2,-(A7)
08005476  4EB9 0800 17122          jsr       @ucos_ii_OSTmr_Link
0800547A  526E      
0800547C  504F      17123          addq.w    #8,A7
0800547E  6008      17124          bra.s     @ucos_ii_OSTmr_Task_10
                    17125   @ucos_ii_OSTmr_Task_9:
                    17126   ; } else {
                    17127   ; ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
08005480  2042      17128          move.l    D2,A0
08005482  117C 0002 17129          move.b    #2,35(A0)
08005486  0023      
                    17130   @ucos_ii_OSTmr_Task_10:
                    17131   ; }
                    17132   ; pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
08005488  2042      17133          move.l    D2,A0
0800548A  2628 0002 17134          move.l    2(A0),D3
                    17135   ; if (pfnct != (OS_TMR_CALLBACK)0) {
0800548E  4A83      17136          tst.l     D3
08005490  670E      17137          beq.s     @ucos_ii_OSTmr_Task_11
                    17138   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
08005492  2042      17139          move.l    D2,A0
08005494  2F28 0006 17140          move.l    6(A0),-(A7)
08005498  2F02      17141          move.l    D2,-(A7)
0800549A  2043      17142          move.l    D3,A0
0800549C  4E90      17143          jsr       (A0)
0800549E  504F      17144          addq.w    #8,A7
                    17145   @ucos_ii_OSTmr_Task_11:
                    17146   ; }
                    17147   ; }
                    17148   ; ptmr = ptmr_next;
080054A0  242E FFF6 17149          move.l    -10(A6),D2
080054A4  609A      17150          bra       @ucos_ii_OSTmr_Task_4
                    17151   @ucos_ii_OSTmr_Task_6:
                    17152   ; }
                    17153   ; OSSchedUnlock();
080054A6  4EB9 0800 17154          jsr       _OSSchedUnlock
080054AA  0806      
080054AC  6000 FF40 17155          bra       @ucos_ii_OSTmr_Task_1
                    17156   ; /*
                    17157   ; *********************************************************************************************************
                    17158   ; *                                                uC/OS-II
                    17159   ; *                                          The Real-Time Kernel
                    17160   ; *
                    17161   ; *                              (c) Copyright 1992-2009, Micrium, Weston, FL
                    17162   ; *                                           All Rights Reserved
                    17163   ; *
                    17164   ; * File    : uCOS_II.C
                    17165   ; * By      : Jean J. Labrosse
                    17166   ; * Version : V2.91
                    17167   ; *
                    17168   ; * LICENSING TERMS:
                    17169   ; * ---------------
                    17170   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
                    17171   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
                    17172   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience 
                    17173   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
                    17174   ; * licensing fee.
                    17175   ; *********************************************************************************************************
                    17176   ; */
                    17177   ; #define  OS_GLOBALS                           /* Declare GLOBAL variables                              */
                    17178   ; #include <ucos_ii.h>
                    17179   ; #define  OS_MASTER_FILE                       /* Prevent the following files from including includes.h */
                    17180   ; #include <os_core.c>
                    17181   ; #include <os_flag.c>
                    17182   ; #include <os_mbox.c>
                    17183   ; #include <os_mem.c>
                    17184   ; #include <os_mutex.c>
                    17185   ; #include <os_q.c>
                    17186   ; #include <os_sem.c>
                    17187   ; #include <os_task.c>
                    17188   ; #include <os_time.c>
                    17189   ; #include <os_tmr.c>
                    17190   ; C:\IDE68K\UCOSII\BIOS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17191   ; #include <Bios.h>
                    17192   ; /*
                    17193   ; **  These basic IO routines are designed to handle input and output of characters
                    17194   ; **  via the serial port to the console of hyperternal
                    17195   ; **
                    17196   ; **  You need to include this code into your projects, either as a source file, or copy into your code
                    17197   ; */
                    17198   ; // things that need to be done at initialisation/boot include
                    17199   ; // 1) initialise serial port and LCD display
                    17200   ; // 2) initialise the LCD display
                    17201   ; // 3) install the trap handler for a context switch (trap0)
                    17202   ; // 4) install the TickISR for level 3 IRQ
                    17203   ; // these actions can be performed in OSInitHookBegin() in file OS_CPU_C.c (one the Port files)
                    17204   ; /*********************************************************************************************
                    17205   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    17206   ; *********************************************************************************************/
                    17207   ; void Init_RS232(void)
                    17208   ; {
                    17209   _Init_RS232:
                    17210   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
080054B0  13FC 0015 17211          move.b    #21,4194368
080054B4  0040 0040 
                    17212   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
080054B8  13FC 0001 17213          move.b    #1,4194372
080054BC  0040 0044 
080054C0  4E75      17214          rts
                    17215   ; }
                    17216   ; int kbhit(void)
                    17217   ; {
                    17218   _kbhit:
                    17219   ; if(((char)(RS232_Status) & (char)(0x02)) == (char)(0x02))    // wait for Tx bit in status register to be '1'
080054C2  1039 0040 17220          move.b    4194368,D0
080054C6  0040      
080054C8  C03C 0002 17221          and.b     #2,D0
080054CC  0C00 0002 17222          cmp.b     #2,D0
080054D0  6604      17223          bne.s     kbhit_1
                    17224   ; return 1 ;
080054D2  7001      17225          moveq     #1,D0
080054D4  6002      17226          bra.s     kbhit_3
                    17227   kbhit_1:
                    17228   ; else
                    17229   ; return 0 ;
080054D6  4280      17230          clr.l     D0
                    17231   kbhit_3:
080054D8  4E75      17232          rts
                    17233   ; }
                    17234   ; /*********************************************************************************************************
                    17235   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    17236   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    17237   ; **  to allow the board to communicate with HyperTerminal Program
                    17238   ; **
                    17239   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    17240   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    17241   ; **  call _putch() also
                    17242   ; *********************************************************************************************************/
                    17243   ; int _putch( int c)
                    17244   ; {
                    17245   __putch:
080054DA  4E56 0000 17246          link      A6,#0
                    17247   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    17248   _putch_1:
080054DE  1039 0040 17249          move.b    4194368,D0
080054E2  0040      
080054E4  C03C 0002 17250          and.b     #2,D0
080054E8  0C00 0002 17251          cmp.b     #2,D0
080054EC  6702      17252          beq.s     _putch_3
080054EE  60EE      17253          bra       _putch_1
                    17254   _putch_3:
                    17255   ; ;
                    17256   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
080054F0  202E 0008 17257          move.l    8(A6),D0
080054F4  C03C 007F 17258          and.b     #127,D0
080054F8  13C0 0040 17259          move.b    D0,4194370
080054FC  0042      
                    17260   ; return c ;                                              // putchar() expects the character to be returned
080054FE  202E 0008 17261          move.l    8(A6),D0
08005502  4E5E      17262          unlk      A6
08005504  4E75      17263          rts
                    17264   ; }
                    17265   ; /*********************************************************************************************************
                    17266   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    17267   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    17268   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    17269   ; **
                    17270   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                    17271   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                    17272   ; **  call _getch() also
                    17273   ; *********************************************************************************************************/
                    17274   ; int _getch( void )
                    17275   ; {
                    17276   __getch:
08005506  2F02      17277          move.l    D2,-(A7)
                    17278   ; int c ;
                    17279   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    17280   _getch_1:
08005508  1039 0040 17281          move.b    4194368,D0
0800550C  0040      
0800550E  C03C 0001 17282          and.b     #1,D0
08005512  0C00 0001 17283          cmp.b     #1,D0
08005516  6702      17284          beq.s     _getch_3
08005518  60EE      17285          bra       _getch_1
                    17286   _getch_3:
                    17287   ; ;
                    17288   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
0800551A  1039 0040 17289          move.b    4194370,D0
0800551E  0042      
08005520  C0BC 0000 17290          and.l     #255,D0
08005524  00FF      
08005526  C0BC 0000 17291          and.l     #127,D0
0800552A  007F      
0800552C  2400      17292          move.l    D0,D2
                    17293   ; _putch(c);
0800552E  2F02      17294          move.l    D2,-(A7)
08005530  4EB9 0800 17295          jsr       __putch
08005534  54DA      
08005536  584F      17296          addq.w    #4,A7
                    17297   ; return c ;
08005538  2002      17298          move.l    D2,D0
0800553A  241F      17299          move.l    (A7)+,D2
0800553C  4E75      17300          rts
                    17301   ; }
                    17302   ; /************************************************************************************
                    17303   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                    17304   ; ************************************************************************************/
                    17305   ; void Wait1ms(void)
                    17306   ; {
                    17307   _Wait1ms:
0800553E  2F02      17308          move.l    D2,-(A7)
                    17309   ; long int  i ;
                    17310   ; for(i = 0; i < 1000; i ++)
08005540  4282      17311          clr.l     D2
                    17312   Wait1ms_1:
08005542  0C82 0000 17313          cmp.l     #1000,D2
08005546  03E8      
08005548  6C04      17314          bge.s     Wait1ms_3
0800554A  5282      17315          addq.l    #1,D2
0800554C  60F4      17316          bra       Wait1ms_1
                    17317   Wait1ms_3:
0800554E  241F      17318          move.l    (A7)+,D2
08005550  4E75      17319          rts
                    17320   ; ;
                    17321   ; }
                    17322   ; /************************************************************************************
                    17323   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                    17324   ; **************************************************************************************/
                    17325   ; void Wait3ms(void)
                    17326   ; {
                    17327   _Wait3ms:
08005552  2F02      17328          move.l    D2,-(A7)
                    17329   ; int i ;
                    17330   ; for(i = 0; i < 3; i++)
08005554  4282      17331          clr.l     D2
                    17332   Wait3ms_1:
08005556  0C82 0000 17333          cmp.l     #3,D2
0800555A  0003      
0800555C  6C0A      17334          bge.s     Wait3ms_3
                    17335   ; Wait1ms() ;
0800555E  4EB9 0800 17336          jsr       _Wait1ms
08005562  553E      
08005564  5282      17337          addq.l    #1,D2
08005566  60EE      17338          bra       Wait3ms_1
                    17339   Wait3ms_3:
08005568  241F      17340          move.l    (A7)+,D2
0800556A  4E75      17341          rts
                    17342   ; }
                    17343   ; /*********************************************************************************************
                    17344   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                    17345   ; *********************************************************************************************/
                    17346   ; void Init_LCD(void)
                    17347   ; {
                    17348   _Init_LCD:
                    17349   ; LCDcommand = (char)(0x0c) ;
0800556C  13FC 000C 17350          move.b    #12,4194336
08005570  0040 0020 
                    17351   ; Wait3ms() ;
08005574  4EB9 0800 17352          jsr       _Wait3ms
08005578  5552      
                    17353   ; LCDcommand = (char)(0x38) ;
0800557A  13FC 0038 17354          move.b    #56,4194336
0800557E  0040 0020 
                    17355   ; Wait3ms() ;
08005582  4EB9 0800 17356          jsr       _Wait3ms
08005586  5552      
08005588  4E75      17357          rts
                    17358   ; }
                    17359   ; /******************************************************************************
                    17360   ; *subroutine to output a single character held in d1 to the LCD display
                    17361   ; *it is assumed the character is an ASCII code and it will be displayed at the
                    17362   ; *current cursor position
                    17363   ; *******************************************************************************/
                    17364   ; void Outchar(int c)
                    17365   ; {
                    17366   _Outchar:
0800558A  4E56 0000 17367          link      A6,#0
                    17368   ; LCDdata = (char)(c);
0800558E  202E 0008 17369          move.l    8(A6),D0
08005592  13C0 0040 17370          move.b    D0,4194338
08005596  0022      
                    17371   ; Wait1ms() ;
08005598  4EB9 0800 17372          jsr       _Wait1ms
0800559C  553E      
0800559E  4E5E      17373          unlk      A6
080055A0  4E75      17374          rts
                    17375   ; }
                    17376   ; /**********************************************************************************
                    17377   ; *subroutine to output a message at the current cursor position of the LCD display
                    17378   ; ************************************************************************************/
                    17379   ; void OutMess(char *theMessage)
                    17380   ; {
                    17381   _OutMess:
080055A2  4E56 FFFC 17382          link      A6,#-4
                    17383   ; char c ;
                    17384   ; while((c = *theMessage++) != (char)(0))
                    17385   OutMess_1:
080055A6  206E 0008 17386          move.l    8(A6),A0
080055AA  52AE 0008 17387          addq.l    #1,8(A6)
080055AE  1D50 FFFF 17388          move.b    (A0),-1(A6)
080055B2  1010      17389          move.b    (A0),D0
080055B4  6714      17390          beq.s     OutMess_3
                    17391   ; Outchar(c) ;
080055B6  122E FFFF 17392          move.b    -1(A6),D1
080055BA  4881      17393          ext.w     D1
080055BC  48C1      17394          ext.l     D1
080055BE  2F01      17395          move.l    D1,-(A7)
080055C0  4EB9 0800 17396          jsr       _Outchar
080055C4  558A      
080055C6  584F      17397          addq.w    #4,A7
080055C8  60DC      17398          bra       OutMess_1
                    17399   OutMess_3:
080055CA  4E5E      17400          unlk      A6
080055CC  4E75      17401          rts
                    17402   ; }
                    17403   ; /******************************************************************************
                    17404   ; *subroutine to clear the line by issuing 24 space characters
                    17405   ; *******************************************************************************/
                    17406   ; void Clearln(void)
                    17407   ; {
                    17408   _Clearln:
080055CE  2F02      17409          move.l    D2,-(A7)
                    17410   ; unsigned char i ;
                    17411   ; for(i = 0; i < 24; i ++)
080055D0  4202      17412          clr.b     D2
                    17413   Clearln_1:
080055D2  0C02 0018 17414          cmp.b     #24,D2
080055D6  6410      17415          bhs.s     Clearln_3
                    17416   ; Outchar(' ') ;  /* write a space char to the LCD display */
080055D8  4878 0020 17417          pea       32
080055DC  4EB9 0800 17418          jsr       _Outchar
080055E0  558A      
080055E2  584F      17419          addq.w    #4,A7
080055E4  5202      17420          addq.b    #1,D2
080055E6  60EA      17421          bra       Clearln_1
                    17422   Clearln_3:
080055E8  241F      17423          move.l    (A7)+,D2
080055EA  4E75      17424          rts
                    17425   ; }
                    17426   ; /******************************************************************************
                    17427   ; *subroutine to move the cursor to the start of line 1 and clear that line
                    17428   ; *******************************************************************************/
                    17429   ; void Oline0(char *theMessage)
                    17430   ; {
                    17431   _Oline0:
080055EC  4E56 0000 17432          link      A6,#0
                    17433   ; LCDcommand = (char)(0x80) ;
080055F0  13FC 0080 17434          move.b    #128,4194336
080055F4  0040 0020 
                    17435   ; Wait3ms();
080055F8  4EB9 0800 17436          jsr       _Wait3ms
080055FC  5552      
                    17437   ; Clearln() ;
080055FE  4EB9 0800 17438          jsr       _Clearln
08005602  55CE      
                    17439   ; LCDcommand = (char)(0x80) ;
08005604  13FC 0080 17440          move.b    #128,4194336
08005608  0040 0020 
                    17441   ; Wait3ms() ;
0800560C  4EB9 0800 17442          jsr       _Wait3ms
08005610  5552      
                    17443   ; OutMess(theMessage) ;
08005612  2F2E 0008 17444          move.l    8(A6),-(A7)
08005616  4EB9 0800 17445          jsr       _OutMess
0800561A  55A2      
0800561C  584F      17446          addq.w    #4,A7
0800561E  4E5E      17447          unlk      A6
08005620  4E75      17448          rts
                    17449   ; }
                    17450   ; /******************************************************************************
                    17451   ; *subroutine to move the cursor to the start of line 2 and clear that line
                    17452   ; *******************************************************************************/
                    17453   ; void Oline1(char *theMessage)
                    17454   ; {
                    17455   _Oline1:
08005622  4E56 0000 17456          link      A6,#0
                    17457   ; LCDcommand = (char)(0xC0) ;
08005626  13FC 00C0 17458          move.b    #192,4194336
0800562A  0040 0020 
                    17459   ; Wait3ms();
0800562E  4EB9 0800 17460          jsr       _Wait3ms
08005632  5552      
                    17461   ; Clearln() ;
08005634  4EB9 0800 17462          jsr       _Clearln
08005638  55CE      
                    17463   ; LCDcommand = (char)(0xC0) ;
0800563A  13FC 00C0 17464          move.b    #192,4194336
0800563E  0040 0020 
                    17465   ; Wait3ms() ;
08005642  4EB9 0800 17466          jsr       _Wait3ms
08005646  5552      
                    17467   ; OutMess(theMessage) ;
08005648  2F2E 0008 17468          move.l    8(A6),-(A7)
0800564C  4EB9 0800 17469          jsr       _OutMess
08005650  55A2      
08005652  584F      17470          addq.w    #4,A7
08005654  4E5E      17471          unlk      A6
08005656  4E75      17472          rts
                    17473   ; }
                    17474   ; /*********************************************************************************
                    17475   ; ** Timer ISR
                    17476   ; **********************************************************************************/
                    17477   ; void Timer_ISR(void)
                    17478   ; {
                    17479   _Timer_ISR:
                    17480   ; if(Timer1Status == 1) {       // Did Timer 1 produce the Interrupt?
08005658  1039 0040 17481          move.b    4194354,D0
0800565C  0032      
0800565E  0C00 0001 17482          cmp.b     #1,D0
08005662  6608      17483          bne.s     Timer_ISR_1
                    17484   ; Timer1Control = 3;      	// if so clear interrupt and restart timer
08005664  13FC 0003 17485          move.b    #3,4194354
08005668  0040 0032 
                    17486   Timer_ISR_1:
0800566C  4E75      17487          rts
                    17488   ; }
                    17489   ; }
                    17490   ; /**********************************************************************************
                    17491   ; ** Timer Initialisation Routine
                    17492   ; **********************************************************************************/
                    17493   ; void Timer1_Init(void)
                    17494   ; {
                    17495   _Timer1_Init:
                    17496   ; Timer1Data = 0x03;		// program 100 hz time delay into timer 1.
0800566E  13FC 0003 17497          move.b    #3,4194352
08005672  0040 0030 
                    17498   ; /*
                    17499   ; ** timer driven off 25Mhz clock so program value so that it counts down in 0.01 secs
                    17500   ; ** the example 0x03 above is loaded into top 8 bits of a 24 bit timer so reads as
                    17501   ; ** 0x03FFFF a value of 0x03 would be 262,143/25,000,000, so is close to 1/100th sec
                    17502   ; **
                    17503   ; **
                    17504   ; ** Now write binary 00000011 to timer control register:
                    17505   ; **	Bit0 = 1 (enable interrupt from that timer)
                    17506   ; **	Bit 1 = 1 enable counting
                    17507   ; */
                    17508   ; Timer1Control = 3;
08005676  13FC 0003 17509          move.b    #3,4194354
0800567A  0040 0032 
0800567E  4E75      17510          rts
                    17511   ; }
                    17512   ; /*********************************************************************************************************************************
                    17513   ; **  IMPORTANT FUNCTION
                    17514   ; **  This function installs an exception (interrupt) handler so you can capture and deal with any 68000 exception in your program
                    17515   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    17516   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    17517   ; **  Calling this function allows you to deal with Interrupts for example
                    17518   ; **
                    17519   ; **	e.g. to install the function 'void Timer_ISR()' (see above in this program) to deal with interrupts from the timer do this
                    17520   ; **
                    17521   ; **	InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-8 on level 3 IRQ (exception number 27 on 68k)
                    17522   ; **
                    17523   ; **	see main below for other examples
                    17524   ; ***********************************************************************************************************************************/
                    17525   ; /*
                    17526   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    17527   ; {
                    17528   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
                    17529   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
                    17530   ; }
                    17531   ; */
                    17532   ULMUL:
08005680  4E56 0000 17533          link    A6,#0
08005684  48E7 C000 17534          movem.l D0/D1,-(A7)
08005688  222E 0008 17535          move.l  8(A6),D1
0800568C  202E 000C 17536          move.l  12(A6),D0
08005690  602C      17537          bra.s   lmul_3
                    17538   LMUL:
08005692  4E56 0000 17539          link    A6,#0
08005696  48E7 C000 17540          movem.l D0/D1,-(A7)
0800569A  222E 0008 17541          move.l  8(A6),D1
0800569E  202E 000C 17542          move.l  12(A6),D0
080056A2  4A80      17543          tst.l   D0
080056A4  6A0A      17544          bpl.s   lmul_1
080056A6  4480      17545          neg.l   D0
080056A8  4A81      17546          tst.l   D1
080056AA  6A0A      17547          bpl.s   lmul_2
080056AC  4481      17548          neg.l   D1
080056AE  600E      17549          bra.s   lmul_3
                    17550   lmul_1:
080056B0  4A81      17551          tst.l   D1
080056B2  6A0A      17552          bpl.s   lmul_3
080056B4  4481      17553          neg.l   D1
                    17554   lmul_2:
080056B6  6114      17555          bsr.s   domul
080056B8  4481      17556          neg.l   D1
080056BA  4080      17557          negx.l  D0
080056BC  6002      17558          bra.s   lmul_4
                    17559   lmul_3:
080056BE  610C      17560          bsr.s   domul
                    17561   lmul_4:
080056C0  2D41 0008 17562          move.l  D1,8(A6)
080056C4  4CDF 0003 17563          movem.l (A7)+,D0/D1
080056C8  4E5E      17564          unlk    A6
080056CA  4E75      17565          rts
                    17566   domul:
080056CC  0C81 0000 17567          cmpi.l  #$FFFF,D1
080056D0  FFFF      
080056D2  620C      17568          bhi.s   domul_1
080056D4  0C80 0000 17569          cmpi.l  #$FFFF,D0
080056D8  FFFF      
080056DA  620E      17570          bhi.s   domul_2
080056DC  C2C0      17571          mulu    D0,D1
080056DE  4E75      17572          rts
                    17573   domul_1:
080056E0  0C80 0000 17574          cmpi.l  #$FFFF,D0
080056E4  FFFF      
080056E6  6218      17575          bhi.s   domul_4
080056E8  6002      17576          bra.s   domul_3
                    17577   domul_2
080056EA  C141      17578          exg     D0,D1
                    17579   domul_3:
080056EC  2F02      17580          move.l  D2,-(A7)
080056EE  2401      17581          move.l  D1,D2
080056F0  4842      17582          swap    D2
080056F2  C2C0      17583          mulu    D0,D1
080056F4  C4C0      17584          mulu    D0,D2
080056F6  4842      17585          swap    D2
080056F8  4242      17586          clr.w   D2
080056FA  D282      17587          add.l   D2,D1
080056FC  241F      17588          move.l  (A7)+,D2
080056FE  4E75      17589          rts
                    17590   domul_4:
08005700  48E7 3000 17591          movem.l D2/D3,-(A7)
08005704  2401      17592          move.l  D1,D2
08005706  2601      17593          move.l  D1,D3
08005708  C2C0      17594          mulu    D0,D1
0800570A  4842      17595          swap    D2
0800570C  C4C0      17596          mulu    D0,D2
0800570E  4840      17597          swap    D0
08005710  C6C0      17598          mulu    D0,D3
08005712  D483      17599          add.l   D3,D2
08005714  4842      17600          swap    D2
08005716  4242      17601          clr.w   D2
08005718  D282      17602          add.l   D2,D1
0800571A  4CDF 000C 17603          movem.l (A7)+,D2/D3
0800571E  4E75      17604          rts
                    17605   ULDIV:
08005720  4E56 0000 17606          link    A6,#0
08005724  48E7 C000 17607          movem.l D0/D1,-(A7)
08005728  222E 0008 17608          move.l  8(A6),D1
0800572C  202E 000C 17609          move.l  12(A6),D0
08005730  6036      17610          bra.s   ldiv_3
                    17611   LDIV:
08005732  4E56 0000 17612          link    A6,#0
08005736  48E7 C000 17613          movem.l D0/D1,-(A7)
0800573A  222E 0008 17614          move.l  8(A6),D1
0800573E  202E 000C 17615          move.l  12(A6),D0
08005742  4A80      17616          tst.l   D0
08005744  6A0E      17617          bpl.s   ldiv_1
08005746  4480      17618          neg.l   D0
08005748  4A81      17619          tst.l   D1
0800574A  6A14      17620          bpl.s   ldiv_2
0800574C  4481      17621          neg.l   D1
0800574E  612A      17622          bsr.s   dodiv
08005750  4481      17623          neg.l   D1
08005752  6016      17624          bra.s   ldiv_4
                    17625   ldiv_1:
08005754  4A81      17626          tst.l   D1
08005756  6A10      17627          bpl.s   ldiv_3
08005758  4481      17628          neg.l   D1
0800575A  611E      17629          bsr.s   dodiv
0800575C  4480      17630          neg.l   D0
0800575E  600A      17631          bra.s   ldiv_4
                    17632   ldiv_2:
08005760  6118      17633          bsr.s   dodiv
08005762  4480      17634          neg.l   D0
08005764  4481      17635          neg.l   D1
08005766  6002      17636          bra.s   ldiv_4
                    17637   ldiv_3:
08005768  6110      17638          bsr.s   dodiv
                    17639   ldiv_4:
0800576A  2D40 0008 17640          move.l  D0,8(A6)
0800576E  2D41 000C 17641          move.l  D1,12(A6)
08005772  4CDF 0003 17642          movem.l (A7)+,D0/D1
08005776  4E5E      17643          unlk    A6
08005778  4E75      17644          rts
                    17645   dodiv:
0800577A  0C81 0000 17646          cmpi.l  #$FFFF,D1
0800577E  FFFF      
08005780  6236      17647          bhi.s   dodiv_2
08005782  0C80 0000 17648          cmpi.l  #$FFFF,D0
08005786  FFFF      
08005788  6210      17649          bhi.s   dodiv_1
0800578A  80C1      17650          divu    D1,D0
0800578C  2200      17651          move.l  D0,D1
0800578E  4241      17652          clr.w   D1
08005790  4841      17653          swap    D1
08005792  0280 0000 17654          andi.l  #$FFFF,D0
08005796  FFFF      
08005798  4E75      17655          rts
                    17656   dodiv_1:
0800579A  48A7 A000 17657          movem.w D0/D2,-(A7)
0800579E  4240      17658          clr.w   D0
080057A0  4840      17659          swap    D0
080057A2  80C1      17660          divu    D1,D0
080057A4  3400      17661          move.w  D0,D2
080057A6  301F      17662          move.w  (A7)+,D0
080057A8  80C1      17663          divu    D1,D0
080057AA  4840      17664          swap    D0
080057AC  4281      17665          clr.l   D1
080057AE  3200      17666          move.w  D0,D1
080057B0  3002      17667          move.w  D2,D0
080057B2  4840      17668          swap    D0
080057B4  341F      17669          move.w  (A7)+,D2
080057B6  4E75      17670          rts
                    17671   dodiv_2:
080057B8  48E7 3800 17672          movem.l D2/D3/D4,-(A7)
080057BC  2401      17673          move.l  D1,D2
080057BE  4242      17674          clr.w   D2
080057C0  4842      17675          swap    D2
080057C2  5282      17676          addq.l  #1,D2
080057C4  2600      17677          move.l  D0,D3
080057C6  2801      17678          move.l  D1,D4
080057C8  2202      17679          move.l  D2,D1
080057CA  61CE      17680          bsr.s   dodiv_1
080057CC  2204      17681          move.l  D4,D1
080057CE  82C2      17682          divu    D2,D1
080057D0  80C1      17683          divu    D1,D0
080057D2  0280 0000 17684          andi.l  #$FFFF,D0
080057D6  FFFF      
                    17685   dodiv_3:
080057D8  2204      17686          move.l  D4,D1
080057DA  2404      17687          move.l  D4,D2
080057DC  4842      17688          swap    D2
080057DE  C2C0      17689          mulu    D0,D1
080057E0  C4C0      17690          mulu    D0,D2
080057E2  4842      17691          swap    D2
080057E4  D282      17692          add.l   D2,D1
080057E6  9283      17693          sub.l   D3,D1
080057E8  620A      17694          bhi.s   dodiv_4
080057EA  4481      17695          neg.l   D1
080057EC  B881      17696          cmp.l   D1,D4
080057EE  6208      17697          bhi.s   dodiv_5
080057F0  5280      17698          addq.l  #1,D0
080057F2  60E4      17699          bra.s   dodiv_3
                    17700   dodiv_4:
080057F4  5380      17701          subq.l  #1,D0
080057F6  60E0      17702          bra.s   dodiv_3
                    17703   dodiv_5:
080057F8  4CDF 001C 17704          movem.l (A7)+,D2/D3/D4
080057FC  4E75      17705          rts
                    17706          section   const
          0800 57FE 17707   const      equ         *				; consts start whever the linker groups them, after the code section (but still in rom)
                    17708   
080057FE            17709                   align
                    17710   
                    17711   
                    17712   @ucos_ii_1:
080057FE  3F00      17713          dc.b      63,0
                    17714   @ucos_ii_2:
08005800  7543 2F4F 17715          dc.b      117,67,47,79,83,45,73,73,32,73,100,108,101,0
08005804  532D 4949 
08005808  2049 646C 
0800580C  6500      
                    17716   @ucos_ii_3:
0800580E  7543 2F4F 17717          dc.b      117,67,47,79,83,45,73,73,32,83,116,97,116,0
08005812  532D 4949 
08005816  2053 7461 
0800581A  7400      
                    17718   @ucos_ii_4:
0800581C  7543 2F4F 17719          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,76,111
08005820  532D 4949 
08005824  2054 6D72 
08005828  4C6F      
0800582A  636B 00   17720          dc.b      99,107,0
                    17721   @ucos_ii_5:
0800582E  7543 2F4F 17722          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,83,105
08005832  532D 4949 
08005836  2054 6D72 
0800583A  5369      
0800583C  676E 616C 17723          dc.b      103,110,97,108,0
08005840  00        
                    17724   @ucos_ii_6:
08005842  7543 2F4F 17725          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,0
08005846  532D 4949 
0800584A  2054 6D72 
0800584E  00        
                    17726   _OSUnMapTbl:
08005850  0000 0100 17727          dc.b      0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0
08005854  0200 0100 
08005858  0300 0100 
0800585C  0200 0100 
08005860  0400 0100 
08005864  0200      
08005866  0100 0300 17728          dc.b      1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0
0800586A  0100 0200 
0800586E  0100 0500 
08005872  0100 0200 
08005876  0100 0300 
0800587A  0100      
0800587C  0200 0100 17729          dc.b      2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0
08005880  0400 0100 
08005884  0200 0100 
08005888  0300 0100 
0800588C  0200 0100 
08005890  0600      
08005892  0100 0200 17730          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0
08005896  0100 0300 
0800589A  0100 0200 
0800589E  0100 0400 
080058A2  0100 0200 
080058A6  0100      
080058A8  0300 0100 17731          dc.b      3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0
080058AC  0200 0100 
080058B0  0500 0100 
080058B4  0200 0100 
080058B8  0300 0100 
080058BC  0200      
080058BE  0100 0400 17732          dc.b      1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0
080058C2  0100 0200 
080058C6  0100 0300 
080058CA  0100 0200 
080058CE  0100 0700 
080058D2  0100      
080058D4  0200 0100 17733          dc.b      2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0
080058D8  0300 0100 
080058DC  0200 0100 
080058E0  0400 0100 
080058E4  0200 0100 
080058E8  0300      
080058EA  0100 0200 17734          dc.b      1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
080058EE  0100 0500 
080058F2  0100 0200 
080058F6  0100 0300 
080058FA  0100 0200 
080058FE  0100      
08005900  0400 0100 17735          dc.b      4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0
08005904  0200 0100 
08005908  0300 0100 
0800590C  0200 0100 
08005910  0600 0100 
08005914  0200      
08005916  0100 0300 17736          dc.b      1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0
0800591A  0100 0200 
0800591E  0100 0400 
08005922  0100 0200 
08005926  0100 0300 
0800592A  0100      
0800592C  0200 0100 17737          dc.b      2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0
08005930  0500 0100 
08005934  0200 0100 
08005938  0300 0100 
0800593C  0200 0100 
08005940  0400      
08005942  0100 0200 17738          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0
08005946  0100 0300 
0800594A  0100 0200 
0800594E  0100      
                    17739          section   data
          0800 5950 17740   end_ROM    equ         *				; end of rom is wherever the last code/constant appears (* means here)
                    17741   
08000000            17742              org         RAM				; starting at address $08000000
          0800 0000 17743   begin_RAM  equ         *				; begin ram starts here
          0800 0000 17744   data       equ         *				; data starts here also
                    17745   
08000000            17746                   align
                    17747   
                    17748   *********************************************************************************************************************************************************
                    17749   * Section for Initialised Data (in theory should be copied to Ram at startup) but is part of program code as we copy whole program to ram at startup
                    17750   ********************************************************************************************************************************************************
                    17751   
          0800 0000 17752   DataStart       equ       *
                    17753   __ungetbuf:     ds.l      1                    ungetbuffer for stdio functions
********  **** ****  Error: Multiple defined symbol
08000004            17754   __allocp:       ds.l      1                    start of free memory block list
08000008            17755   __heap:         ds.l      1                    begin of free memory
                    17756   
                    17757   
                    17758          section   bss
          0800 000C 17759   bss        equ         *
                    17760   
                    17761   ;           org         $0B000000               Ram based vector table must be stored here otherwise InstallException Handler will not work
                    17762   
                    17763   *********************************************************************************************************
                    17764   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    17765   * install the exception handler using the C function InstallExceptionHandler()
                    17766   *********************************************************************************************************
                    17767   
0800000C            17768   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
08000010            17769   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
08000014            17770   VBusError        ds.l    1      storage for address of Bus Error Handler
08000018            17771   VAddressError    ds.l    1      storage for address of Address Error Handler
0800001C            17772   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
08000020            17773   VDividebyZero    ds.l    1      storage for address of divide by zero handler
08000024            17774   VCheck           ds.l    1      ditto
08000028            17775   VTrapV           ds.l    1      ditto
0800002C            17776   VPrivilege       ds.l    1      ditto
08000030            17777   VTrace           ds.l    1
08000034            17778   VLine1010emul    ds.l    1
08000038            17779   VLine1111emul    ds.l    1
0800003C            17780   VUnassigned1     ds.l    1
08000040            17781   VUnassigned2     ds.l    1
08000044            17782   VUnassigned3     ds.l    1
08000048            17783   VUninit_IRQ      ds.l    1
0800004C            17784   VUnassigned4     ds.l    1
08000050            17785   VUnassigned5     ds.l    1
08000054            17786   VUnassigned6     ds.l    1
08000058            17787   VUnassigned7     ds.l    1
0800005C            17788   VUnassigned8     ds.l    1
08000060            17789   VUnassigned9     ds.l    1
08000064            17790   VUnassigned10    ds.l    1
08000068            17791   VUnassigned11    ds.l    1
0800006C            17792   VSpuriousIRQ     ds.l    1
                    17793   
                    17794   * Interrupt handlers Vector 25-31
08000070            17795   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000074            17796   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000078            17797   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800007C            17798   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000080            17799   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000084            17800   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000088            17801   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    17802   
                    17803   * Trap Handler vectors 32-47
0800008C            17804   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000090            17805   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000094            17806   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000098            17807   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800009C            17808   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A0            17809   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A4            17810   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A8            17811   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000AC            17812   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B0            17813   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B4            17814   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B8            17815   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000BC            17816   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000C0            17817   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000C4            17818   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000C8            17819   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    17820   
                    17821   __ungetbuf:                            ; ungetbuffer for stdio functions
********  **** ****  Error: Multiple defined symbol
080000CC            17822              ds.l        1
                    17823   __timezone:                            ; difference, in seconds, between local time and UTC
080000D0            17824              ds.l        1
                    17825   __daylight:                            ; flag, '1' for daylight saving time, '0' for standard time.
080000D4            17826              ds.l        1
                    17827   __romsize:                             ; size of ROM used by program
080000D8            17828              ds.l        1
                    17829   __ramsize:                             ; size of RAM used by program
080000DC            17830              ds.l        1
                    17831   
080000E0            17832                   align
                    17833   
          0800 00E0 17834   DataEnd         equ       *                    this label will equate to the address of the last byte of global variable in it
          0000 00E0 17835   DataLength      equ       DataEnd-DataStart    length of data needed to copy to Ram on bootup
                    17836   
                    17837   *********************************************************************************************************
                    17838   * Section for uninitialised Data which is set to zero, i.e. we should set this space to zero at starup
                    17839   *********************************************************************************************************
          0800 00E0 17840   BssStart       equ       *
                    17841   
                    17842   _OSTmrTickCtr:
080000E0            17843          ds.b      1
                    17844   _OSCtxSwCtr:
080000E2            17845          ds.b      4
                    17846   _OSEventFreeList:
080000E6            17847          ds.b      4
                    17848   _OSEventTbl:
080000EA            17849          ds.b      220
                    17850   _OSFlagTbl:
080001C6            17851          ds.b      60
                    17852   _OSFlagFreeList:
08000202            17853          ds.b      4
                    17854   _OSCPUUsage:
08000206            17855          ds.b      1
                    17856   _OSIdleCtrMax:
08000208            17857          ds.b      4
                    17858   _OSIdleCtrRun:
0800020C            17859          ds.b      4
                    17860   _OSStatRdy:
08000210            17861          ds.b      1
                    17862   _OSTaskStatStk:
08000212            17863          ds.b      256
                    17864   _OSIntNesting:
08000312            17865          ds.b      1
                    17866   _OSLockNesting:
08000314            17867          ds.b      1
                    17868   _OSPrioCur:
08000316            17869          ds.b      1
                    17870   _OSPrioHighRdy:
08000318            17871          ds.b      1
                    17872   _OSRdyGrp:
0800031A            17873          ds.b      1
                    17874   _OSRdyTbl:
0800031C            17875          ds.b      8
                    17876   _OSRunning:
08000324            17877          ds.b      1
                    17878   _OSTaskCtr:
08000326            17879          ds.b      1
                    17880   _OSIdleCtr:
08000328            17881          ds.b      4
                    17882   _OSTaskIdleStk:
0800032C            17883          ds.b      256
                    17884   _OSTCBCur:
0800042C            17885          ds.b      4
                    17886   _OSTCBFreeList:
08000430            17887          ds.b      4
                    17888   _OSTCBHighRdy:
08000434            17889          ds.b      4
                    17890   _OSTCBList:
08000438            17891          ds.b      4
                    17892   _OSTCBPrioTbl:
0800043C            17893          ds.b      256
                    17894   _OSTCBTbl:
0800053C            17895          ds.b      1892
                    17896   _OSMemFreeList:
08000CA0            17897          ds.b      4
                    17898   _OSMemTbl:
08000CA4            17899          ds.b      120
                    17900   _OSQFreeList:
08000D1C            17901          ds.b      4
                    17902   _OSQTbl:
08000D20            17903          ds.b      96
                    17904   _OSTaskRegNextAvailID:
08000D80            17905          ds.b      1
                    17906   _OSTime:
08000D82            17907          ds.b      4
                    17908   _OSTmrFree:
08000D86            17909          ds.b      2
                    17910   _OSTmrUsed:
08000D88            17911          ds.b      2
                    17912   _OSTmrTime:
08000D8A            17913          ds.b      4
                    17914   _OSTmrSem:
08000D8E            17915          ds.b      4
                    17916   _OSTmrSemSignal:
08000D92            17917          ds.b      4
                    17918   _OSTmrTbl:
08000D96            17919          ds.b      576
                    17920   _OSTmrFreeList:
08000FD6            17921          ds.b      4
                    17922   _OSTmrTaskStk:
08000FDA            17923          ds.b      256
                    17924   _OSTmrWheelTbl:
080010DA            17925          ds.b      32
                    17926          section   heap
          0800 10FA 17927   end_RAM    equ         *				; wherever the program variables end, is the start of the heap
          0800 10FA 17928   heap       equ         *
                    17929   
          0801 0000 17930   __stack    equ         RAM+RAMsize     ; stack for main function, no longer needed after OSStart() is called
080010FA            17931                  align
                    17932   
          0800 10FA 17933   BssEnd         equ       *
          0000 101A 17934   BssLength      equ       BssEnd-BssStart       length of zeroed data needed to copy to Ram on bootup
                    17935   
                    17936   *********************************************************************************************************
                    17937   * Section for Heap
                    17938   *********************************************************************************************************
                    17939   
          0800 10FA 17940   heap           equ       *
080010FA            17941                  align
          0000 0000

Assembly errors: 4
